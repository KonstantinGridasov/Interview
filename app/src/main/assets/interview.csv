type;question;answer;;;;;;;;;;;;;;;;;;;;;;
ООП;Что такое ООП?;ООП - методология программирования, основанная на представлении программного продукта в виде совокупности объектов, каждый из которых является экземпляром конкретного класса. ООП использует в качестве базовых элементов взаимодействие объектов.;;;;;;;;;;;;;;;;;;;;;;
ООП;Что такое объект?;Объект - именнованная модель реальной сущности, обладающая конкретными значениями свойств и проявляющая свое поведение, обладающий именем набор данных (полей и свойств объекта), физически находящихся в памяти компьютера, и методов, имеющих доступ к ним. Объект -конкретный экземпляр класса.;;;;;;;;;;;;;;;;;;;;;;
ООП;Назовите основные принципы ООП.; Принято считать, что объектно-ориентированное программирование строится на 4 основных принципах (раньше их было всего 3). Эти принципы: <br>(Абстракция)<br>Инкапсуляция<br>Наследование<br>Полиморфизм   ;;;;;;;;;;;;;;;;;;;;;;
ООП;Что такое наследование?; Наследование это процесс благодаря которому один объект может приобрести свойства другого объекта (наследование всех свойств одного объекта другим) и добавлять черты характерны только для него самого !<br>  Суперкласс -> Подкласс Родительский -> Дочерний;;;;;;;;;;;;;;;;;;;;;;
ООП;Что такое полиморфизм? Какие проявления полиморфизма в Java Вы знаете?;" Полиморфизм (polymorphism) (от греческого polymorphos) - это свойство, которое позволяет одно и то же имя использовать для решения двух или более схожих, но технически разных задач. Целью полиморфизма, применительно к объектно-ориентированному программированию, является использование одного имени для задания общих для класса действий. Выполнение каждого конкретного действия будет определяться типом данных. В более общем смысле, концепцией полиморфизма является идея ""один интерфейс, множество методов"". Это означает, что можно создать общий интерфейс для группы близких по смыслу действий.  ";;;;;;;;;;;;;;;;;;;;;;
ООП;Что такое инкапсуляция?;Инкапсуляция (encapsulation) - это сокрытие реализации класса и отделение его внутреннего представления от внешнего (интерфейса), это свойство которое позволяет закрыть доступ к полям и методам класса другим классам, а предоставлять им доступ только через интерфейс(метод). При использовании объектно-ориентированного подхода не принято применять прямой доступ к свойствам какого-либо класса из методов других классов. Для доступа к свойствам класса принято задействовать специальные методы этого класса для получения и изменения его свойств.;;;;;;;;;;;;;;;;;;;;;;
ООП;Что такое aбстракция?;Абстракция - это выделение общих характеристик объекта,исключая набор незначительных. С помощью принципа абстракции данных, данные преобразуются в объекты. Данные обрабатываются в виде цепочки сообщений между отдельными объектами. Все объекты проявляют свои уникальные признаки поведения. Огромный плюс абстракции в том, что она отделяет реализацию объектов от их деталей, что в свою очередь позволяет управлять функциями высокого уровня через функции низкого уровня.  ;;;;;;;;;;;;;;;;;;;;;;
ООП;В чем преимущества объектно-ориентированных языков программирования?; Они представляют реальные объекты в  жизни, например, Машина, Джип, Счет в  банке и тд… Инкапсуляция, наследование и полиморфизм делает его еще мощнее.;;;;;;;;;;;;;;;;;;;;;;
ООП;Как использование объектно – ориентерованного подхода улучшает разработку программного обеспечения?;<br>повторное использование кода(наследование)   <br>   реальное отображение предметной  области. <br> Объекты соответствуют реальному миру(см. предыдущий пункт).  ;;;;;;;;;;;;;;;;;;;;;;
ООП;Имеется выражение «является» и «имеет». Что они подразумевают в плане принципов ООП? В чем разница между композицией и агрегацией?;" ""является"" - наследование ""имеет"" - композиция<br> В качестве примера предположим что у нас есть классы Строение, Дом и Ванная комната. Так вот Дом является строением, что нельзя сказать про Ванну, которая не является домом. А вот Дом имеет\включает в себя Ванну. Если  вы хотите использовать повторно код, то не обязательно использовать наследование. Если нет отношения ""является"", то лучше тогда использовать композицию для повторного использования кода. <br>Не  используйте наследование для получение полиморфизма, если нет ключевой зависимости ""является"". Используйте интерфейсы для полиморфизма. Из  спецификации можно узнать, что       Ассоциация  обозначает связь между объектами.      Агрегация и композиция это частные случаи ассоциации.  Агрегация предполагает, что объекты связаны  взаимоотношением ""part-of"" (часть).  Композиция  более строгий вариант агрегации. <br>Дополнительно к требованию part-of накладывается условие, что ""часть"" не может одновременно принадлежать разным ""хозяевам"", и заканчивает своё существование вместе с владельцем. Например:  <br>     мотоцикл -> cумка с багажём - ассоциация. Отношение ""имеет"".     мотоцикл -> колесо - композиция.      группа  по интересам -> человек - агрегация. человек часть группы, но может принадлежать нескольким разным группам.  ";;;;;;;;;;;;;;;;;;;;;;
ООП;Что вы подразумеваете под полиморфизмом, инкапсуляцией и динамическим связыванием?;" Полиморфизм означает способность  переменно данного типа, которая  ссылается на объекты разных  типов, при этом вызывается  метод, характерный для конкретного  типа ссылки на объект. В чем преимущество полиморфизма? Он позволяет добавлять новые классы производных объектов, не нарушая  при этом код вызова. Также использование полиморфизма называют динамическим связыванием объектов.  <br>  Рассмотрим  пример полиморфизма: Имеется классы: Фигура, круг и треугольник. Круг  и треугольник наследуется от фигуры соответственно. Каждый  класс имеет метод ""рисовать"". В круге и треугольнике этот метод  переопределен. Так вот, создаем объект с типом ""Фигура"" и присваиваем ей ссылку на объект типа ""Круг"" и вызываем на этом объекте  метод ""рисовать"". В итоге вызывается метод класса ""Круг"", а не класса ""Фигура"" как ожидалось.  Фигура  ф = new Круг()  Ф.рисовать()   Также вместо класса родителя ""Фигура"" к  примеру можно использовать интерфейс ""Фигура"", определив там метод рисовать. Этот интерфейс мы имплементируем в классах ""Круг"" ""Треугольник"". Далее на интерфейсе создаем объект и присваиваем ему ссылку на объект какого-то из реализующих этот интерфейс классов. Это удобно например если у нас есть некий метод:  public void drawShape(Фигура ф){ ф.рисовать()  }  <br>  Обратите  внимание что в метод мы передаем параметр с типом интерфейса, т.е. мы не знаем какой именно тип объекта будем, но реализация будет таже. Далее мы можем просто создать еще класс, к примеру ""Трапеция"", имплементировать и имплементировать интерфейс ""Фигура"" и просто передать экземпляр класса в метод, ничего не меняя в реализации и вызове. Наследование  это включение поведения(методы) и состояния(поля) базового класса в производный от него. В результате этого мы избегаем дублирования кода и процесс исправления ошибок в коде также упрощается.   <br>В джава есть два вида наследования:      наследование классов. Каждый  наследник может иметь толко одного родителя.     наследование  интерфейсов. Интерфейс может  иметь сколько угодно родителей.  Некоторые тонкие ньюансы по поводу наследования интрефейсов и классов. Мы  имеем два интерфейса с одинаковыми  по имени полями. Имплементируем эти  интерфейсы на каком-то классе. Как нам вызвать поля этих интерфейсов? У нас неоднозначность. Необходимо  объект класса привести к нужному  интерфейсу. Класс к = new Класс()  ((Интефейс1) к).поле     <br>  Хорошо, что будет если мы имеем метод с одинаковой сигнатурой в интерфейсах и реализуем эти интерфейсы на классе. Как нам в классе реализовать два метода с одинаковой сигнатурой??? Ответ: никак, мы просто реализовываем один общий метод в классе. Это является недостатком, так как нам  может потребоваться разная реализация.  И третий случай: У нас есть класс  и интерфейс с одинаковым по сигнатуре  методом. Мы наследуемся от этого  класса и имплементируем этот интерфейс. Что нам нужно делать? ведь необходимо реализовать метод интерфейса по всем правилам. И вот тут интересно, компилятор не выдает ошибок, так как метод уже  у нас реализован в классе родителе.";;;;;;;;;;;;;;;;;;;;;;
Java core.;Чем отличается JRE, JVM и JDK?; JRE кратко - для работы. Java Runtime Environment (сокр. JRE) - минимальная реализация виртуальной машины, необходимая для исполнения Java-приложений, без компилятора и других средств разработки. Состоит из виртуальной машины - Java Virtual Machine и библиотеки Java-классов. JDK кратко - для программирования. Java Development Kit (сокращенно JDK) - бесплатно распространяемый компанией Oracle Corporation (ранее Sun Microsystems) комплект разработчика приложений на языке Java, включающий в себя компилятор Java (javac), стандартные библиотеки классов Java, примеры, документацию, различные утилиты и исполнительную систему Java (JRE). Java Virtual Machine (сокращенно Java VM, JVM) - виртуальная машина Java - основная часть исполняющей системы Java, так называемой Java Runtime Environment (JRE). Виртуальная машина Java интерпретирует Байт-код Java, предварительно созданный из исходного текста Java-программы компилятором Java (javac). JVM может также использоваться для выполнения программ, написанных на других языках программирования.;;;;;;;;;;;;;;;;;;;;;;
Java core.;Опишите модификаторы доступа в Java.;В Java существуют следующие модификаторы доступа:    <br>private: (используется конструкторах, внутренних классах, методах и полях класса) - Доступ разрешен только в текущем классе.      <br>default (package-private): (используется в классах, конструкторах, интерфейсах, внутренних классах, методах и полях класса) - Доступ на уровне пакета. Если класс будет так объявлен он будет доступен только внутри пакета.      <br>protected: (используется конструкторах, внутренних классах, методах и полях класса) Модификатор доступа на уровне пакета и в иерархии наследования.      <br>public: (используется в классах, конструкторах, интерфейсах, внутренних классах, методах и полях класса) - Модификатор доступа общественный, доступен всем.   Последовательность модификаторов по убыванию уровня закрытости: private, default ,protected, public).  ;;;;;;;;;;;;;;;;;;;;;;
Java core.;Что такое package level access.; Доступ из классов одного package-а в классы другого package-a.;;;;;;;;;;;;;;;;;;;;;;
Java core.;Чем абстрактный клас отличается от интерфейса? В каких случаях Вы бы использовали абстрактный класс, а в каких интерфейс?;"Абстрактный класс это класс, который помечен как ""abstract"", он может содержать абстрактные методы, а может их и не содержать.   Экземпляр абстрактного класса нельзя создать. Класс, который наследуется от абстрактного класса может реализовывать абстрактные методы, а может и не реализовывать, тогда класс наследник должен быть тоже абстрактным. Также если класс наследник переопределяет реализованный в абстрактном классе родители метод, его можно переопределить с модификатором абстракт! Т.е отказаться от реализации. Соответственно данный класс должен быть также абстрактным также.  <br>Что касается интерфейса, то в нем находятся только абстрактные методы и константы, так было до выхода Java 8. Начиная с Java 8 кроме абстрактных методов мы также можем использовать в интерфейсах стандартные методы (default methods) и статические методы (static methods). <br>Default метод в интерфейсе - это метод в интерфейсе с по умолчанию реализованной логикой, который не требуется обязательно определять в реализации этого интерфейса.  <br>Static методы в интерфейсе - это по существу то же самое, что static-методы в абстрактном классе.  При реализации интерфейса, класс обязан реализовать все методы интерфейса. Иначе класс должен быть помечен как абстрактный. Интерфейс также может содержать внутренние классы. И не абстрактные методы в них. Что же использовать Интерфейс или Абстрактный класс? Абстрактный класс используется когда нам нужна какая-то реализация по умолчанию. Интерфейс используется когда классу нужно указать конкретное поведение. Часто интерфейс и абстрактный класс комбинируют, т.е. имплементируют интерфейс в абстрактном классе, чтоб указать поведение и реализацию по умолчанию. Это хорошо видно на примере свига: Мы создаем свою модель таблицы с определенным поведением и уже с реализацией по умолчанию.  ВАЖНО! При реализации интерфейса, необходимо реализовать все его методы, иначе будет Fatal error, так же это можно избежать, присвоив слово abstract. ";;;;;;;;;;;;;;;;;;;;;;
Java core.;Может ли объект получить доступ к private-переменной класса? Если, да, то каким образом?;Вообще доступ у приватной переменной класса можно получить только внутри класса, в котором она объявлена. Также доступ к приватным переменным можно осуществить через механизм Java Reflection API.;;;;;;;;;;;;;;;;;;;;;;
Java core.;Для чего в джаве статические блоки?;Статические блоки в джава выполняются до выполнения конструктора, с помощью них инициализируют статические поля к примеру. Еще один ньюанс, блок статической инициализации может создаваться сам при компиляции программы:;;;;;;;;;;;;;;;;;;;;;;
Java core.;Можно ли перегрузить static метод?;Статические методы могут перегружаться нестатическими и наоборот - без ограничений. А вот в переопределении статического метода смысла нет.;;;;;;;;;;;;;;;;;;;;;;
Java core.;Расскажите про внутренние классы. Когда вы их будете использовать?;Внутренний  класс - это класс, который  находится внутри класса или интерфейса. При этом он получает доступ ко всем полям и методам своего внешнего класса.  Для чего он может применятся? Например чтоб обеспечить какую-то дополнительную логику класса. Хотя использование внутренних классов усложняет программу, рекомендуется избегать их использование.;;;;;;;;;;;;;;;;;;;;;;
Java core.;В чем разница между переменной экземпляра и статической переменной? Приведите пример.;Статические переменные инициализируются при загрузке класса класслодером, и не зависят от объекта. Переменная экземпляра инициализируется при создании класса. Пример: Например нам нужна глобальная переменная для всех объектов класс, например число посещений пользователей определенной статьи в интернете. При каждом новом посещении статьи создается новый объект и инкрементируется переменная посещений.;;;;;;;;;;;;;;;;;;;;;;
Java core.;Приведите пример когда можно использовать статический метод?;Статические методы могут быть использованы для  инициализации статических переменных. Часто статические методы используются в классах утилитах, таких как  Collections, Math, Arrrays;;;;;;;;;;;;;;;;;;;;;;
Java core.;Расскажите про классы- загрузчики и про динамическую зарузку классов.;"Любой класс, используемый в джава программу так или иначе был загружен в контекст программы каким-то загрузчиком. Все виртуальные машины джава включают хотябы один загрузчик классов, так называем базовый загрузчик. Он загружает все основные классы, это классы из rt.jar. Интересно то, что этот загрузчик никак не связан с программой, тоесть мы не можем получить например у java.lang.Object имя зарузчика, метод getClassLoader() вернет нам null.   <br> Следующий загрузчик - это  загрузчик расширений, он загружает  классы из $JAVA_HOME/lib/ext.   <br> Далее по иерархии идет системный  загрузчик, он загружает классы, путь к которым указан в переменно класпас.   <br> Для примера предположим что у нас есть некий пользовательский класс MyClass и мы его используем. Как идет его загрузка… : <br>Сначала системный загрузчик пытается найти  его в своем кэше загрузок его, если найден - класс успешно загружается, иначе управление загрузкой передается загрузчику расширений, он также проверяет  свой кэш загрузок и в случае неудачи  передает задачу базовому загрузчику. Тот проверяет кэш и в случае неудачи пытается его загрузить, если загрузка прошла успешно -  загрузка закончена. Если нет - передает управление загрузчику расширений. Загрузчик  расширений пытается загрузить класс  и в случае неудачи передает это  дело системному загрузчику. Системный  загрузчик пытается загрузить класс  и в случае неудачи возбуждается исключение java.lang.ClassNotFoundException.   <br> Вот так работает загрузка классов в  джава. Так называемое делегирование загрузки.   Если  в системе присутствуют пользовательские загрузики, то они должны быть унаследованы от класса java.lang.ClassLoader .<br> Что же такое статическая и что  такое динамическая загрузка класса?   Статическая загрузка класса происходит при использовании  оператора ""new"".   <br>Динамическая  загрузка происходит ""на лету"" в  ходе выполнения программы с помощью  статического метода класса Class.forName(имя класса). Для чего нужна динамическая загрузка? Например мы не знаем какой класс нам понадобится и принимаем решение в ходе выполнения программы передавая имя класса в статический метод forName().";;;;;;;;;;;;;;;;;;;;;;
Java core.;Что такое статическая и что такое динамическая загрузка класса?;;;;;;;;;;;;;;;;;;;;;;;
Java core.;"Для чего нужен оператор ""assert"" в джава?";" Это так называемый оператор  утверждений. Он проверяет некое  условие, если оно ложно, то  генерируется AssertationError assert status: ""message error""  Тут проверяется булевская переменная ""status"".";;;;;;;;;;;;;;;;;;;;;;
Java core.;Почему в некоторых интерфейсах вообще не определяют методов?;Это так называемые интерфейсы - маркеры. Они просто указывают что класс относится к определенной группе классов. Например интерфейс Clonable указывает на то, что класс поддерживает механизм клонирования. Степень абстракции в данном случае доведен до абсолюта. В интерфейсе вообще нет никаких объявлений. Интерфейси-маркери в Java:      Searilizable interface     Cloneable interface     Remote interface     ThreadSafe interface  ;;;;;;;;;;;;;;;;;;;;;;
Java core.;Какая основная разница между String, StringBuffer, StringBuilder?;String - неизменяемый класс, тоесть для для добавление данных в уже существующую строку, создается новый объект строки. StringBuffer и StringBuilder могут изменятся и добавление строки не такое дорогостоющее с точки зрения памяти. Первы - синхронизированный, второй - нет. Это их единственное различие. Правда  если нам нужно сделать подстроку  строки, то лучше использовать String, так как ее массив символов не меняется и не создается заново для новой строки. А вот в StringBuffer и StringBuilder для создания подстроки создается новый массив символов.  ;;;;;;;;;;;;;;;;;;;;;;
Java core.;Расскажите про потоки ввода-вывода Java.;"Потоки  ввода-вывода бывают двух видов:      байтовый поток(InputStream и OutputStream)      символный поток(Reader и Writer)   Это все абстрактные классы - декораторы, которым можно добавлять дополнительный функционал, например: InputStream in = new FileInputStream(new File(""file.txt"")) ";;;;;;;;;;;;;;;;;;;;;;
Java core.;Что такое Heap и Stack память в Java?;" Java Heap (куча)  - динамически распредляемая область памяти, создаваемая при старте JVM. Используется Java Runtime для выделения памяти под объекты и JRE классы. Создание нового объекта также происходит в куче. Здесь работает сборщик мусора: освобождает память путем удаления объектов, на которые нет каких-либо ссылок. Любой объект, созданный в куче, имеет глобальный доступ и на него могут ссылаться с любой части приложения. Cтрогими тезами:      Все обьекты обитают в куче и попадают туда при создании.     обьект состоит из полей класса и методов.     в куче выделяется место под сам обьект, количество выделенной памяти зависит от полей, если у тебя полем класса, к примеру, служит интовая переменная, то не важно, инициализируешь ты ее как ""0"" или как ""1000000"" - обьект займет в куче свои биты, + столько байт сколько вмещает тип int(+32 бита), и так с каждым полем.  Стековая память в Java работает по схеме LIFO (Последний-зашел-Первый-вышел). Всякий раз, когда вызывается метод, в памяти стека создается новый блок, который содержит примитивы и ссылки на другие объекты в методе расположение в RAM и достижение процессору через указатель стека. Как только метод заканчивает работу, блок также перестает использоваться, тем самым предоставляя доступ для следующего метода. Размер стековой памяти намного меньше объема памяти в куче. Cтрогими тезами:      Все методы обитают в стеке и попадают туда при вызове.     Переменные в методах так же имеют стековую память, по скольку они локальные.     Если в методе создается обьект, то он помещается в кучу, но его ссылка все еще будет находится в стеке и после того как метод покинет стек - обьект станет жертвой сборщика мусора, так как ссылка на него утеряна, и из главного стека программы невозможно будет добраться до такого обьекта.   ";;;;;;;;;;;;;;;;;;;;;;
Java core.;Какая разница между Stack и Heap памятью в Java?; Приведем следующие различия между Heap и Stack памятью в Java.      Куча используется всеми частями приложения в то время как стек используется только одним потоком исполнения программы.     Всякий раз, когда создается объект, он всегда хранится в куче, а в памяти стека содержится ссылка на него. Память стека содержит только локальные переменные примитивных типов и ссылки на объекты в куче.     Объекты в куче доступны с любой точки программы, в то время как стековая память не может быть доступна для других потоков.     Управление памятью в стеке осуществляется по схеме LIFO.     Стековая память существует лишь какое-то время работы программы, а память в куче живет с самого начала до конца работы программы.     Мы можем использовать -Xms и -Xmx опции JVM, чтобы определить начальный и максимальный размер памяти в куче. Для стека определить размер памяти можно с помощью опции -Xss .     Если память стека полностью занята, то Java Runtime бросает java.lang.StackOverflowError, а если память кучи заполнена, то бросается исключение java.lang.OutOfMemoryError: Java Heap Space.     Размер памяти стека намного меньше памяти в куче. Из-за простоты распределения памяти (LIFO), стековая память работает намного быстрее кучи. ;;;;;;;;;;;;;;;;;;;;;;
Java core.;Расскажите про модель памяти в джава?; В Джаве память устроена следующим  образом, есть два вида:      куча     стек  Куча  состоит из статического контекста  и самой кучи Перейдем  к куче. Куча состоит из двух частей:      Новая куча     Старая куча  Новая куча в свою очередь состоит из двух частей:      Eden(назовем ее первая) куча     Survival(выжившая) куча  Краткое описание:      Eden Space (heap) - в этой области выделятся память под все создаваемые из программы объекты. Большая часть объектов живет недолго (итераторы, временные объекты, используемые внутри методов и т.п.), и удаляются при выполнении сборок мусора это области памяти, не перемещаются в другие области памяти. Когда данная область заполняется (т.е. количество выделенной памяти в этой области превышает некоторый заданный процент), GC выполняет быструю (minor collection) сборку мусора. По сравнению с полной сборкой мусора она занимает мало времени, и затрагивает только эту область памяти - очищает от устаревших объектов Eden Space и перемещает выжившие объекты в следующую область.      Survivor Space (heap) – сюда перемещаются объекты из предыдущей, после того, как они пережили хотя бы одну сборку мусора. Время от времени долгоживущие объекты из этой области перемещаются в Tenured Space.     Tenured (Old) Generation (heap) - Здесь скапливаются долгоживущие объекты (крупные высокоуровневые объекты, синглтоны, менеджеры ресурсов и проч.). Когда заполняется эта область, выполняется полная сборка мусора (full, major collection), которая обрабатывает все созданные JVM объекты.     Permanent Generation (non-heap) - Здесь хранится метаинформация, используемая JVM (используемые классы, методы и т.п.).    ;;;;;;;;;;;;;;;;;;;;;;
Java core.;Как работает сборщик мусора (garbage collector)?; Во-первых что стоит сказать, что у сборщика мусора есть несколько алгоритмов работы, он не один. Когда происходит очистка памяти? Если память в Первой куче полностью заполнена, то туда идет сборщик мусора и делает свою работу) Какую именно, зависит  от обстоятельств… Например если в  первой кучи много мусора(т.е. объектов с нулевой ссылкой), то сборщик мусора помечает эти объекты, далее те что остались объекты со ссылками он их переносит в Выжившую кучу, а в первой куче он просто все удаляет.  Ситуация  другая, в первой кучи мало мусора, но очень много рабочих объектов. Как поступает в этом случае сборщик  мусора? Он  помечает мусор, удаляет его и  оставшиеся объекты компонует. Также следует заметить что при нехватке места в Выжившей куче, объекты  переносятся в старую кучу, там  хранятся как правило долго живущие объекты. Также следует заметить что сборщик мусора вызывается сам периодически, а не только когда памяти не хватает.;;;;;;;;;;;;;;;;;;;;;;
Java core.;Расскажите про приведение типов. Что такое понижение и повышение типа? Когда вы получаете ClassCastException?; Приведение  типов это установка типа переменной или объекта отличного от текущего. В ждава есть два вида приведения:      автоматическое     не автоматическое  Автоматическое  происходит например: byte-> short->int->long->float->double тоесть если мы расширяем тип, то явное преобразование не требуется, приведение происходит автоматически. Если же мы сужаем, то необходимо явно указывать приведение типа. В случае же с объектами, то мы можем  сделать автоматическое приведение от наследника к родителю, но никак  не наоборот, тогда вылетит ClassCastException.;;;;;;;;;;;;;;;;;;;;;;
Java core.;Что такое статический класс, какие особенности его использования?; Статическим классом может быть только внутренний клас(определение класса размещается внутри другого класса). В объекте обычного внутреннего класса хранится ссылка на объект внешнего класса. Внутри статического внутреннего класса такой ссылки нет. То есть: Для создания объекта статического внутреннего класса не нужен объект внешнего класса. Из объекта статического вложенного класса нельзя обращаться к нестатическим членам внешнего класса напрямую. И еще обычные внутренние классы не могут содержать статические методы и члены. Зачем вообще нужны внутренние классы? – Каждый внутренний класс способен независимо  наследовать определенную реализацию. Таким образом внутренний класс не ограничен при наследовании в ситуациях, когда внешний класс уже наследует реализацию. То есть это как бы вариант решения проблемы множественного наследования.;;;;;;;;;;;;;;;;;;;;;;
Java core.;Каким образом из вложенного класса получить доступ к полю внешнего класса.;Если класс внутренний то: Внешнийкласс.this.Поле внешнего класса Если класс статический внутренний(вложенный),то в методе нужно создать объект внешнего класса, и получить доступ к его полю.Или второй вариант  объявить это поле внешнего класса как  static;;;;;;;;;;;;;;;;;;;;;;
Java core.;Какие существуют типы вложенных классов? Для чего они используются?; Вложенные классы существуют внутри других классов.  Нормальный класс - полноценный член пакета. Вложенные классы, которые стали доступны начиная с Java 1.1, могут быть четырех типов:      статические члены класса     члены класса     локальные классы     анонимные классы  Статические члены классов (static nested classes) - как и любой другой статический метод, имеет доступ к любым статическим методам своего внешнего класса, в том числе и к приватным. К нестатическим полям и методам обрамляющего класса он не может обращатся напрямую. Он может использовать их только через ссылку на экземпляр класса родителя. Члены класса - локальные классы, объявленные внутри блока кода. Эти классы видны только внутри блока. Анонимные классы -  Эти типы классов не имеют имени и видны только внутри блока.;;;;;;;;;;;;;;;;;;;;;;
Java core.;Возможно ли при переопределении (override) метода изменить: (Модификатор доступа Возвращаемый тип Тип аргумента или количество Имя аргументов Изменять порядок, количество или вовсе убрать секцию throws?);"  Да, если расширять (package -> protected -> public)     Да, если выполняется Downcasting(понижающее преобразование, преобразование вниз по иерархии) то есть возвращаемый тип в переопределенном методе класса наследника должен быть НЕ шире чем в классе родителе (Object -> Number -> Integer)     Нет, в таком случае происходит Overload(перегрузка)     Да     Возможно изменять порядок. Возможно вовсе убрать секцию throws в методе, так как она уже определена. Так же возможно добавлять новые исключения, которые наследуются от объявленных или исключения времени выполнения.  Переопределение методов действует при наследовании классов, т.е. в классе наследнике объявлен метод с такой же сигнатурой что и в классе родителе. Значит этот метод переопределил метод своего суперкласса. Несколько нюансов по этому поводу:      Модификатор доступа в методе класса наследника должен быть НЕ уже чем в классе родителе, иначе будет ошибка компиляции.     Описание исключения в переопределенном методе класса наследника должен быть НЕ шире чем в классе родителе, иначе ошибка компиляции.     Метод обьявленный как ""private"" в классе родителе нельзя переопределить!  ";;;;;;;;;;;;;;;;;;;;;;
Java core.;Что такое autoboxing?;Autoboxing/Unboxing - автоматическое преобразование между скалярными типами Java и соответствующими типами-врапперами (например, между int - Integer). Наличие такой возможности сокращает код, поскольку исключает необходимость выполнения явных преобразований типов в очевидных случаях.;;;;;;;;;;;;;;;;;;;;;;
Java core.;Что такое Generics?;" ""Java Generics"" - это технический термин, обозначающий набор свойств языка позволяющих определять и использовать обобщенные типы и методы. Обобщенные типы или методы отличаются от обычных тем, что имеют типизированные параметры.  Примером дженериков или обобщенных типов может служить библитека с коллекциями в Java. Например, класс LinkedList<E> - типичный обобщенный тип. Он содержит параметр E, который представляет тип элементов, которые будут храниться в коллекции. Вместо того, чтобы просто использовать LinkedList, ничего не говоря о типе элемента в списке, мы можем использовать LinkedList<String> или LinkedList<Integer>.  Создание объектов обобщенных типов происходит посредством замены параметризированных типов реальными типами данных. Класс типа LinkedList<E> -  обобщенный тип, который содержит параметр E. Создание объектов, типа LinkedList<String> или LinkedList<Integer> называются параметризированными типами, а String и Integer - реальные типы аргументов.   ";;;;;;;;;;;;;;;;;;;;;;
Java core.;Какова истинная цель использования обобщенных типов в Java?; Обобщенные типы в Java были изобретены, в первую очередь, для реализации обобщенных коллекций.;;;;;;;;;;;;;;;;;;;;;;
Java core.;Каким образом передаются переменные в методы, по значению или по ссылке?; В java параметры в методы передаются по значению, тоесть создаются копии параметров и с ними ведется работа в методе. В случае с примитивными типами, то при передачи параметра сама переменная не будет меняться так как в метод просто копируется ее значение. А вот при передачи объекта копируется ссылка на объект, тоесть если в методе мы поменяем состояние объекта, то и за методом состояние объекта тоже поменяется. Но если мы этой копии ссылки попытаемся присвоить новую ссылку на обьект, то старая ссылка у нас не изменится.  В случае передачи по значению параметр копируется. Изменение параметра не будет заметно на вызывающей стороне.  В Java объекты всегда передаются по ссылке, а примитивы - по значениюю.;;;;;;;;;;;;;;;;;;;;;;
Java core.;Какие методы есть у класса Object?; Object это базовый класс для всех остальных объектов в Java. Каждый класс наследуется от Object. Соответственно все классы наследуют методы класса Object. Методы класса Object:      public final native Class getClass()     public native int hashCode()     public boolean equals(Object obj)     protected native Object clone() throws CloneNotSupportedException     public String toString()     public final native void notify()     public final native void notifyAll()     public final native void wait(long timeout) throws InterruptedException     public final void wait(long timeout, int nanos) throws InterruptedException     public final void wait() throws InterruptedException     protected void finalize() throws Throwable  ;;;;;;;;;;;;;;;;;;;;;;
Java core.;Правила переопределения метода Object.equals().;"      Используйте оператор == что бы проверить ссылку на объект, переданную в метод equals. Если ссылки совпадают - вернуть true. Это не обязательно, нужно скорее для оптимизации, но может сэкономить время в случае ""тяжёлых"" сравнений.     Используйте оператор instanceof для проверки типа аргумента. Если типы не совпадают, вернуть false.      Преобразуйте аргумент к корректному типу. Так как на предыдущем шаге мы выполнили проверку, преобразование корректно.      Пройтись по всем значимым полям объектов и сравнить их друг с другом. Если все поля равны - вернуть true. Для сравнения простых типов использовать ==. Для полей со ссылкой на объекты использовать equals. float преобразовывать в int  с помощью Float.floatToIntBits и сравнить с помощью ==. double преобразовывать в long  с помощью Double.doubleToLongBits и сравнить с помощью ==. Для коллекций вышеперечисленные правила применяются к каждому элементу коллекции. Нужно учитывать возможность null полей/объектов. Очерёдность сравнения полей может существенно влиять на производительность.     Закончив реализацию equals задайте себе вопрос, является ли метод симметричным, транзитивным и непротиворечивым.  И ещё несколько дополнительных правил.      Переопределив equals, всегда переопределять hashCode.     Не использовать сложную семантику в equals (типа определения синонимов). equals должен сравнивать поля объектов, не более.  ";;;;;;;;;;;;;;;;;;;;;;
Java core.;Если вы хотите переопределить equals(), какие условия должны удовлетворяться для переопределенного метода?; Метод equals() обозначает отношение эквивалентности объектов. Эквивалентным называется отношение, которое является симметричным, транзитивным и рефлексивным.      Рефлексивность: для любого ненулевого x, x.equals(x) вернет true      Транзитивность: для любого ненулевого x, y и z, если x.equals(y) и y.eqals(z) вернет true, тогда и x.equals(z) вернет true      Симметричность: для любого ненулевого x и y, x.equals(y) должно вернуть true, тогда и только тогда, когда y.equals(x) вернет true.  Также для любого ненулевого x, x.equals(null) должно вернуть false.;;;;;;;;;;;;;;;;;;;;;;
Java core.;Какая связь между hashCode и equals?; Объекты равны, когда a.equals(b)=true и a.hashCode==b.hashcode ->true Но необязательно, чтобы два различных объекта возвращали различные хэш коды(такая ситуация называется коллизией).;;;;;;;;;;;;;;;;;;;;;;
Java core.;Каким образом реализованы методы hashCode и equals в классе Object?; Реализация метода equals в классе Object сводится к проверке на равенство двух ссылок: Реализация же метода hashCode класса Object сделана нативной, т.е. определенной не с помощью Java-кода: Он обычно возвращает адрес объекта в памяти;;;;;;;;;;;;;;;;;;;;;;
Java core.;Что будет, если переопределить equals не переопределяя hashCode? Какие могут возникнуть проблемы?; Они будут неправильно хранится в контейнерах, использующих хэш коды, таких как HashMap, HashSet. Например HashSet хранит элементы в случайном (на первый взгляд) порядке. Дело в том, что для быстрого поиска HashSet расчитывает для каждлого элемента hashCode и именно по этому ключу ищет и упорядочивает элементы внутри себя;;;;;;;;;;;;;;;;;;;;;;
Java core.;Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode?; Есть. Необходимо использовать уникальные, лучше примитивные поля, такие как id, uuid, например. Причем, если эти поля задействованы при вычислении hashCode, то нужно их задействовать при выполнении equals. Общий совет: выбирать поля, которые с большой долью вероятности будут различаться.;;;;;;;;;;;;;;;;;;;;;;
Java core.;Для чего нужен метод hashCode()?;Существуют коллекции(HashMap, HashSet), которые используют хэш код, как основу при работе с объектами. А если хэш для равных объектов будет разным, то в HashMap будут два равных значения, что является ошибкой. Поэтому необходимо соответствующим образом переопределить метод hashCode(). Х   Хеширование - преобразование входного массива данных произвольной длины в выходную битовую строку фиксированной длины. Такие преобразования также называются хеш-функциями или функциями свёртки, а их результаты называют хешем или хеш-кодом. Хе Хеш-таблице - это структура данных, реализующая интерфейс ассоциативного массива, а именно, она позволяет хранить пары (ключ, значение) и выполнять три операции: операцию добавления новой пары, операцию поиска и операцию удаления пары по ключу. Выполнение операции в хеш-таблице начинается с вычисления хеш-функции от ключа. Получающееся хеш-значение i = hash(key) играет роль индекса в массиве H. Затем выполняемая операция (добавление, удаление или поиск) перенаправляется объекту, который хранится в соответствующей ячейке массива H[i]. Одним из методов построения хеш-функции есть метод деления с остатком (division method) состоит в том, что ключу k ставится в соответствие остаток от деления k на m, где m - число возможных хеш-значений.  ;;;;;;;;;;;;;;;;;;;;;;
Java core.;Правила переопределения метода Object.hashCode().; При реализации hashCode используется несколько простых правил. Прежде всего, при вычислении хеш-кода следует использовать те же поля, которые сравниваются в equals. Это, во-первых, даст равенство хеш-кодов для равных обектов, во-вторых, распределено полученное значение будет точно так же, как и исходные данные. Теоретически, можно сделать так, чтобы хеш-код всегда был равен 0, и это будет абсолютно легальная реализация. Другое дело, что ее ценность будет равна тому же самому нулю. Далее. Несмотря на то, что хеш-коды равных объектов должны быть равны, обратное неверно! Два неравных объекта могут иметь равные хеш-коды. Решающее значение имеет не уникальность, а скорость вычисления, потому как это приходится делать очень часто. Потому, в некоторых случаях имеет смысл посчитать хеш-код заранее и просто выдавать его по запросу. Прежде всего это стоит делать тогда, когда вычисление трудоемко, а объект неизменен.;;;;;;;;;;;;;;;;;;;;;;
Java core.;Расскажите про клонирование объектов. В чем отличие между поверхностным и глубоким клонированием?;" Чтобы объект можно было клонировать, он должен реализовать интерфейс Cloneable(маркер). Использование этого интерфейса влияет на поведение метода ""clone"" класс Object. Таким образом  myObj.clone() создаст нам клон нашего объекта, но этот клон будет поверхностный. Что значит поверхностным? Это значит что клонируется только примитивные поля класса, ссылочные поля не клонируются! Для того, чтоб произвести глубокое клонирование, необходимо в клонируемом классе переопределить метод clone() и в нем произвести клонирование изменяемых полей объекта.  ";;;;;;;;;;;;;;;;;;;;;;
Java core.;Правила переопределения метода Object.clone().; Метод clone() в Java используется для клонирования объектов. Т.к. Java работает с объектами с помощью ссылок, то простым присваиванием тут не обойдешься, ибо в таком случае копируется лишь адрес, и мы получим две ссылки на один и тот же объект, а это не то, что нам нужно. Механизм копирования обеспечивает метод clone() класса Object.  clone() действует как конструктор копирования. Обычно он вызывает метод clone() суперкласса и т.д. пока не дойдет до Object.  Метод clone() класса Object создает и возвращает копию объекта с такими же значениями полей. Object.clone() кидает исключение CloneNotSupportedException если вы пытаетесь клонировать объект не реализующий интерфейс Cloneable. Реализация по умолчанию метода Object.clone() выполняет неполное/поверхностное (shallow) копирование. Если вам нужно полное/глубокое (deep) копирование класса то в методе clone() этого класса, после получения клона суперкласса, необходимо скопировать нужные поля.  Синтаксис вызова clone() следующий:;;;;;;;;;;;;;;;;;;;;;;
Java core.;Где и как вы можете использовать закрытый конструктор?;Например в качестве паттерна Синглетон. В том же классе создается статический метод. Где и создается экземпляр класса, конечно если он уже не создан, тогда он просто возвращается методом.;;;;;;;;;;;;;;;;;;;;;;
Java core.;Что такое конструктор по умолчанию?;" В Java если нет явным образом опредёленных конструкторов в классе, то компилятор использует конструктор по умолчанию, опредёленный неявным способом, который аналогичен ""чистому"", конструктору по умолчанию. Конструктор по умолчанию - это довольно простая конструкция, которая сводится к созданию для типа конструктора без параметров. Так, например, если при объявлении нестатического класса не объявить пользовательский конструктор (не важно, с параметрами или без них), то компилятор самостоятельно сгенерирует конструктор без параметров. Некоторые программисты явным образом задают конструктор по умолчанию по привычке, чтобы не забыть в дальнейшем, но это не обязательно В Java если производный класс не вызывает явным образом конструктор базового класса (в Java используя super() в первой строчке), то конструктор по умолчанию вызывается неявно. Если базовый класс не имеет конструктора по умолчанию, то это считается ошибкой.";;;;;;;;;;;;;;;;;;;;;;
Java core.;Опишите метод Object.finalize().; Метод finalize(). Java обеспечивает механизм, который является аналогичным использованию деструкторов в С ++, который может использоваться для того, чтобы произвести процесс очистки перед возвращением управления операционной системе.  Применяя метод finalize(), можно определять специальные действия, которые будут выполняться тогда, когда объект будет использоваться сборщиком мусора. Данный метод вызывается при уничтожении объекта автоматическим сборщиком мусора (garbage collector). В классе Object он ничего не делает, однако в классе-наследнике позволяет описать все действия, необходимые для корректного удаления объекта, такие как закрытие соединений с БД, сетевых соединений, снятие блокировок на файлы и т.д. В обычном режиме напрямую этот метод вызывать не нужно, он отработает автоматически. Если необходимо, можно обратиться к нему явным образом. Его синтаксис:  protected void finalize( ) throws Throwable  Ссылки не являются собранным мусором  только объекты - собранный мусор.;;;;;;;;;;;;;;;;;;;;;;
Java core.;Чем отличаются слова final, finally и finalize?; final - Нельзя наследоваться от файнал класса. Нельзя переопределить файнал метод. Нельзя изменить сначение файнал поля. finally - используется при обработке ошибок, вызывается всегда, даже если произошла ошибка(кроме System.exit(0)). Удобно использовать для освобождения ресурсов. finalize() - вызывается перед тем как сборщик мусора будет проводить освобождение памяти. Не рекомендуется использовать для освобождения системных ресурсов, так как не известно когда сборщик мусора будет производить свою очистку. Вообще данный метод мало кто использует. Единственно что можно использовать этот метод для закрытия ресурса что должен работать на протяжении всей работы программы и закрываться по ее окончанию. Еще можно использовать метод для защиты от так называемых «дураков», проверять, освобождены ли ресурсы, если нет, то закрыть их.;;;;;;;;;;;;;;;;;;;;;;
Java core.;Опишите иерархию исключений.;" Все классы-исключения расширяют класс Throwable - непосредственное расширение класса object.  У класса Throwable и у всех его расширений по традиции два конструктора:        Throwable о - конструктор по умолчанию       Throwable (String message) - создаваемый объект будет содержать произвольное сообщение message.   Записанное в конструкторе сообщение можно получить затем методом getMessage (). Если объект создавался конструктором по умолчанию, то данный метод возвратит null.  Метод toString возвращает краткое описание события, именно он работал в предыдущих листингах.  Три метода выводят сообщения обо всех методах, встретившихся по пути ""полета"" исключения:       printstackTrace() - выводит сообщения в стандартный вывод, как правило, это консоль       printStackTrace(PrintStream stream) - выводит сообщения в байтовый поток stream       printStackTrace(PrintWriter stream) - выводит сообщения в символьный поток stream.   У класса Throwable два непосредственных наследника - классы Error и Exception. Они не добавляют новых методов, а служат для разделения классов-исключений на два больших семейства - семейство классов-ошибок (error) и семейство собственно классов-исключений (exception).  Классы-ошибки, расширяющие класс Error, свидетельствуют о возникновении сложных ситуаций в виртуальной машине Java. Их обработка требует глубокого понимания всех тонкостей работы JVM. Ее не рекомендуется выполнять в обычной программе. Не советуют даже выбрасывать ошибки оператором throw. He следует делать свои классы-исключения расширениями класса Error или какого-то его подкласса.   Имена классов-ошибок, по соглашению, заканчиваются словом Error.  Классы-исключения, расширяющие класс Exception, отмечают возникновение обычной нештатной ситуации, которую можно и даже нужно обработать. Такие исключения следует выбросить оператором throw. Классов-исключений очень много, более двухсот. Они разбросаны буквально по всем пакетам J2SDK. В большинстве случаев вы способны подобрать готовый класс-исключение для обработки исключительных ситуаций в своей программе. При желании можно создать и свой класс-исключение, расширив класс Exception или любой его подкласс.   Среди классов-исключений выделяется класс RuntimeException - прямое расширение класса Exception. В нем и его подклассах отмечаются исключения, возникшие при работе JVM, но не столь серьезные, как ошибки. Их можно обрабатывать и выбрасывать, расширять своими классами, но лучше доверить это JVM, поскольку чаще всего это просто ошибка в программе, которую надо исправить. Особенность исключений данного класса в том, что их не надо отмечать в заголовке метода пометкой throws.   Имена классов-исключений, по соглашению, заканчиваются словом Exception.";;;;;;;;;;;;;;;;;;;;;;
Java core.;Какие виды исключений в Java вы знаете, чем они отличаются?; Все исключительные ситуации можно разделить на две категории: проверяемые(checked) и непроверяемые(unchecked). Все исключения, порождаемые от Throwable, можно разбить на три группы. Они определяются тремя базовыми типами: наследниками Throwable - классами Errorи Exception, а также наследником Exception - RuntimeException. Ошибки, порожденные от Exception (и не являющиеся наследниками RuntimeException ), являются проверяемыми. Т.е. во время компиляции проверяется, предусмотрена ли обработка возможных исключительных ситуаций. Как правило, это ошибки, связанные с окружением программы (сетевым, файловым вводом-выводом и др.), которые могут возникнуть вне зависимости от того, корректно написан код или нет. Например, открытие сетевого соединения или файла может привести к возникновению ошибки и компилятор требует от программиста предусмотреть некие действия для обработки возможных проблем. Таким образом повышается надежность программы, ее устойчивость при возможных сбоях. Исключения, порожденные от RuntimeException, являются непроверяемыми и компилятор не требует обязательной их обработки. Как правило, это ошибки программы, которые при правильном кодировании возникать не должны (например, IndexOutOfBoundsException- выход за границы массива, java.lang.ArithmeticException- деление на ноль). Поэтому, чтобы не загромождать программу, компилятор оставляет на усмотрение программиста обработку таких исключений с помощью блоков try-catch. Исключения, порожденные от Error, также не являются проверяемыми. Они предназначены для того, чтобы уведомить приложение о возникновении фатальной ситуации, которую программным способом устранить практически невозможно (хотя формально обработчик допускается). Они могут свидетельствовать об ошибках программы, но, как правило, это неустранимые проблемы на уровне JVM. В качестве примера можно привести StackOverflowError (переполнение стека), OutOfMemoryError (нехватка памяти). Методы, код которых может порождать проверяемые исключения, должны либо сами их обрабатывать, либо в заголовке метода должно быть указано ключевое слово throws с перечислением необрабатываемых проверяемых исключений. На непроверяемые ошибки это правило не распространяется. Переопределенный (overridden) метод не может расширять список возможных исключений исходного метода.  ;;;;;;;;;;;;;;;;;;;;;;
Java core.;Что такое checked и unchecked Exception?; Checked исключения, это те, которые должны обрабатываться блоком catch или описываться в сигнатуре метода. Unchecked могут не обрабатываться и не быть описанными.  Unchecked исключения в Java - наследованные от RuntimeException, Checked - от Exception.  Пример unchecked исключения - NullPointerException, checked исключения - IOException.;;;;;;;;;;;;;;;;;;;;;;
Java core.;Как создать свой unchecked Exception?; Унаследоваться от RuntimeException.;;;;;;;;;;;;;;;;;;;;;;
Java core.;Какие есть Unchecke exeption?;;;;;;;;;;;;;;;;;;;;;;;
Java core.;Что такое Error?; Исключения, порожденные от Error, не являются проверяемыми. Они предназначены для того, чтобы уведомить приложение о возникновении фатальной ситуации, которую программным способом устранить практически невозможно (хотя формально обработчик допускается). Они могут свидетельствовать об ошибках программы, но, как правило, это неустранимые проблемы на уровне JVM. В качестве примера можно привести StackOverflowError (переполнение стека), OutOfMemoryError (нехватка памяти). Методы, код которых может порождать проверяемые исключения, должны либо сами их обрабатывать, либо в заголовке метода должно быть указано ключевое слово throws с перечислением необрабатываемых проверяемых исключений. На непроверяемые ошибки это правило не распространяется.;;;;;;;;;;;;;;;;;;;;;;
Java core.;Опишите работу блока try-catch-finally.; Если срабатывает один из блоков catch, то остальные блоки в данной конструкции try-catch выполняться не будут. Cвойством транзакционности исключения не обладают - действия, произведенные в блоке try до возникновения исключения, не отменяются поcле его возникновения.;;;;;;;;;;;;;;;;;;;;;;
Java core.;Возможно ли использование блока try-finally (без catch)?;try может быть в паре с finally, без catch. Работает это точно так же - после выхода из блока try выполняется блок finally. Это может быть полезно, например, в следующей ситуации. При выходе из метода вам надо произвести какое-либо действие. А return в этом методе стоит в нескольких местах. Писать одинаковый код перед каждым return нецелесообразно. Гораздо проще и эффективнее поместить основной код в try, а код, выполняемый при выходе - в finally.;;;;;;;;;;;;;;;;;;;;;;
Java core.;Всегда ли исполняется блок finally?; Не всегда например в следующих ситуациях:      Существуют потоки-демоны - потоки предоставляющие некие сервисы, работая в фоновом режиме во время выполнения программы, но при этом не являются ее неотъемлеммой частью.Таким образом когда все потоки не демоны завершаются, программа завершает свою работу. В потоках демонах блок finally не выполняеться, они прерываются внезапно.     System.exit(0)     если в блоке finally произошло исключение и нет обработчика, то оставшийся код в блоке finally может не выполнятся. ;;;;;;;;;;;;;;;;;;;;;;
Java core.;Какие есть оссобенности класса String? что делает метод intern().;"      Внутреннее состояние класса String нельзя изменить после его создания, т.е. этот класс неизменяемый (immutable) поэтому когда вы пишете String str = ""One"" + ""Two""  создается три! объекта класса String.      От него нельзя унаследоваться, потому что класс String объявлен как final: public final class String     Метод hashCode класса String переписан и возвращает: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]      У класса String есть метод public String intern(), который возвращает строку в каноническом ее представлении из внутреннего пула строк, поддерживаемого JVM, он нужен чтобы вместо String.equals() использовать ==.  Понятно, что оператор сравнения ссылок выполняется гораздо быстрее, чем посимвольное сравнение строк. Используют в основном, где приходится сравнивать много строк, например в каких нибудь XML парсерах. А вообще по увеличению производительности ещё вопрос. Ибо метод intern() тогда должен выполняться быстрее чем equals(), каждый раз когда вы вызываете метод intern() просматривается пул строк на наличие такой строки и если такая уже есть в пуле, то возвращается ссылка на нее.Сравниваются они через equal().";;;;;;;;;;;;;;;;;;;;;;
Java core.;Можно ли наследовать строковый тип, почему?; Классы объявлены final, поэтому наследоваться не получится.;;;;;;;;;;;;;;;;;;;;;;
Java core.;Почему строка является популярным ключом в HashMap в Java?; Поскольку строки неизменны, их хэшкод кэшируется в момент создания, и не требует повторного пересчета. Это делает строки отличным кандидатом для ключа в Map и они обрабатываются быстрее, чем другие объекты-ключи HashMap. Вот почему строки преимущественно используются в качестве ключей HashMap.;;;;;;;;;;;;;;;;;;;;;;
Java core.;Дайте определение понятию конкатенация строк.; Конкатенация - операция объединения строк. Результатом является объединения второй строки с окончанием первой. Операция конкатенации могут быть выполнены так:;;;;;;;;;;;;;;;;;;;;;;
Java core.;Как перевернуть строку?;StringBuilder(stroka).reverse;;;;;;;;;;;;;;;;;;;;;;
Java core.;Как сравнить значение двух строк?;Строка в Java - это отдельный объект, который может не совпадать с другим объектом, хотя на экране результат выводимой строки может выглядеть одинаково. Оператор == (а также !=) работает с ссылками объекта String. Если две переменные String указывают на один и тот же объект в памяти, сравнение вернет результат true. В противном случае результат будет false, несмотря на то что текст может содержать в точности такие же символы. Для сравнения посимвольно на эквивалентность необходимо использовать метод equals().;;;;;;;;;;;;;;;;;;;;;;
Java core.;Как обрезать пробелы в начале и конце строки?;trim;;;;;;;;;;;;;;;;;;;;;;
Java core.;"Дайте определение понятию ""пул строк"".";Пул строк - это набор строк, который хранится в памяти Java heap. Мы знаем, что String это специальный класс в Java, и мы можем создавать объекты этого класса, используя оператор new точно так же, как и создавать объекты, предоставляя значение строки в двойных кавычках. Диаграмма ниже объясняет, как пул строк размещается в памяти Java heap и что происходит, когда мы используем различные способы создания строк. Пул строк возможен исключительно благодаря неизменяемости строк в Java и реализации идеи интернирования строк. Пул строк помогает экономить большой объем памяти, но с другой стороны создание строки занимает больше времени. Когда мы используем двойные кавычки для создания строки, сначала ищется строка в пуле с таким же значением, если находится, то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка. Тем не менее, когда мы используем оператор new, мы принуждаем класс String создать новый объект строки, а затем мы можем использовать метод intern() для того, чтобы поместить строку в пул, или получить из пула ссылку на другой объект String с таким же значением.;;;;;;;;;;;;;;;;;;;;;;
Java core.;Можно ли синхронизировать доступ к строке?; String сам по себе потокобезопасный класс. Если мы мы работаем с изменяемыми строками, то нужно использовать StringBuffer.;;;;;;;;;;;;;;;;;;;;;;
Java core.;Как правильно сравнить значения строк двух различных объектов типа String и StringBuffer?;Привести их к одному типу и сравнить.;;;;;;;;;;;;;;;;;;;;;;
Java core.;Почему строка неизменная и финализированная в Java?;Есть несколько преимуществ в неизменности строк:      Строковый пул возможен только потому, что строка неизменна в Java, таким образом виртуальная машина сохраняет много места в памяти(heap space), поскольку разные строковые переменные указывают на одну переменную в пуле. Если бы строка не была неизмененяемой, тогда бы интернирование строк не было бы возможным, потому что если какая-либо переменная изменит значение, это отразится также и на остальных переменных, ссылающихся на эту строку.     Если строка будет изменяемой, тогда это станет серьезной угрозой безопасности приложения. Например, имя пользователя базы данных и пароль передаются строкой для получения соединения с базой данных и в программировании сокетов реквизиты хоста и порта передаются строкой. Так как строка неизменяемая, её значение не может быть изменено, в противном случае любой хакер может изменить значение ссылки и вызвать проблемы в безопасности приложения.     Строки используются в Java classloader и неизменность обеспечивает правильность загрузки класса при помощи Classloader. К примеру, задумайтесь об экземпляре класса, когда вы пытаетесь загрузить java.sql.Connection класс, но значение ссылки изменено на myhacked.Connection класс, который может осуществить нежелательные вещи с вашей базой данных.     Поскольку строка неизменная, её hashcode кэшируется в момент создания и нет необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в Map и его обработка будет быстрее, чем других ключей HashMap. Это причина, почему строка наиболее часто используемый объект, используемый в качестве ключа HashMap.   ;;;;;;;;;;;;;;;;;;;;;;
Java core.;Напишите метод удаления данного символа из строки.;Мы можем использовать метод replaceAll для замены всех вхождений в строку другой строкой. Обратите внимание на то, что метод получает в качестве аргумента строку, поэтому мы используем класс Character для создания строки из символа, и используем её для замены всех символов на пустую строку.;;;;;;;;;;;;;;;;;;;;;;
Java core.;Что такое рефлексия?;Рефлексия используется для получения или модификации информации о типах во время выполнения программы. Этот механизм позволяет получить сведения о классах, интерфейсах, полях, методах, конструкторах во время исполнения программы. При этом не нужно знать имена классов, методов или интерфейсов. Также этот механизм позволяет создавать новые объекты, выполнять методы и получать и устанавливать значения полей;;;;;;;;;;;;;;;;;;;;;;
Java core.;Что произойдет со сборщиком мусора (GC), если во время выполнения метода finalize() некоторого объекта произойдет исключение?; Во время старта JVM запускается поток finalizer, который работает в фоне. Этот поток имеет метод runFinalizer, который игнорирует все исключения методов finalize объектов перед сборкой мусора. То есть если во время выполнения метода finalize возникнет исключительная ситуация, его выполнение будет остановлено и это никак не скажется на работоспособности самого сборщика мусора (garbage collector).  ;;;;;;;;;;;;;;;;;;;;;;
Java core.;Что такое интернационализация, локализация?; Интернационализация (internationalization, а для краткости - i18n) - такой способ создания приложений, при котором их можно легко адаптировать для разных аудиторий, говорящих на разных языках. Локализацияlocalization а для краткости - l10n) -  адаптация интерфейса приложения под несколько языков. Добавление нового языка может внести определенные сложности в локализацию интерфейса.  ;;;;;;;;;;;;;;;;;;;;;;
Java core.;Что такое Аннотации в Java?;" Аннотации - это своего рода метатеги, которые добавляются к коду и применяются к объявлению пакетов, классов, конструкторов, методов, полей, параметров и локальных переменных. Аннотации всегда обладают некоторой информацией и связывают эти ""дополнительные данные"" и все перечисленные конструкции языка. Фактически аннотации представляют собой их дополнительные модификаторы, применение которых не влечет за собой изменений ранее созданного кода. ";;;;;;;;;;;;;;;;;;;;;;
Java core.;Какие функции выполняет Аннотации?; Аннотация выполняет следующие функции:    дает необходимую информацию для компилятора     дает информацию различным инструментам для генерации другого кода, конфигураций и т. д.     может использоваться во время работы кода Самая часто встречаемая аннотация, которую встречал любой программист, даже начинающий это @Override.;;;;;;;;;;;;;;;;;;;;;;
Java core.;Какие встроенные аннотации в Java вы знаете?; В языке Java SE определено несколько встроенных аннотаций, большинство из их являются специализированными. Четыре типа @Retention, @Documented, @Target и @Inherited - из пакета java.lang.annotation. Из оставшиеся выделяются - @Override, @Deprecated, @SafeVarargs и @SuppressWarnings - из пакета java.lang. Широкое использование аннотаций в различных технологиях и фреймворках обуславливается возможностью сокращения кода и снижения его связанности. ;;;;;;;;;;;;;;;;;;;;;;
Java core.;Что делают аннотации @Retention, @Documented, @Target и @Inherited?; Эти аннотации, имеют следующее значение:      @Retention - эта аннотация предназначена для применения только в качестве аннотации к другим аннотациям, позволяет указать жизненный цикл аннотации: будет она присутствовать только в исходном коде, в скомпилированном файле, или она будет также видна и в процессе выполнения. Выбор нужного типа зависит от того, как вы хотите использовать аннотацию.      @Documented - это маркер-интерфейс, который сообщает инструменту, что аннотация должна быть документирована.     @Target - эта аннотация задает тип объявления, к которым может быть применима аннотация. Принимает один аргумент, который должен быть константой из перечисления ElementType, это может быть поле, метод, тип и т.д. Например, чтобы указать, что аннотация применима только к полям и локальным переменным: @Targer({ ElementType.FIELD, ElementTyle.LOCAL_VARIABLE } )     @Inherited - это аннотация-маркер, которая может применяться в другом объявление аннотации, она касается только тех аннотаций, что будут использованы в объявлениях классов. Эта аннотация позволяет аннотации супер класса быть унаследованной в подклассе.  ;;;;;;;;;;;;;;;;;;;;;;
Java core.;Что делают аннотации @Override, @Deprecated, @SafeVarargs и @SuppressWarnings?;       Эти аннотации предназначены для:      @Override - аннотация-маркер, которая может применяться только к методам. Метод, аннотированный как @Override, должен переопределять метод супер класса.     @Deprecated - указывает, что объявление устарело и должно быть заменено более новой формой.     @SafeVarargs - аннотация-маркер, применяется к методам и конструкторам. Она указывает, что никакие небезопасные действия, связанные с параметром переменного количества аргументов, недопустимы. Применяется только к методам и конструкторам с переменным количеством аргументов, которые объявлены как static или final.     @SuppressWarnings - эта аннотация указывает, что одно или более предупреждений, которые могут быть выданы компилятором следует подавить.  ;;;;;;;;;;;;;;;;;;;;;;
Java core.;Какой жизненный цикл аннотации можно указать с помощью @Retention?; Существует 3 возможные варианты чтобы указать где аннотация будет жить. Они инкапсулированы в перечисление java.lang.annotation.RetentionPolicy. Это SOURSE, CLASS, RUNTIME.      SOURCE - содержаться только в исходном файле и отбрасываются при компиляции.     CLASS - сохраняются в файле, однако они недоступны JVM во время выполнения.     RUNTIME - сохраняются в файле во время компиляции и остаются доступными JVM во время выполнения. ;;;;;;;;;;;;;;;;;;;;;;
Java core.;К каким элементам можно применять аннотацию, как это указать?; Для того чтобы ограничить использование аннотации её нужно проаннотировать. Для этого существует аннотация @Target.      @Target(ElementType.PACKAGE) - только для пакетов      @Target(ElementType.TYPE) - только для классов      @Target(ElementType.CONSTRUCTOR) - только для конструкторов      @Target(ElementType.METHOD) - только для методов      @Target(ElementType.FIELD) - только для атрибутов(переменных) класса      @Target(ElementType.PARAMATER) - только для параметров метода      @Target(ElementType.LOCAL_VARIABLE) - только для локальных переменных.  В случае если вы хотите, что бы ваша аннотация использовалась больше чем для одного типа параметров, то можно указать @Target следующим образом: тут мы говорим, аннотацию можно использовать только для параметров метода и для локальных переменных. ;;;;;;;;;;;;;;;;;;;;;;
Java core.;Как создать свою Аннотацию?; Написать свою аннотацию не так сложно, как могло бы казаться. В следующем коде приведено объявление аннотации. как вы видите на месте где обычно пишут class или interface у нас написано @interface. Структура практически та же, что и у интерфейсов, только пишется @interface.      @interface - указывает на то, что это аннотация     default - говорит про то, что метод по умолчанию будет возвращать определённое значение.  Аннотация готова теперь ею можно пользоваться, также аннотацию можно сконфигурировать.  ;;;;;;;;;;;;;;;;;;;;;;
Java core.;Атрибуты каких типов допустимы в аннотациях?; Атрибуты могут иметь только следующие типы: примитивы      String     Class или «any parameterized invocation of Class»     enum     annotation     массив элементов любого из вышеперечисленных типов   Последний пункт надо понимать как то, что допустимы только одномерные массивы. ;;;;;;;;;;;;;;;;;;;;;;
Java core.;Что такое JMX?; Управленческие расширения Java (Java Management Extensions, JMX) -  API при помощи которого можно контролировать работу приложений и управлять различными параметрами удаленно в реальном времени. Причем управлять можно фактически чем угодно - лишь бы это было написано на Java. Это может быть микро-устройство типа считывателя отпечатка или система, включающая тысячи машин, каждая из которых предоставляет определенные сервисы. Данные ресурсы представляются MBean-объектами (управляемый Java Bean). JMX вошла в поставку Java начиная с версии 5. ;;;;;;;;;;;;;;;;;;;;;;
Java core.;Какие выгоды предлагает JMX?;" Вот как эти выгоды описывает Sun      Простота реализации. Архитектура JMX основана на понятии ""сервера управляемых объектов"" который выступает как управляющий агент и может быть запущен на многих устройствах/компьютерах, которые поддерживают JAVA.     Масштабируемость. Службы агентов JXM являются независимыми и могут быть встроены наподобие plug-in’ов в агента JMX. Компонентно-основанаая система позволяет создавать масштабируемые решения от крохотных устройств до очень крупных систем.     Возможность расширять концепцию в будущем. JMX позволяет создавать гибкие решения. Например, JMX позволяет создавать удобные решения, которые могут находить различные сервисы.     Концентрация на управлении. JMX предоставляет сервися, разработанные для работы в распределенных средах и его API спроектировано для решений, которые управляют приложениями, сетями, сервисами и т.д.   ";;;;;;;;;;;;;;;;;;;;;;
Java core.;Что еще умеет JMX кроме дистанционного управления?;" JMX делает гораздо больше, чем просто предоставляет рабочую оболочку для дистанционного управления. Она обеспечивает дополнительные услуги (services), способные занять ключевое место в процессе разработки. Приведу лишь краткое описание:      Event notification: Интерфейсы оповещают исполнителей и слушателей о событиях типа изменения атрибута, что позволяет MBean-компонентам общаться с другими MBean-компонентами или удалённым ""командным пунктом"" и докладывать об изменениях своего состояния     Monitor service: Monitor MBeans может посылать уведомления о событиях зарегистрированным слушателям. Слушателем может выступать другой MBean или управляющее приложение. В качестве основных атрибутов, для которых используется данное свойство, являются counter, gauge или string.     Timer service: Timer MBean будет посылать уведомления зарегистрированным слушателям, с учётом определённого числа или временного промежутка.     M-let service: М-let service может создавать и регистрировать экземпляры MBean-серверов. Список MBean-компонентов и имён из классов определяются в m-let-файле с помощью MLET -меток. URL указывает на месторасположения m-let-файла.  ";;;;;;;;;;;;;;;;;;;;;;
Java core.;Что такое MBean?; MBeans - это Java-объекты, которые реализуют определенный интерфейс. Интерфейс включает:      некие величины, которые могут быть доступны      операции, которые могут быть вызваны      извещения, которые могут быть посланы      конструкторы.  ;;;;;;;;;;;;;;;;;;;;;;
Java core.;Какие типы MBeans существуют?; Существует 4 типа MBeans:      Standard MBeans. Самые простые бины. Их управляющий интерфейс определяется набором методов     Dynamic MBeans. Они реализуют специализированный интерфейс, который делают доступным во время исполнения.     Open MBeans. Это Dynamic MBeans, которые используют только основные типы данных для универсального управления.     Model MBeans. Это Dynamic MBeans, которые полностью конфигурируемы и могут показать свое описание во время исполнения (нечто вроде Reflection)  ;;;;;;;;;;;;;;;;;;;;;;
Java core.;Что такое MBean Server?;MBean Server - это реестр объектов, которые используются для управления. Любой объект зарегистрированный на сервере становится доступным для приложений. Надо отметить, что сервер публикует только интерфейсы и не дает прямых ссылок на объекты. Любые ресурсы, которыми вы хотите управлять должны быть зарегистрированы на сервере как MBean. Сервер предоставляет стандартный интерфейс для доступа к MBean. Интересно, что регистрировать MBean может любой другой MBean, сам агент или удаленное приложение через распределенные сервисы. Когда вы регистрируете MBean вы должны дать ему уникальное имя, которое будет использовано для обращения к даному объекту.;;;;;;;;;;;;;;;;;;;;;;
Java core.;Какие механизмы обеспечивают безопасность в технологии Java?; В технологии Java безопасность обеспечивают следующие три механизма:      структурные функциональные возможности языка (например, проверка границ массивов, запрет на преобразования непроверенных типов, отсутствие указателей и т.д.).     средства контроля доступа, определяющие действия, которые разрешается или запрещается выполнять в коде (например, может ли код получать доступ к файлам, передавать данные по сети и т.д.).     механизм цифровой подписи, предоставляющий авторам возможность применять стандартные алгоритмы для аутентификации своих программ, а пользователям - точно определять, кто создал код и изменился ли он с момента его подписания. ;;;;;;;;;;;;;;;;;;;;;;
Java core.;Назовите несколько видов проверок которые выполняет верификатор байт-кода Java?; Ниже приведены некоторые виды проверок, выполняемых верификатором.      инициализация переменных перед их использованием.     согласование типов ссылок при вызове метода.     соблюдение правил доступа к закрытым данным и методам.     доступ к локальным переменным в стеке во время выполнения.     отсутствие переполнения стека.  При невыполнении какой-нибудь из этих проверок класс считается поврежденным и загружаться не будет.;;;;;;;;;;;;;;;;;;;;;;
Java core.;"Что вы знаете о ""диспетчере защиты"" в Java?"; В качестве диспетчера защиты служит класс, определяющий, разрешено ли коду выполнять ту или иную операцию. Ниже перечислены операции, подпадающие под контроль диспетчера защиты. Существует немало других проверок, выполняемых диспетчером защиты в библиотеке Java.      создание нового загрузчика классов.     выход из виртуальной машины.     получение доступа к члену другого класса с помощью рефлексии.     получение доступа к файлу.     установление соединения через сокет.     запуск задания на печать.     получение доступа к системному буферу обмена.     получение доступа к очереди событий в AWT.     обращение к окну верхнего уровня. ;;;;;;;;;;;;;;;;;;;;;;
Java core.;Что такое JAAS?; JAAS (Java Authentication and Authorization Service - служба аутентификации и авторизации Java ) - служба JAAS, по существу, представляет собой встраиваемый прикладной интерфейс API, отделяющий прикладные программы на Java от конкретной технологии, применяемой для реализации средств аутентификации. Помимо прочего, эта служба поддерживает механизмы регистрации в UNIX и NT, механизм аутентификации Kerberos и механизмы аутентификации по сертификатам. После аутентификации за пользователем может быть закреплен определенный набор полномочий. Входит в состав платформы Java начиная с версии Java SE 1.4. ;;;;;;;;;;;;;;;;;;;;;;
Java core.;Что такое Рефакторинг?;Рефакторинг - процесс изменения внутренней структуры программы, не затрагивающий её внешнего поведения и имеющий целью облегчить понимание её работы. В основе рефакторинга лежит последовательность небольших эквивалентных (то есть сохраняющих поведение) преобразований..;;;;;;;;;;;;;;;;;;;;;;
Collections;Что такое Коллекция?; Коллекции - это хранилища или контейнеры, поддерживающие различные способы накопления и упорядочения объектов с целью обеспечения возможностей эффективного доступа к ним. Они представляют собой реализацию абстрактных структур данных, поддерживающих три основные операции: добавление нового элемента в коллекцию       удаление элемента из коллекции      изменение элемента в коллекции.  ;;;;;;;;;;;;;;;;;;;;;;
Collections;Назовите основные интерфейсы коллекций и их имплементации.; Сollection расширяет три интерфейса: List, Set, Queue. List - хранит упорядоченные елементы(могут быть одинаковые)  Имеет такие реализации как LinkedList, ArrayList и Vector.      Vector синхронизирован, и по этому в одном потоке, он работает медленней остальных реализаций.     ArrayList - его преимущество в навигации по коллекции.     LinkedList - Его преимущество в во вставке и удалении элементов в коллекции.   Set - коллекции, которые не содержат повторяющихся элементов. Основные реализации: HashSet, TreeSet, LinkedHashSet      TreeSet - упорядочивает элементы по их значениям      HashSet - упорядочивает элементы по их хэш ключах, хотя на первый взляд может показаться что элементы хранятся в случайном порядке.     LinkedHashSet - хранит элементы в порядке их добавления   Queue - интерфейс для реализации очереди в джава. Основные реализации: LinkedList, PriorityQueue. Очереди работают по принципу FIFO – first in first out.  Map - интерфейс для реализации так называемой карты, где элементы хранятся с их ключами. Основные реализации: HashTable, HashMap, TreeMap, LinkedHashMap      HashTable - синхронизированна, объявлена уставревшей.     HashMap - порядок елементов рассчитывается по хэш ключу      TreeMap - элементы хранятся в отсортированном порядке     LinkedHashMap - элементы хранятся в порядке вставки  Ключи в Мар не могут быть одинаковыми! Синхронизировать не синхронизированные коллекции и карты можно посредством класса Collections.synchronizedMap(MyMap)\ synchronizedList(MyList).  ;;;;;;;;;;;;;;;;;;;;;;
Collections;Чем отличается ArrayList от LinkedList? В каких случаях лучше использовать первый, а в каких второй?; Отличие заключается в способе хранения данных. ArrayList хранит в виде массива, а LinkedList - в виде списка (двунаправленного). В ArrayList быстрее происходит сортировка, т.к. для ее выполнения данные списка копируются в массив (а копировать из массива ArrayList в массив для сортировки быстрее). При большом числе операций добавления и удаления LinkedList должен быть более удачным выбором, т.к. при этих операциях не приходится перемещать части массива. Если при добавлении в ArrayList превышается его объем, размер массива увеличивается, новая емкость рассчитывается по формуле (oldCapacity * 3) / 2 + 1, поэтому лучше указывать размер при создании или, если он не известен, использовать LinkedList (но это может быть существенно при слишком уж больших объемах данных).  ;;;;;;;;;;;;;;;;;;;;;;
Collections;Чем отличается HashMap от Hashtable?; Класс HashMap по функционалу очень похож на Hashtable. Главное отличие в том, что методы класса Hashtable синхронизированы, а HashMap - нет. Кроме этого класс HashMap в отличии от Hashtable разрешает использование null в качестве ключей и значений.  Наличие синхронизации в Hashtable уменьшает производительность кода, использующего данный класс. Поэтому классы JCF (Java Collections Framework, появившийся в Java 2), в том числе и HashMap, несинхронизированы. Если синхронизация все же нужна, можно использовать методы класса Collections: Collections.synchronizedMap(map), Collections.synchronizedList(list) или Collections.synchronizedSet(set).  Данные методы возвращают синхронизированный декоратор переданной коллекции. При этом все равно в случае итерирования по коллекции требуется ручная синхронизация.  Начиная с Java 6 JCF был расширен специальными коллекциями, поддерживающими многопоточный доступ, такими как CopyOnWriteArrayList и ConcurrentHashMap.  ;;;;;;;;;;;;;;;;;;;;;;
Collections;Чем отличается ArrayList от Vector?; Методы класса Vector синхронизированы, в то время как ArrayList - нет.;;;;;;;;;;;;;;;;;;;;;;
Collections;Как сравниваются елементы коллекций?; Для сравнения элементов коллекций  используется метод equals() и hashcode() Эти методы унаследованы от класса Object.      Если наш пользовательский класс  переопределяет equals(), то он должен и переопределить hashcode()     Если  два объекта эквивалентны, то и  хэш коды этих объектов тоже должны быть равны     Если  поле не используется в equals(), то оно и не должно использоваться в hashcode().  ;;;;;;;;;;;;;;;;;;;;;;
Collections;Расположите в виде иерархии следующие интерфейсы: List, Set, Map, SortedSet, SortedMap, Collection,Iterable, Iterator, NavigableSet, NavigableMap.;;;;;;;;;;;;;;;;;;;;;;;
Collections;Почему Map - это не Collection, в то время как List и Set являются Collection?;"       Коллекция (List и Set) представляет собой совокупность некоторых элементов (обычно экземпляров одного класса).Map -это совокупность пар ""ключ""-""значение"". Соответственно некоторые методы интерфейса Collection нельзя использовать в Map. Например, метод remove(Object o) в интерфейсе Collection предназначен для удаления элемента, тогда как такой же метод remove(Object key) в интерфейсе Map - удаляет элемент по заданному ключу.";;;;;;;;;;;;;;;;;;;;;;
Collections;"Дайте определение понятию ""iterator"".";Итератор - объект, позволяющий перебирать элементы коллекции. Например foreach реализован с использованием итератора. Одним из ключевых методов интерфейса Collection является метод Iterator<E> iterator(). Он возвращает итератор - то есть объект, реализующий интерфейс Iterator. Интерфейс Iterator имеет следующее определение:;;;;;;;;;;;;;;;;;;;;;;
Collections;Что вы знаете об интерфейсе Iterable?;Все коллекции из java.util реализуют интерфейс Collection, который, в свою очередь, расширяет интерфейс Iterable. В интерфейсе Iterable описан только один метод: Iterator iterator()  Он возвращает Iterator, т.е. объект, который поочерёдно возвращает все элементы коллекции. ;;;;;;;;;;;;;;;;;;;;;;
Collections;Как одной строчкой преобразовать HashSet в ArrayList?;List<> = new ArrayList<>(set);;;;;;;;;;;;;;;;;;;;;;
Collections;Как одной строчкой преобразовать ArrayList в HashSet?;Set<>=HashSet<>(list);;;;;;;;;;;;;;;;;;;;;;
Collections;Как перебрать все ключи Map учитывая, что Map - это не Iterable?;Использовать метод keySet(), который возвращает множество (Set<K>) ключей.;;;;;;;;;;;;;;;;;;;;;;
Collections;Как перебрать все значения Map учитывая, что Map - это не Iterable?;Использовать метод values(), который возвращает коллекцию (Collection<V>) значений.;;;;;;;;;;;;;;;;;;;;;;
Collections;Как перебрать все пары ключ-значение в Map учитывая, что Map - это не Iterable?;"Использовать метод entrySet(), который возвращает множество (Set<Map.Entry<K, V>) пар ""ключ""-""значение"".";;;;;;;;;;;;;;;;;;;;;;
Collections;"В чем проявляется ""сортированность"" SortedMap, кроме того, что toString() выводит все по порядку?";Естественное упорядочивание (natural ordering) отражается при итерации по коллекции ключей или значений хэш-таблицы (возвращаемых методами keySet(), values() и entrySet()).;;;;;;;;;;;;;;;;;;;;;;
Collections;Как одним вызовом копировать элементы из любой Collection в массив?;list.toArray();;;;;;;;;;;;;;;;;;;;;;
Collections;Реализуйте симметрическую разность двух коллекций используя методы Collection (addAll(), removeAll(), retainAll()).;Симметрическая разность двух коллекций - это множество элементов, одновременно не принадлежащих обоим исходным коллекциям.;;;;;;;;;;;;;;;;;;;;;;
Collections;Сравните Enumeration и Iterator.; Оба интерфейса предназначены для обхода коллекций. Интерфейс Iterator был введен несколько позднее в Java Collections Framework и его использование предпочтительнее. Основные различия Iterator по сравнению с Enumeration:      наличие метода remove() для удаления элемента из коллекции при обходе      исправлены имена методов для повышения читаемости кода.  ;;;;;;;;;;;;;;;;;;;;;;
Collections;Как между собой связаны Iterable и Iterator?;Интерфейс Iterable имеет только один метод - iterator(), который возвращает итератор коллекции для её обхода.;;;;;;;;;;;;;;;;;;;;;;
Collections;"Как между собой связаны Iterable, Iterator и ""for-each "" введенный в Java 5?";Экземпляры классов, реализующих интерфейс Iterable, могут использоваться в конструкции foreach.;;;;;;;;;;;;;;;;;;;;;;
Collections;Сравните Iterator и ListIterator.; ListIterator расширяет интерфейс Iterator, позволяя клиенту осуществлять обход коллекции в обоих направлениях, изменять коллекцию и получать текущую позицию итератора. При этом важно помнить, что ListIterator не указывает на конкретный элемент, а его текущая позиция располагается между элементами, которые возвращают методы previous() и next(). Таким образом, модификация коллекции осуществляется для последнего элемента, который был возвращен методами previous() и next().  ;;;;;;;;;;;;;;;;;;;;;;
Collections;"Что произойдет, если я вызову Iterator.next() не ""спросив"" Iterator.hasNext()?";Если итератор указывает на последний элемент коллекции, то возникнет исключение NoSuchElementException, иначе будет возвращен следующий элемент.;;;;;;;;;;;;;;;;;;;;;;
Collections;Что произойдет, если я вызову Iterator.next() перед этим 10 раз вызвав Iterator.hasNext()? Я пропущу 9 элементов?;Нет, hasNext() осуществляет только проверку наличия следующего элемента.;;;;;;;;;;;;;;;;;;;;;;
Collections;Если у меня есть коллекция и порожденный итератор, изменится ли коллекция, если я вызову iterator.remove()?; Вызов метода iterator.remove() возможен только после вызова метода iterator.next() хотя бы раз, иначе появится исключение IllegalStateException(). Если iterator.next() был вызван прежде, то iterator.remove() удалит элемент, на который указывает итератор.  ;;;;;;;;;;;;;;;;;;;;;;
Collections;Если у меня есть коллекция и порожденный итератор, изменится ли итератор, если я вызову collection.remove(..)?;Итератор не изменится, но при следующем вызове его методов возникнет исключение ConcurrentModificationException.;;;;;;;;;;;;;;;;;;;;;;
Collections;Зачем добавили ArrayList, если уже был Vector?; Обе структуры данных предназначены для хранения коллекции элементов, в том числе дупликатов и null. Они основаны на использовании массивов, динамически расширяющихся при необходимости. Класс Vector был введен в JDK 1.0 и не является частью Java Collection Framework. Методы класса Vector синхронизированы, что обеспечивает потокобезопасность, но это приводит к снижению производительности, поэтому и был введен класс ArrayList, методы которого не синхронизированы.;;;;;;;;;;;;;;;;;;;;;;
Collections;В реализации класса ArrayList есть следующие поля: Object[] elementData, int size. Объясните, зачем хранить отдельно size, если всегда можно взять elementData.length?;Размер массива elementData представляет собой вместимость (capacity) ArrayList, которая всегда больше переменной size - реального количества хранимых элементов. С добавлением новых элементов вместимость автоматически возрастает при необходимости.;;;;;;;;;;;;;;;;;;;;;;
Collections;LinkedList - это односвязный, двусвязный или четырехсвязный список?; Двухсвязный список: каждый элемент LinkedList хранит ссылку на предыдущий и следующий элементы.;;;;;;;;;;;;;;;;;;;;;;
Collections;Какое худшее время работы метода contain() для элемента, который есть в LinkedList (O(1), O(log(N)), O(N), O(N*log(N)), O(N*N))?;O(N). Время поиска элемента линейно пропорционально количеству элементов с списке.;;;;;;;;;;;;;;;;;;;;;;
Collections;Какое худшее время работы метода contain() для элемента, который есть в ArrayList (O(1), O(log(N)), O(N), O(N*log(N)), O(N*N))?;O(N). Время поиска элемента линейно пропорционально количеству элементов с списке.;;;;;;;;;;;;;;;;;;;;;;
Collections;Какое худшее время работы метода add() для LinkedList (O(1), O(log(N)), O(N), O(N*log(N)), O(N*N))?;       O(N). Здесь стоит заметить, что добавление элемента в конец списка с помощью методом add(value), addLast(value) и добавление в начало списка с помощью addFirst(value) выполняется за время O(1). O(N) - будет при добавление элемента в отсортированный список, а также при добавлении элемента с помощью метода add(index, value).;;;;;;;;;;;;;;;;;;;;;;
Collections;Какое худшее время работы метода add() для ArrayList (O(1), O(log(N)), O(N), O(N*log(N)), O(N*N))?;O(N). Вставка элемента в конец списка осуществляется за время O(1), но если вместимость массива недостаточна, то происходит создание нового массива с увеличенным размером и копирование всех элементов из старого массива в новый.;;;;;;;;;;;;;;;;;;;;;;
Collections;Сколько выделяется элементов в памяти при вызове ArrayList.add()?;Если в массиве достаточно места для размещения нового элемента, то дополнительное место в памяти не выделяется. Иначе происходит создание нового массива с размером: Другими словами, создается новый массив, размер которого вычисляется как умножение старого размера на 1.5 (это верно для JDK 1.7, в более ранних версиях вычисления отличаются).  ;;;;;;;;;;;;;;;;;;;;;;
Collections;Сколько выделяется элементов в памяти при вызове LinkedList.add()?; Создается один новый экземпляр вложенного класса Node.;;;;;;;;;;;;;;;;;;;;;;
Collections;Оцените количество памяти на хранение одного примитива типа byte в LinkedList?; Каждый элемент LinkedList хранит ссылку на предыдущий элемент, следующий элемент и ссылку на данные. Для x32 систем каждая ссылка занимает 32 бита (4 байта). Сам объект типа Node занимает приблизительно 8 байт. Размер каждого объекта в Java кратен 8, соответственно получаем 24 байта. Примитив типа byte занимает 1 байт памяти, но в списке примитивы упаковываются, соответственно получаем еще 8 байт. Таким образом, в x32 JVM около 32 байтоввыделяется для хранения одного значения типа byte в LinkedList. Для 64-битной JVM каждая ссылка занимает 64 бита (8 байт). Вычисления аналогичны.;;;;;;;;;;;;;;;;;;;;;;
Collections;Оцените количество памяти на хранение одного примитива типа byte в ArrayList?; ArrayList основан на массиве. Каждый элемент массива хранит примитивный тип данных - byte, размер которого 1 байт.;;;;;;;;;;;;;;;;;;;;;;
Collections;Я добавляю элемент в середину List-а: list.add(list.size()/2, newElem). Для кого эта операция медленнее - для ArrayList или для LinkedList?; Для ArrayList:      проверка массива на вместимость. Если вместимости недостаточно, то увеличение размера массива и копирование всех элементов в новый массив ( O(N) )      копирование всех элементов, расположенных правее от позиции вставки, на одну позицию вправо ( O(N/2))      вставка элемента ( O(1) ).  Для LinkedList:      поиск позиции вставки ( O(N/2) )      вставка элемента ( O(1) ).  В худшем случае вставка в середину списка эффективнее для LinkedList. В остальных - скорее всего, для ArrayList, поскольку копирование элементов осуществляется за счет системного метода System.arraycopy().  ;;;;;;;;;;;;;;;;;;;;;;
Collections;Как перебрать элементы LinkedList в обратном порядке, не используя медленный get(index)?; Использовать обратный итератор. Для этого в LinkedList есть метод descendingIterator().;;;;;;;;;;;;;;;;;;;;;;
Collections;Как одним вызовом из List получить List со всеми элементами, кроме первых и последних 3-х?;list.sublist(3,oldlist.size()-3);;;;;;;;;;;;;;;;;;;;;;
Collections;Могут ли у разных объектов в памяти (ref0 != ref1) быть ref0.hashCode() == ref1.hashCode()?;Да, могут. Метод hashCode() не гарантирует уникальность возвращаемого значения.;;;;;;;;;;;;;;;;;;;;;;
Collections;Могут ли у разных объектов в памяти (ref0 != ref1) быть ref0.equals(ref1) == true?;Да, могут. Для этого в классе этих объектов должен быть переопределен метод equals(). Если используется метод Object.equals(), то для двух ссылок x и y метод вернет true тогда и только тогда, когда обе ссылки указывают на один и тот же объект (т.е. x == y возвращает true).  ;;;;;;;;;;;;;;;;;;;;;;
Collections;Могут ли у разных ссылок на один объект в памяти (ref0 == ref1) быть ref0.equals(ref1) == false?; Нет, не может. Метод equals() должен гарантировать свойство рефлексивности: для любых ненулевых ссылок xметод x.equals(x) должен возвращать true.;;;;;;;;;;;;;;;;;;;;;;
Collections;Есть класс Point{int x, y }. Почему хэш-код в виде 31 * x + y предпочтительнее чем x + y?; Множитель создает зависимость значения хэш-кода от очередности обработки полей, а это дает гораздо лучшую хэш-функцию.;;;;;;;;;;;;;;;;;;;;;;
Collections;"Если у класса Point{int x, y } ""правильно "" реализовать метод equals (return ref0.x == ref1.x && ref0.y == ref1.y), но сделать хэш-код в виде int hashCode() {return x }, то будут ли корректно такие точки помещаться и извлекаться из HashSet?"; HashSet использует HashMap для хранения элементов (в качестве ключа используется сам объект). При добавлении элемента в HashMap вычисляется хэшкод и позиция в массиве, куда будет вставлен новый элемент. У всех экземпляров класса Point одинаковый хэшкод, что приводит в вырождению хэш-таблицы в список. При возникновении коллизии осуществляется проверка на наличие уже такого элемента в текущем списке: Если элемент найден, то его значение перезаписывается. В нашем случае для разных объектов метод equals() будет возвращать false. Соответственно новый элемент будет добавлен в HashSet. Извлечение элемента также будет осуществляться успешно. Но производительность такого кода будет низкой и преимущества хэш-таблиц использоваться не будут.  ;;;;;;;;;;;;;;;;;;;;;;
Collections;equals() порождает отношение эквивалентности. Какими из свойств обладает такое отношение: коммутативность, симметричность, рефлексивность, дистрибутивность, ассоциативность, транзитивность?; Метод equals() должен обеспечивать:      симметричность (для любых ненулевых ссылок x и y метод x.equals(y) должен возвращать true тогда и только тогда, когда y.equals(x) возвращает true)      рефлексивность (для любых ненулевых ссылок x метод x.equals(x) должен возвращать true.)      транзитивность (для любых ненулевых ссылок x, y и z, если x.equals(y) возвращает true и y.equals(z)возвращает true, тогда и x.equals(z) должен возвращать true).  Также есть ещё два свойства: постоянство и неравенство null.  ;;;;;;;;;;;;;;;;;;;;;;
Collections;Можно ли так реализовать equals(Object that) {return this.hashCode() == that.hashCode()}?;Строго говоря нельзя, поскольку метод hashCode() не гарантирует уникальность значения для каждого объекта. Однако для сравнения экземпляров класса Object такой код допустим, т.к. метод  hashCode() в классе Object возвращает уникальные значения для разных объектов (вычисления основаны на использовании адреса объекта в памяти).;;;;;;;;;;;;;;;;;;;;;;
Collections;В equals требуется проверять, что аргумент (equals(Object that)) такого же типа как и сам объект. В чем разница между this.getClass() == that.getClass() и that instanceof MyClass?; Оператор instanceof сравнивает объект и указанный тип. Его можно использовать для проверки является ли данный объект экземпляром некоторого класса, либо экземпляром его дочернего класса, либо экземпляром класса, который реализует указанный интерфейс. getClass() = ... проверяет два типа на идентичность. Для корректной реализации контракта метода equals() необходимо использовать точное сравнение с помощью getClass().  ;;;;;;;;;;;;;;;;;;;;;;
Collections;Можно ли реализовать метод equals класса MyClass вот так: class MyClass {public boolean equals(MyClass that) {return this == that }}?; Реализовать можно, но данный метод не переопределяет метод equals() класса Object, а перегружает его.;;;;;;;;;;;;;;;;;;;;;;
Collections;Будет ли работать HashMap, если все ключи будут возвращать int hashCode() {return 42 }?; Да, будет. Но тогда хэш-таблица вырождается в связный список и теряет свои преимущества.;;;;;;;;;;;;;;;;;;;;;;
Collections;Зачем добавили HashMap, если уже был Hashtable?; Класс Hashtable был введен в JDK 1.0 и не является частью Java Collection Framework. Методы класса Hashtable синхронизированы, что обеспечивает потокобезопасность, но это приводит к снижению производительности, поэтому и был введен класс HashMap, методы которого не синхронизированы. Помимо этого класс HashMap обладает некоторыми другими отличиями: например, позволяет хранить один null ключ и множество null значений.  ;;;;;;;;;;;;;;;;;;;;;;
Collections;Согласно Кнуту и Кормену существует две основных реализации хэш-таблицы: на основе открытой адресацией и на основе метода цепочек. Как реализована HashMap? Почему так сделали (по вашему мнению)? В чем минусы и плюсы каждого подхода?; Класс HashMap реализован с использованием метода цепочек, т.е. каждой ячейке массива соответствует свой связный список и при возникновении коллизии осуществляется добавление нового элемента в этот список. Для метода цепочек коэффициент заполнения может быть больше 1, с увеличением числа элементов производительность убывает линейно. Такие таблицы удобно использовать, если заранее неизвестно количество хранимых элементов, либо их может быть достаточно много, что приводит к большим значениям коэффициента заполнения. Среди методов открытой реализации различают:      линейное пробирование      квадратичное пробирование      двойное хеширование.  Основные недостатки структур с методом открытой адресации:      Количество элементов в таблице не может превышать размера массива. По мере увеличения числа элементов в таблице и повышения коэффициента заполнения (load factor) производительность структуры резко падает, поэтому необходимо проводить перехеширование.     Сложно организовать удаление элемента.     Также первые два метода открытой адресации приводят к проблеме первичной и вторичной группировок.  Основное преимущество хэш-таблицы с открытой адресацией - это отсутствие затрат на создание и хранение объектов списка. Также проще организовать сериализацию/десериализацию объекта.  ;;;;;;;;;;;;;;;;;;;;;;
Collections;Сколько переходов по ссылкам происходит, когда вы делаете HashMap.get(key) по ключу, который есть в таблице?;" Возможно, я неправильно понял этот вопрос. За переходы по ссылке в данном ответе я считаю вызовы методов. Рассмотрим первый случай, когда ключ равен null: выполняем метод getForNullKey(). В цикле foreach проходимся по списку значений для ключа и возвращаем нужное значение. Таким образом, получаем 1 переход. Второй случай: ключ не равен null. Выполняем метод getEntry(key). Вычисляется хэш-код ключа (метод hash(key)), затем определяется индекс ячейки массива, в которой будем искать значение (метод indexFor(hash, table.length)). После того, как нашли нужную пару ""ключ-значение"" возвращаем значение (метод entry.getValue()). Таким образом, получаем 4 перехода.  ";;;;;;;;;;;;;;;;;;;;;;
Collections;Сколько создается новых объектов, когда вы добавляете новый элемент в HashMap?;Один новый объект статического вложенного класса Entry<K,V>.;;;;;;;;;;;;;;;;;;;;;;
Collections;Как работает HashMap при попытке сохранить в нее два элемента по ключам с одинаковым hashCode, но для которых equals == false?; По значению hashCode вычисляется индекс ячейки массива, в список которой будет происходить добавление элемента. Перед добавлением осуществляется проверка на наличие уже элементов в этой ячейке. Если элементов нет, то происходит добавление. Если возникает коллизия, то итеративно осуществляется обход списка в поисках элемента с таким же ключом и хэш-кодом. Если такой элемент найден, то его значение перезаписывается, а старое - возвращается. Поскольку в условии сказано, что добавляемые ключи - разные, то второй элемент будет добавлен в начало списка.  ;;;;;;;;;;;;;;;;;;;;;;
Collections;HashMap может выродиться в список даже для ключей с разным hashCode. Как это возможно?; Это возможно в случае, если метод, определяющий номер ячейки массива по hashCode будет возвращать одинаковое значение.;;;;;;;;;;;;;;;;;;;;;;
Collections;Какое худшее время работы метода get(key) для ключа, которого нет в таблице (O(1), O(log(N)), O(N), O(N*log(N)), O(N*N))?; O(N). Худший случай - это поиск ключа в таблице, вырожденной в список, перебор ключей которой занимает линейно пропорциональное время количеству хранимых элементов.;;;;;;;;;;;;;;;;;;;;;;
Collections;Какое худшее время работы метода get(key) для ключа, который есть в таблице (O(1), O(log(N)), O(N), O(N*log(N)), O(N*N))?; O(N). Аналогичные рассуждения, что и для предыдущего вопроса.;;;;;;;;;;;;;;;;;;;;;;
Collections;Объясните смысл параметров в конструкторе HashMap(int initialCapacity, float loadFactor).;       int initialCapacity - исходный размер HashMap (количество корзин в хэш-таблице в момент её создания), по умолчанию имеет значение 16.  float loadFactor - коэффициент заполнения HashMap. Равен отношению числа хранимых элементов в таблице к её размеру. loadFactor - является мерой заполнения таблицы элементами, при превышении количества хранимых таблицей значений , происходит автоматическое перехеширование. Значение по умолчанию 0.75 является хорошим компромиссом между временем доступа и объемом хранимых данных. ;;;;;;;;;;;;;;;;;;;;;;
Collections;В чем разница между HashMap и IdentityHashMap? Для чего нужна IdentityHashMap? Как может быть полезна для реализации сериализации или клонирования?; IdentityHashMap - это структура данных, реализующая интерфейс Map, но использующая сравнение ссылок вместо метода equals() при сравнении ключей (значений). Другими словами, в IdentityHashMap два ключа k1 и k2 будут рассматриваться равными, если выполняется условие k1 == k2. IdentityHashMap не использует метод hashCode(), вместо которого применяется метод System.identityHashCode(Object). Другое отличие (как следствие) заключается в более высокой производительности IdentityHashMap по сравнению с HashMap, если последний хранит объекты с дорогостоящими методами equals() и hashCode(). Одним из основных требований к использованию HashMap является неизменяемость ключа, однако это требование не распространяется на IdentityHashMap, который не использует методы equals() и hashCode(). Согласно документации, такая структура данных может применяться для реализации сериализации/клонирования. Для выполнения подобных алгоритмов программе необходимо обслуживать таблицу со всеми ссылками на объекты, которые уже были обработаны. Такая таблица не должна рассматривать уникальные объекты как равные, даже если метод equals() возвращает true.  ;;;;;;;;;;;;;;;;;;;;;;
Collections;В чем разница между HashMap и WeakHashMap? Для чего нужна WeakHashMap?;" Перед рассмотрением WeakHashMap кратко напомню, что такое WeakReference. В Java существует 4 типа ссылок: сильные (strong reference), мягкие (SoftReference), слабые (WeakReference) и фантомные (PhantomReference). Особенности каждого типа ссылок связаны с работой Garbage Collector. Если объект можно достичь только с помощью цепочки WeakReference (то есть на него не ссылаются сильные и мягкие ссылки), то данный объект будет отмечен для удаления. WeakHashMap - это структура данных, реализующая интерфейс Map и основанная на использовании WeakReference для хранения ключей. Таким образом, пара ""ключ-значение"" будет удалена из WeakHashMap, если на объект-ключ более не имеется сильных ссылок. В качестве примера использования такой структуры данных можно привести следующую ситуацию: допустим имеются объекты, которые необходимо расширить дополнительной информацией, при этом изменение класса этих объектов нежелательно либо невозможно. В этом случае добавляем каждый объект в WeakHashMap в качестве ключа, а в качестве значения - нужную информацию. Таким образом, пока на объект имеется сильная ссылка (либо мягкая), можно проверять хэш-таблицу и извлекать информацию. Как только объект будет удален, то WeakReference для этого ключа будет помещен в ReferenceQueue и затем соответствующая запись для этой слабой ссылки будет удалена из WeakHashMap.  ";;;;;;;;;;;;;;;;;;;;;;
Collections;В WeakHashMap используются WeakReferences. А почему бы не создать SoftHashMap на SoftReferences?; SoftHashMap представлена в стронних библиотеках, например, в Apache Commons. ;;;;;;;;;;;;;;;;;;;;;;
Collections;В WeakHashMap используются WeakReferences. А почему бы не создать PhantomHashMap на PhantomReferences?; PhantomReference при вызове метода get() возвращает всегда null, поэтому, я думаю, создание PhantomHashMap просто невозможно. Плюс назначение такой структуры данных тяжело представить. ;;;;;;;;;;;;;;;;;;;;;;
Collections;Сделайте HashSet из HashMap (используйте только множество ключей, но не множество значений).;new HashSet<>(map.keySet);;;;;;;;;;;;;;;;;;;;;;
Collections;Сделайте HashMap из HashSet (HashSet<Map.Entry<K, V>>).;Map<K,V>map=new HashSet<>(set.size)  for (Map.Entry<K,V> entry : set){map.put(entry.getKey,entry.getValue))};;;;;;;;;;;;;;;;;;;;;;
Collections;Сравните интерфейсы java.util.Queue и java.util.Deque.;" Согласно документации Deque (""дек"", Double Ended Queue) - это линейная коллекция, поддерживающая вставку/извлечение элементов с обоих концов. Помимо этого реализации интерфейса Deque могут строится по принципу FIFO, либо LIFO. Queue - это очередь, обычно (но необязательно) строится по принципу FIFO (First-In-First-Out) - соответственно извлечение элемента осуществляется с начала очереди, вставка элемента - в конец очереди. Этот принцип нарушает, к примеру, приоритетная очередь (PriorityQueue), использующая переданный comparator при вставке нового элемента, либо расстановка элементов осуществляется согласно естественному упорядочиванию (natural ordering). Deque расширяет Queue. Реализации и Deque, и Queue обычно не переопределяют методы equals() и hashCode(), основанные на сравнении хранящихся элементов. Вместо этого используются унаследованные методы класса Object, основанные на сравнении ссылок.";;;;;;;;;;;;;;;;;;;;;;
Collections;Кто кого расширяет: Queue расширяет Deque, или Deque расширяет Queue?; Deque расширяет Queue.;;;;;;;;;;;;;;;;;;;;;;
Collections;Почему LinkedList реализует и List, и Deque?; LinkedList позволяет добавлять элементы в начало и конец списка за константное время, что хорошо подходит для реализации интерфейса Deque (в отличие, например, от ArrayList).;;;;;;;;;;;;;;;;;;;;;;
Collections;В чем разница между классами java.util.Arrays и java.lang.reflect.Array?; java.util.Arrays - класс, содержащий статические методы для работы с массивами, таких как, например, поиск по массиву и его сортировка. java.lang.reflect.Array - класс для работы с массивами при использовании рефлексии. Рефлексия - это механизм, позволяющий исследовать данные о программе во время её выполнения.  ;;;;;;;;;;;;;;;;;;;;;;
Collections;В чем разница между классами java.util.Collection и java.util.Collections?;" Класс java.util.Collections содержит исключительно статические методы для работы с коллекциями. В них входят методы, реализующие полиморфные алгоритмы (такие алгоритмы, использование которых возможно с разными видами структур данных), ""оболочки"", возвращающие новую коллекцию с инкапсулированной указанной структурой данных и некоторые другие методы. java.util.Collection - это корневой интерфейс Java Collections Framework. Этот интерфейс в основном применяется там, где требуется высокий уровень абстракции, например, в классе java.util.Collections.  ";;;;;;;;;;;;;;;;;;;;;;
Collections;Напишите НЕмногопоточную программу, которая заставляет коллекцию выбросить ConcurrentModificationException.;;;;;;;;;;;;;;;;;;;;;;;
Collections;"Что такое ""fail-fast поведение""?"; Fail-fast поведение означает, что при возникновении ошибки или состояния, которое может привести к ошибке, система немедленно прекращает дальнейшую работу и уведомляет об этом.  В Java Collections API итераторы могут использовать либо fail-fast, либо fail-safe поведение, либо быть weakly consistent. Итератор с fail-fast поведением выбросит исключение ConcurrentModificationException, если после его создания была произведена модификация коллекции, т.е. добавлен или удален элемент (без использования метода remove() итератора). Реализация такого поведения осуществляется за счет подсчета количества модификаций коллекции (modification count):       при изменении коллекции (удаление/добавление элемента) счетчик увеличивается       при создании итератора ему передается текущее значение счетчика       при каждом обращении к итератору сохраненное значение счетчика сравнивается с текущим, и, если они не совпадают, возникает исключение.   Использование fail-fast подхода позволяет избежать недетерминированного поведения программы в течение времени. Также стоит отметить, что fail-fast поведение не может быть абсолютно гарантировано.  ;;;;;;;;;;;;;;;;;;;;;;
Collections;Для множеств еnum-ов есть специальный класс java.util.EnumSet? Зачем? Чем авторов не устраивал HashSet или TreeSet?; EnumSet - это одна из разновидностей реализации интерфейса Set для использования с перечислениями (Enum). EnumSet использует массив битов для хранения значений (bit vector), что позволяет получить высокую компактность и эффективность. В структуре данных хранятся объекты только одного типа Enum, который указывается при создании экземпляра EnumSet. Все основные операции выполняются за константное время (O(1)) и в основном несколько быстрее (хотя и негарантированно), чем их аналоги в реализации HashSet. Пакетные операции (bulk operations, например, containsAll() и retainAll()) выполняются очень быстро, если их аргументом является экземпляр типаEnum.  Помимо этого класс EnumSet предоставляет множество статических методов инициализации для упрощенного и удобного создания экземпляров.  Итерация по EnumSet осуществляется согласно порядку объявления элементов перечисления.  ;;;;;;;;;;;;;;;;;;;;;;
Collections;"java.util.Stack - считается ""устаревшим"". Чем его рекомендуют заменять? Почему?";" Рекомендуется использовать интерфейс Deque (""дек"", Double Ended Queue) и его реализации. Например:  Стек - это структура данных, построенная на принципе LIFO (Last-In-First-Out, либо по-другому FILO). Каждое новое значение добавляется на ""вершину"" стека, а извлекается последний добавленный элемент (с ""вершины"" стека). При извлечении элемента он удаляется из структуры данных. Класс Stack появился в JDK 1.0 и расширяет класс Vector, наследуя его функционал, что несколько нарушает понятие стека (например, класс Vector предоставляет возможность обращаться к любому элементу по индексу). Также использование Deque позволяет следовать принципу программирования на уровне интерфейсов, а не конкретных реализаций, что облегчает дальнейшую поддержку разрабатываемого класса и повышает его гибкость, позволяя при необходимости менять реализацию дека на нужную. ";;;;;;;;;;;;;;;;;;;;;;
Collections;Какая коллекция реализует дисциплину обслуживания FIFO?; FIFO - First-In-First-Out (первый пришел, первым ушел). По этому принципу обычно построена такая структура данных как очередь (java.util.Queue).;;;;;;;;;;;;;;;;;;;;;;
Collections;Какая коллекция реализует дисциплину обслуживания FILO?; FILO - First-In-Last-Out (первый пришел, последним ушел). По этому принципу построена такая структура данных как стек (java.util.Stack).;;;;;;;;;;;;;;;;;;;;;;
Collections;Приведите пример, когда какая-либо коллекция выбрасывает UnsupportedOperationException.;;;;;;;;;;;;;;;;;;;;;;;
Collections;"Почему нельзя написать ""ArrayList<List> numbers = new ArrayList<ArrayList>() "" но можно ""List<ArrayList> numbers = new ArrayList<ArrayList>() ""?";Это связано с ограничениями использования generic types (обобщенных типов). ArrayList<ArrayList> не является подтипом ArrayList<List>, соответственно использование такой записи запрещено.;;;;;;;;;;;;;;;;;;;;;;
Collections;"LinkedHashMap - что это еще за ""зверь""? Что в нем от LinkedList, а что от HashMap?"; Реализация LinkedHashMap отличается от HashMap поддержкой двухсвязанного списка, определяющего порядок итерации по элементам структуры данных. По умолчанию элементы списка упорядочены согласно их порядку добавления в LinkedHashMap (insertion-order). Однако порядок итерации можно изменить, установив параметр конструктора accessOrder в значение true. В этом случае доступ осуществляется по порядку последнего обращения к элементу (access-order). Это означает, что при вызове методов get() или put() элемент, к которому обращаемся, перемещается в конец списка. При добавлении элемента, который уже присутствует в LinkedHashMap (т.е. с одинаковым ключом), порядок итерации по элементам не изменяется. ;;;;;;;;;;;;;;;;;;;;;;
Collections;"LinkedHashSet - что это еще за ""зверь""? Что в нем от LinkedList, а что от HashSet?"; Реализация LinkedHashSet отличается от HashSet поддержкой двухсвязанного списка, определяющего порядок итерации по элементам структуры данных. Элементы списка упорядочены согласно их порядку добавления в LinkedHashSet (insertion-order). При добавлении элемента, который уже присутствует в LinkedHashSet (т.е. с одинаковым ключом), порядок итерации по элементам не изменяется. ;;;;;;;;;;;;;;;;;;;;;;
Collections;"Говорят, на LinkedHashMap легко сделать простенький кэш c ""invalidation policy"", знаете как?"; Необходимо использовать LRU-алгоритм (Least Recently Used algorithm) и LinkedHashMap с access-order. В этом случае при обращении к элементу он будет перемещаться в конец списка, а наименее используемые элементы будут постепенно группироваться в начале списка. Для этого в стандартной реализации LinkedHashMap (source) есть метод removeEldestEntries(), который возвращает true, если текущий объект LinkedHashMap должен удалить наименее используемый элемент из коллекции. Метод вызывается при использовании методов put() и putAll(): Простой пример реализации кэша с очисткой старых значений при превышении указанного порога: Стоит заметить, что LinkedHashMap не позволяет полностью реализовать LRU-алгоритм, поскольку при вставке уже имеющегося в коллекции элемента порядок итерации не меняется. ;;;;;;;;;;;;;;;;;;;;;;
Collections;Что позволяет сделать PriorityQueue?; PriorityQueue - это структура данных, располагающая элементы в порядке натурального упорядочивания, либо используя переданный конструктору Comparator. Используя PriorityQueue, можно, например, реализовать алгоритм Дейкстры для поиска кратчайшего пути от одной вершины графа к другой. Либо применять для хранения объектов согласно их приоритету: например, сортировка пациентов врача - экстренные пациенты перемещаются в начало очереди, менее срочные пациенты - ближе к концу очереди. ;;;;;;;;;;;;;;;;;;;;;;
Collections;В чем заключаются отличия java.util.Comparator от java.lang.Comparable?; Interface Comparable задает свойство сравнения объекту реализующему его. То есть делает объект сравнимым (по правилам разработчика). Interface Comparator позволяет создавать объекты, которые будут управлять процессом сравнения (например при сортировках). ;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Какие нововведения, появились в Java 8?; В Java 8 было добавлено много функций, наиболее значимые из них упомянуты ниже:      Полноценная поддержка лямбда-выражений, которая добавляет функциональные возможности обработки данных для Java.     Ключевое слово default в интерфейсах для поддержки функциональности по умолчанию(интерфейс может иметь реализацию метода по умолчанию).     Ссылки на методы.     Функциональные интерфейсы (предикаты, поставщики и т. д.)     Потоки (stream) для работы с коллекциями     Новое API для работы с датами     Nashorn движок JavaScript, разрабатываемый полностью на Java компанией Oracle.  ;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Как сортировать список строк с помощью лямбда-выражения?;Collection.sort(names,(s1,s2)->s1.compareTo(s2));;;;;;;;;;;;;;;;;;;;;;
Java 8.;Какова структура лямбда-выражения?;" Лямбда выражение имеет следующую структуру: (method params) -> {lambda expression body} где       method params - список входящих параметров, разделенных запятой(в случаи если параметров больше одного заключаются в скобки).      оператор ""->"" - служит разделителем между списком параметров нашего метода и телом, в котором происходит его реализация.      lambda expression body - тело метода, состоящее из одного выражения или нескольких, заключенных в фигурные скобки.   ";;;;;;;;;;;;;;;;;;;;;;
Java 8.;К каким переменным есть доступ у Лямбда-выражений?; Лямбда-выражения имеют доступ к переменным области видимости, в которой их определили. Но доступ возможен только при условии, что переменные являются effective final, то есть либо явно имеют модификатор final, либо не меняют своего значения после инициализации, если переменной присваивается значение во второй раз, лямбда-выражение вызывает ошибку компиляции.  ;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Что такое ссылки на метод?;" Ссылки на метод - компактные лямбда-выражения которые позволяют передавать ссылки на методы или конструкторы. Для этого нужно использовать ключевое слово ""::"". Ссылочные методы внедряют полезный синтаксис, чтобы ссылаться на существующие методы или конструкторы Java-классов или объектов (экземпляров). Совместно с лямбда-выражениями, ссылочные методы делают языковые конструкции компактными и лаконичными, делая его шаблонным.  ";;;;;;;;;;;;;;;;;;;;;;
Java 8.;Какие виды ссылок на методы вы знаете?; Существует четыре вида ссылок на методы:      Ссылка на статический метод(ContainingClass::staticMethodName)     Ссылка на метод конкретного объекта(ContainingObject::instanceMethodName)     Ссылка на метод произвольного объекта конкретного типа(ContainingType::methodName)     Ссылка на конструктор(ClassName::new), для дженериков (generics) Class< T >::new.   ;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Объясните выражение System.out::println.;Выражение System.out::println является ссылкой на статический метод println об'єкта out класа System, который эквивалентен лямбда-выражению x -> System.out.println(x).;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Что такое функциональные интерфейсы?; Функциональный интерфейс - это тот интерфейс, который определяет строго один абстрактный метод. В Java 8 была введена новая аннотация @FunctionalInterface для обозначения интерфейса, функциональным, эта аннотация используется для того, чтобы избежать случайного добавления абстрактных методов в функциональный интерфейс. Она не обязательна, но является хорошей практикой написания кода. Функциональные интерфейсы позволяют нам использовать лямбда-выражения для создания экземпляра таких интерфейсов. Лучшим примером функционального интерфейса будет интерфейс java.lang.Runnable с одним абстрактным методом run(). Заметим, интерфейс может включать сколько угодно default методов и при этом оставаться функциональным, потому что default методы - не абстрактные.  ;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс BiConsumer<T,U>?; Представляет собой операцию, которая принимает два входных параметра, и не возвращает никакого результата.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс BiFunction<T,U,R>?; Представляет собой функцию, которая принимает два аргумента и возвращает результат.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс BinaryOperator<T>?; Представляет собой операцию над двумя операндами одного и того же типа, выполняет над ними бинарную операцию и возвращает результат того же типа, что и операнды.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс BiPredicate<T,U>?; Представляет собой предикат (булеву функцию) двух аргументов.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс BooleanSupplier?; Представляет собой поставщика булевых результатов.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс Consumer<T>?; Представляет собой операцию, которая принимает один входной аргумент, выполняет некоторое действие над объектом типа T, при этом ничего не возвращая.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс DoubleBinaryOperator?;Представляет собой операцию над двумя операндами типа double, возвращает результат типа double.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс DoubleConsumer?;Представляет собой операцию, которая принимает один аргумент типа double, и не возвращает результат.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс DoubleFunction<R>?;Представляет собой функцию, которая принимает один аргумент типа double, и возвращает результат.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс DoublePredicate?;Представляет собой предикат (булеву функцию) одного аргумента типа double.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс DoubleSupplier?;Представляет собой поставщика double результатов.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс DoubleToIntFunction?;Представляет собой функцию, которая принимает один аргумент типа double, возвращает результат типу int.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс DoubleToLongFunction?;Представляет собой функцию, которая принимает один аргумент типа double, и возвращает результат типу long.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс DoubleUnaryOperator?;Представляет собой операцию над одним аргументом типа double, возвращает результат типу double.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс Function<T,R>?;Представляет собой функцию перехода от объекта типа T к объекту типа R.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс IntBinaryOperator?;Представляет собой операцию над двумя операндами типа int, возвращает результат типа int.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс IntConsumer?;Представляет собой операцию, которая принимает один аргумент типа int, и не возвращает результат.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс IntFunction<R>?;Представляет собой операцию, которая принимает один аргумент типа int, возвращает результат.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс IntPredicate?;Представляет собой предикат (булеву функцию) одного аргумента типа int.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс IntSupplier?;Представляет собой поставщика int результатов.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс IntToDoubleFunction?;Представляет собой функцию, которая принимает один аргумент типа int, возвращает результат типу double.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс IntToLongFunction?;Представляет собой функцию, которая принимает один аргумент типа int, возвращает результат типу long.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс IntUnaryOperator?;Представляет собой операцию над одним аргументом типа int, возвращает результат типу int.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс LongBinaryOperator?;Представляет собой операцию над двумя операндами типа long, возвращает результат типа long.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс LongConsumer?;Представляет собой операцию, которая принимает один аргумент типа long, не возвращает результат.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс LongFunction<R>?;Представляет собой функцию, которая принимает один аргумент типа long, и возвращает результат.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс LongPredicate?;Представляет собой предикат (булеву функцию) одного аргумента типа long.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс LongSupplier?;Представляет собой поставщика long результатов.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс LongToDoubleFunction?;Представляет собой функцию, которая принимает один аргумент типа long, и возвращает результат типу double.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс LongToIntFunction?;Представляет собой функцию, которая принимает один аргумент типа long, и возвращает результат типу int.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс LongUnaryOperator?;Представляет собой операцию над одним аргументом типа long, возвращает результат типу long.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс ObjDoubleConsumer<T>?;Представляет собой операцию, которая принимает один аргумент типа object, и второй типа double, и не возвращает результат.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс ObjIntConsumer<T>?;Представляет собой операцию, которая принимает один аргумент типа object, и второй типа int, и не возвращает результат.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс ObjLongConsumer<T>?;Представляет собой операцию, которая принимает один аргумент типа object, и второй типа long, и не возвращает результат.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс Predicate<T>?;Представляет собой предикат (булеву функцию) одного аргумента.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс Supplier<T>?;Представляет собой поставщика результатов.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс ToDoubleBiFunction<T,U>?;Представляет собой функцию, которая принимает два аргумента, возвращает результат типу double.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс ToDoubleFunction<T>?;Представляет собой функцию, которая принимает один аргумент, возвращает результат типа double.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс ToIntBiFunction<T,U>?;Представляет собой функцию, которая принимает два аргумента, возвращает результат типу int.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс ToIntFunction<T>?;Представляет собой функцию, которая принимает один аргумент, возвращает результат типа int.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс ToLongBiFunction<T,U>?;Представляет собой функцию, которая принимает два аргумента, возвращает результат типу long.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс ToLongFunction<T>?;Представляет собой функцию, которая принимает один аргумент, возвращает результат типа long.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен функциональный интерфейс UnaryOperator<T>?;Представляет собой операцию над одним операндом, возвращает результат того же типа, что и операнд.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Что такое StringJoiner?;"StringJoiner используется, чтобы создать последовательность символов, разделенных разделителем, может (но это не обязательно) начинаться с префикса и заканчиваться суффиксом. Пример: newStringJoiner(""."") StringJoiner.add(""first"").add(''second') // result first.second";;;;;;;;;;;;;;;;;;;;;;
Java 8.;Что такое default методы?; Начиная с Java 8 мы можем использовать в интерфейсах стандартные методы (default methods) и статические методы (static methods).  Default метод - это метод в интерфейсе с по умолчанию реализованной логикой, который не требуется обязательно определять в реализации этого интерфейса.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Что такое static методы?; Static-методы в интерфейсе - это по существу то же самое, что static-методы в абстрактном классе.      Статические методы в интерфейсе являются частью интерфейса, мы не можем использовать его для объектов класса реализации.     Статические методы в интерфейсе хороши для обеспечения вспомогательных методов, например, проверки на null, сортировки коллекций и т.д.     Статические методы в интерфейсе помогают обеспечивать безопасность, не позволяя классам, которые реализуют интерфейс, переопределить их.     Мы не можем определить статические методы для методов класса Object, потому что получим ошибку компиляции.    ;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Как вызывать default-метод интерфейса в классе?;Используя ключевое слово super вместе с именем интерфейса. ;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Как вызывать static-метод интерфейса в классе?;Используя имя интерфейса.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Что такое потоки(stream) в Java 8; java.util.stream - введен для поддержки распараллеливания вычислений в потоках. Предоставляет возможность обрабатывать последовательность элементов исполняя одну или несколько операций, которые могут выполняться либо последовательно либо паралельно. Потоки делятся на последовательные и параллельные. Самая большая польза от этого - в работе с коллекциями. Операции над потоком относятся либо к промежуточным, либо к терминальным. Все промежуточные операции возвращают поток, так что мы можем объединять несколько промежуточных операций без использования точки с запятой. Терминальные операции возвращают void или непотоковый результат.  ;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего нужен метод collect Java 8?; Большинство операций класса Stream, которые модифицируют набор данных, возвращают этот набор в виде потока. Однако бывают ситуации, когда хотелось бы получить данные не в виде потока, а в виде обычной коллекции, например, ArrayList или HashSet. И для этого у класса Stream определен метод collect. Метод принимает в качестве параметра функцию преобразования к коллекции: <R,A> R collect(Collector<? super T,A,R> collector) Параметр R представляет тип результата метода, параметр Т - тип элемента в потоке, а параметр А - тип промежуточных накапливаемых данных. В итоге параметр collector представляет функцию преобразования потока в коллекцию.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;В чем разница между коллекцией(Collection) и потоком(Stream)?;Разница между коллекцией(Collection) данных и потоком(Stream) из новой JDK8 в том что коллекции позволяют работать с элементами по-отдельности, тогда как поток(Stream) не позволяет. Например, с использованием коллекций, вы можете добавлять элементы, удалять, и вставлять в середину. Поток(Stream) не позволяет манипулировать отдельными элементами из набора данных, но вместо этого позволяет выполнять функции над данными как одним целом.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего предназначен метод forEach в потоках(stream)?; Метод void forEach(Consumer<? super T> action) - для каждого элемента выполняется действие action. forEach является терминальной операцией, используется для перебора каждого элемента потока. forEach не гарантирует последовательности вывода элементов в параллельном stream-е, для этого используется метод forEachOrdered - он это гарантирует.  ;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Как вывести на экран 10 случайных чисел, используя forEach?;random.inits().limit(10).forEach(System.out::println);;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего предназначен метод map в потоках(stream)?;Метод <R> Stream<R> map(Function<? super T,? extends R> mapper) - преобразует элементы типа T в элементы типа R и возвращает поток с элементами R. map является промежуточной операцией, метод используется для преобразования элементов в другой объект при помощи переданной функции.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Как можно вывести на экран уникальные квадраты чисел используя метод map?;;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Какова цель метода filter в потоках(stream)?;Метод Stream<T> filter(Predicate<? super T> predicate) - фильтрует элементы в соответствии с условием в предикате. filter является промежуточной операцией, используется для фильтрации массива через функцию. На самом деле filter, не выполняет фильтрацию, вместо этого он создается новый поток, который по завершению формирования, содержит элементы исходного потока, которые соответствуют заданному предикату.  ;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Как вывести на экран количество пустых строк с помощью метода filter?;;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего предназначен метод limit в потоках(stream)?;Метод Stream<T> limit(long maxSize) - оставляет в потоке только maxSize элементов. limit является промежуточной операцией, используется для выборки первых maxSize элементов потока. Этот метод также возвращает модифицированный поток, в котором не более maxSize элементов.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Для чего предназначен метод sorted в потоках(stream)?;Метод Stream<T> sorted()/Stream<T> sorted(Comparator<? super T> comparator) - возвращает отсортированный поток. sorted является промежуточной операцией, метод используется для сортировки потока используя естественный порядок сравнения его элементов. Существует также второй метод sorted(), принимающий либо экземпляр Comparable, либо соответствующее ему лямбда-выражение.  ;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Как вывести на экран 10 случайных чисел в отсортированном порядке в Java 8?;;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Параллельная обработка в Java 8?;Чтобы сделать обычный последовательный поток параллельным, надо вызвать у объекта Stream метод parallel. Кроме того, можно также использовать метод parallelStream() интерфейса Collection для создания параллельного потока из коллекции. В то же время если рабочая машина не является многоядерной, то поток будет выполняться как последовательный.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Как найти максимальное число в списке Java 8?;IntSummaryStatic static =numbers.stream().mapToInt(x->(x)).sumarrystatic static.getMax();;;;;;;;;;;;;;;;;;;;;;
Java 8.;Как найти минимальное число в списке Java 8?;IntSummaryStatic static =numbers.stream().mapToInt(x->(x)).sumarrystatic static.getMin();;;;;;;;;;;;;;;;;;;;;;
Java 8.;Как получить сумму всех чисел в списке, используя Java 8?;IntSummaryStatic static =numbers.stream().mapToInt(x->(x)).sumarrystatic static.getSum();;;;;;;;;;;;;;;;;;;;;;
Java 8.;Как получить среднее значение всех чисел, в списке, используя Java 8?;IntSummaryStatic static =numbers.stream().mapToInt(x->(x)).sumarrystatic static.getAverage();;;;;;;;;;;;;;;;;;;;;;
Java 8.;Что такое Optional?;Optional - это контейнер объекта, он может содержать значение или некоторый тип Т, или просто быть null. Он предоставляет много полезных методов избавляющие от добавления повторяющихся if null/notNull проверок, что позволяет нам сфокусироваться на том, что мы хотим сделать. Метод isPresent() возвращает true если экземпляр Optional содержит не null значение и false в противном случае. Метод orElseGet() содержит запасной механизм результата, если Optional содержит null, принимая функции для генерации значения по умолчанию. Метод map() преобразует текущее значение Optional и возвращает новый экземпляр Optional. Метод orElse() похож на orElseGet(), но вместо функции он принимает значение по умолчанию.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Что такое Nashorn?;Nashorn - это движок JavaScript, разрабатываемый полностью на Java компанией Oracle.  Он призван дать возможность встраивать код JavaScript в приложения Java. В сравнении с Rhino, который поддерживается Mozilla  Foundation, Nashorn обеспечивает от 2 до 10 раз более высокую производительность, так как он непосредственно компилирует код в памяти и передает байт-код виртуальной машине Java. Nashorn умеет компилировать код JavaScript и генерировать классы Java, которые загружаются специальным загрузчиком. Возможен вызов кода Java прямо из JavaScript.  ;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Что такое jjs в Java 8?;Nashorn поставляется с cmd-утилитой jjs, которая позволяет исполнять JavaScript прямо в консоли. jjs принимает список JavaScript файлов исходного кода и запускает их. Чтобы запустить файл давайте передадим его как аргумент в jjs: jjs fileName.js;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Что такое LocalDateTime в Java 8?;"LocalDateTime объединяет вместе LocaleDate и LocalTime и содержит дату и время, но без часового пояса в календарной системе ISO-8601. Время хранится с точностью до наносекунды, так что в LocalTime можно хранить, например, величину ""13:45.30.123456789"". Есть множество удобных методов, таких как plusMinutes, plusHours, isAfter, toSecondOfDay и т.д.  ";;;;;;;;;;;;;;;;;;;;;;
Java 8.;Что такое ZonedDateTime в Java 8?; ZonedDateTime - аналог java.util.Calendar. Это самый мощный класс с полной информацией о временном контексте, включает временную зону. Он содержит дату и время в календарной системе ISO-8601.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Как получить текущую дату с использованием time API из Java 8?;LocalDate.now();;;;;;;;;;;;;;;;;;;;;;
Java 8.;Как добавить 1 неделю к текущей дате с использованием time API?;today = LocalDate.now() today.plus(1,ChronoUnit.WEEKS);;;;;;;;;;;;;;;;;;;;;;
Java 8.;Как добавить 1 месяц к текущей дате с использованием time API?;today = LocalDate.now() today.plus(1,ChronoUnit.MOUTH);;;;;;;;;;;;;;;;;;;;;;
Java 8.;Как добавить 1 год к текущей дате с использованием time API?;today = LocalDate.now() today.plus(1,ChronoUnit.YEARS);;;;;;;;;;;;;;;;;;;;;;
Java 8.;Как добавить 10 лет к текущей дате с использованием time API?;today = LocalDate.now() today.plus(1,ChronoUnit.DECADES);;;;;;;;;;;;;;;;;;;;;;
Java 8.;Как получить следующий вторник используя time API?;today = LocalDate.now() today.with(TemporalAdjustrs.next(DayOfWeek.TUESDAY);;;;;;;;;;;;;;;;;;;;;;
Java 8.;Как получить вторую субботу текущего месяца используя time API?;;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Как получить текущею дату в миллисекундах используя time API?;;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Як получить текущею дату по местному времени в миллисекундах используя используя time API?;;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Какой класс появился в Java 8 для декодирования данных?;В Java 8 для этого появился класс public static class Base64.Decoder - этот класс реализует декодер для декодирования байт данных, используя схему кодирования Base64 как указано в RFC 4648 и RFC 2045, класс безопасен для использования несколькими параллельными потоками.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Какой класс появился в Java 8 для кодирования данных?;В Java 8 для этого появился класс public static class Base64.Encoder - этот класс реализует кодер для кодирования байт данных, используя схему кодирования Base64 как указано в RFC 4648 и RFC 2045, класс безопасен для использования несколькими параллельными потоками.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Как создать Base64 декодировщик?;Используя метод getDecoder() класса Base64 он возвращает декодировщик Base64.Decoder, который декодирует данные с помощью схемы кодирования base64.;;;;;;;;;;;;;;;;;;;;;;
Java 8.;Как создать Base64 кодировщик?;Используя метод getEncoder() класса Base64 он возвращает кодировщик Base64.Encoder, который кодирует данные с помощью схемы кодирования base64.;;;;;;;;;;;;;;;;;;;;;;
Потоки ввода/вывода в java.;Что такоє символьная ссылка?;Символьная ссылка (Symbolic link, симлинк) - специальный файл в файловой системе, содержащий только текстовую строку с указателем. Эта строка трактуется как путь к файлу, который должен быть открыт при попытке обратиться к данному файлу.;;;;;;;;;;;;;;;;;;;;;;
Потоки ввода/вывода в java.;Какая разница между I/О и NIO?; I/O (input/output, ввод-вывод ) - взаимодействие между обработчиком информации и её поставщиком и/или получателем. Ввод - сигнал или данные, полученные обработчиком, а вывод - сигнал или данные, посланные им (или из него). NIO (/*в контексте Java*/ Non-blocking I/O, New I/O) - коллекция прикладных программных интерфейсов для языка Java, предназначенных для реализации высокопроизводительных операций ввода-вывода. Также встречается аббревиатура NIO.2 - она относится к нововведениям относительно этого направления в Java 7.  ;;;;;;;;;;;;;;;;;;;;;;
Потоки ввода/вывода в java.;Какие особенности NIO вы знаете?; Ключевые особенности NIO:      Каналы и селекторы: NIO поддерживает различные типы каналов. Канал является абстракцией объектов более низкого уровня файловой системы (например, отображенные в памяти файлы и блокировки файлов), что позволяет передавать данные с более высокой скоростью. Каналы не блокируются и поэтому Java предоставляет еще такие инструменты, как селектор, который позволяет выбрать готовый канал для передачи данных, и сокет, который является инструментом для блокировки.     Буферы: в Java 7 была введена буферизация для всех классов-обёрток примитивов (кроме Boolean). Появился абстрактный класс Buffer, который предоставляет такие операции, как clear, flip, mark и т.д. Его подклассы предоставляют методы для получения и установки данных.     Кодировки: в Java 7 появились кодировки (java.nio.charset), кодеры и декодеры для отображения байт и символов Unicode.  ;;;;;;;;;;;;;;;;;;;;;;
Потоки ввода/вывода в java.;Какие существуют виды потоков ввода/вывода?;Потоки ввода/вывода используются для передачи данных в файловые потоки, на консоль или на сетевые соединения. Существует два вида потоков ввода/вывода: байтовые и символьные.;;;;;;;;;;;;;;;;;;;;;;
Потоки ввода/вывода в java.;Назовите основные классы потоков ввода/вывода.; Байтовые: java.io.InputStream, java.io.OutputStream  Символьные: java.io.Reader, java.io.Writer ;;;;;;;;;;;;;;;;;;;;;;
Потоки ввода/вывода в java.;Чем отличаются и что общего у OutputStream, InputStream, Writer, Reader?; Класс OutputStream - это абстрактный класс, определяющий потоковый байтовый вывод. В этой категории находятся классы, определяющие, куда направляются ваши данные: в массив байтов (но не напрямую в String  предполагается что вы сможете создать их из массива байтов), в файл или канал. Базовый класс InputStream представляет классы, которые получают данные из различных источников:      массив байтов     строка (String)     файл     канал (pipe): данные помещаются с одного конца и извлекаются с другого     последовательность различных потоков, которые можно объединить в одном потоке     другие источники (например, подключение к интернету)  Символьные потоки имеют два основных абстрактных класса Reader и Writer, управляющие потоками символов Unicode. Класс Reader - абстрактный класс, определяющий символьный потоковый ввод. Класс Writer - абстрактный класс, определяющий символьный потоковый вывод. В случае ошибок все методы класса передают исключение IOException. ;;;;;;;;;;;;;;;;;;;;;;
Потоки ввода/вывода в java.;Какие подклассы базового класса InputStream ви знаєте, для чего они предназначены?;Подклассы базового класса InputStream:      StringBufferInputStream - превращает строку (String) во входной поток данных InputStream.     SequenceInputStream - сливает два или более потока InputStream в единый поток.     PushbackInputStream - входной поток, поддерживающий однобайтовый возврат во входной поток.     PrintStream - выходной поток, включающий методы print() и println().     PipedInputStream - реализует понятие входного канала.     ObjectInputStream - входной поток для объектов.     InputStream - абстрактный класс, описывающий поток ввода.     FilterInputStream - абстрактный класс, предоставляющий интерфейс для классов-надстроек, которые добавляют к существующим потокам полезные свойства.     FileInputStream - для чтения информации из файла.     DataInputStream - входной поток, включающий методы для чтения стандартных типов данных Java.     ByteArrayInputStream - позволяет использовать буфер в памяти (массив байтов) в качестве источника данных для входного потока.     BufferedInputStream - буферизированный входной поток.  ;;;;;;;;;;;;;;;;;;;;;;
Потоки ввода/вывода в java.;Что вы знаете о RandomAccessFile?; RandomAccessFile это класс который наследуется напрямую от Object и не наследуется от вышеприведенных базовых классов ввода\вывода. Предназначен для работы с файлами, поддерживая произвольный доступ к их содержимому. Работа с классом RandomAccessFile напоминает использование совмещенных в одном классе потоков DataInputStream и DataOutputStream (они реализуют те же интерфейсы DataInput и DataOutput). Кроме того, метод seek() позволяет переместиться к определенной позиции и изменить хранящееся там значение. При использовании RandomAccessFile необходимо знать структуру файла. Класс RandomAccessFile содержит методы для чтения и записи примитивов и строк UTF-8. ;;;;;;;;;;;;;;;;;;;;;;
Потоки ввода/вывода в java.;Какие есть режимы доступа к файлу есть у RandomAccessFile ?;"RandomAccessFile может открываться в режиме чтения (""r"") или чтения/записи (""rw""). Также есть режим ""rws"", когда файл открывается для операций чтения-записи и каждое изменение данных файла немедленно записывается на физическое устройство.";;;;;;;;;;;;;;;;;;;;;;
Потоки ввода/вывода в java.;Какие подклассы базового класса OutputStream ви знаєте, для чего они предназначены?; Класс OutputStream - это абстрактный класс, определяющий потоковый байтовый вывод. В этой категории находятся классы, определяющие, куда направляются ваши данные: в массив байтов (но не напрямую в String  предполагается что вы сможете создать их из массива байтов), в файл или канал. Подклассы базового класса OutputStream:      PipedOutputStream - реализует понятие выходного канала.     ObjectOutputStream - выходной поток для объектов     FilterOutputStream - абстрактный класс, предоставляющий интерфейс для классов-надстроек, которые добавляют к существующим потокам полезные свойства.     FileOutputStream - отправка данных в файл на диске. Реализация класса OutputStream.     DataOutputStream - выходной поток, включающий методы для записи стандартных типов данных Java.     ByteArrayOutputStream - создает буфер в памяти. Все данные, посылаемые в этот поток, размещаются в созданном буфере.     BufferedOutputStream - буферизированный выходной поток.  ;;;;;;;;;;;;;;;;;;;;;;
Потоки ввода/вывода в java.;Для чего используется PushbackInputStream?;" Разновидность буферизации, обеспечивающая чтение байта с последующим его возвратом в поток. Класс PushbackInputStream представляет механизм ""заглянуть"" во входной поток и увидеть, что оттуда поступит в следующий раз, не извлекая информации. У класса есть дополнительный метод unread().";;;;;;;;;;;;;;;;;;;;;;
Потоки ввода/вывода в java.;Для чего используется SequenceInputStream?; Класс SequenceInputStream позволяет соединять вместе несколько экземпляров класса InputStream. Конструктор принимает в качестве аргумента либо пару объектов класса InputStream, либо интерфейс Enumeration. Во время работы класс выполняет запросы на чтение из первого объекта класса InputStream и до конца, а затем переключается на второй. При использовании интерфейса работа продолжится по всем объектам класса InputStream. По достижении конца каждого файла, связанный с ним поток закрывается. Закрытие потока, созданного объектом класса SequenceInputStream, приводит к закрытию всех открытых потоков. ;;;;;;;;;;;;;;;;;;;;;;
Потоки ввода/вывода в java.;Какие подклассы базового класса Reader ви знаєте, для чего они предназначены?; Подклассы базового класса Reader:      StringReader - входной поток, читающий из строки.     Reader - абстрактный класс, описывающий символьный ввод.     PushbackReader - входной поток, позволяющий возвращать символы обратно в поток.     PipedReader - входной канал.     LineNumberReader - входной поток, подсчитывающий строки.     InputStreamReader - входной поток, транслирующий байты в символы.     FilterReader - фильтрующий читатель.     FileReader - входной поток, читающий файл.     CharArrayReader - входной поток, который читает из символьного массива.     BufferedReader - буферизированный входной символьный поток. ;;;;;;;;;;;;;;;;;;;;;;
Потоки ввода/вывода в java.;Какие подклассы базового класса Writer ви знаєте, для чего они предназначены?; Подклассы базового класса Writer:      Writer - абстрактный класс, описывающий символьный вывод     StringWriter - выходной поток, пишущий в строку     PrintWriter - выходной поток, включающий методы print() и println()     PipedWriter - выходной канал     OutputStreamWriter - выходной поток, транслирующий байты в символы     FilterWriter - фильтрующий писатель     FileWriter - выходной поток, пишущий в файл     CharArrayWriter - выходной поток, который пишет в символьный массив     BufferedWriter - буферизированный выходной символьный поток   ;;;;;;;;;;;;;;;;;;;;;;
Потоки ввода/вывода в java.;Что такое абсолютный путь и относительный путь?; Абсолютный путь - это путь, который указывает на одно и то же место в файловой системе, вне зависимости от текущей директории. Полный путь всегда начинается с корневого каталога. Относительный путь - это путь по отношению к текущему рабочему каталогу.;;;;;;;;;;;;;;;;;;;;;;
Потоки ввода/вывода в java.;В каких пакетах лежат классы-потоки?;Стандартный классы ввода\вывода в Java лежат в пакете java.io.*. В JDK 7 добавлен более современный способ работы с потоками под названием Java NIO или Java New IO ети классы лежат в пакете java.nio.*. Для работы с архивами используются классы из пакета java.util.*.;;;;;;;;;;;;;;;;;;;;;;
Потоки ввода/вывода в java.;Что вы знаете о классах-надстройках?; Классы-настройки ето классы которые добавляют к существующим потокам полезные дополнительные свойства. Примеры классов: BufferedOutputStream, BufferedInputStrem, BufferedWriter , BufferedReader -  буферезируют поток и повышают производительность. ;;;;;;;;;;;;;;;;;;;;;;
Потоки ввода/вывода в java.;Какой класс-надстройка позволяет читать данные из входного байтового потока в формате примитивных типов данных?; Для чтения байтовых данных (не строк) применяется класс DataInputStream. В этом случае необходимо использовать классы из группы InputStream. Для преобразования строки в массив байтов, пригодный для помещения в поток ByteArrayInputStream, в классе String предусмотрен метод getBytes(). Полученный ByteArrayInputStream представляет собой поток InputStream, подходящий для передачи DataInputStream. При побайтовом чтении символов из форматированного потока DataInputStream методом readByte() любое полученное значение будет считаться действительным, поэтому возвращаемое значение неприменимо для идентификации конца потока. Вместо этого можно использовать метод available(), который сообщает, сколько еще осталось символов. Класс DataInputStream позволяет читать элементарные данные из потока через интерфейс DataInput, который определяет методы, преобразующие элементарные значения в форму последовательности байтов. Такие потоки облегчают сохранение в файле двоичных данных.;;;;;;;;;;;;;;;;;;;;;;
Потоки ввода/вывода в java.;Какой класс-надстройка позволяет ускорить чтение/запись за счет использования буфера?; Для этого используются классы, позволяющие буферизировать поток:      java.io.BufferedInputStream - буферизированный входной поток. Конструкторы: BufferedInputStream(InputStream in), BufferedInputStream(InputStream in, int size).     java.io.BufferedOutputStream - буферизированный выходной поток. Конструкторы: BufferedOutputStream(OutputStream out), BufferedOutputStream(OutputStream out, int size).     java.io.BufferedReader - буферизированный входной символьный поток. Конструкторы: BufferedReader(Reader r), BufferedReader(Reader in, int sz).     java.io.BufferedWriter - буферизированный выходной символьный поток. Конструкторы: BufferedWriter(Writer out), BufferedWriter(Writer out, int sz).  ;;;;;;;;;;;;;;;;;;;;;;
Потоки ввода/вывода в java.;Какие классы позволяют преобразовать байтовые потоки в символьные и обратно?; OutputStreamWriter - это мост между классом OutputStream и классом Writer. Символы, записанные в поток, преобразовываются в байты. InputStreamReader - аналог для чтения. При помощи методов класса Reader читаются байты из потока InputStream и далее преобразуются в символы. ;;;;;;;;;;;;;;;;;;;;;;
Потоки ввода/вывода в java.;В чем отличие класса PrintWriter от PrintStream?;Прежде всего, в классе PrintWriter применен усовершенствованный способ работы с символами UNICODE и другой механизм буферизации вывода. В классе PrintStream буфер вывода сбрасывался всякий раз, когда вызывался метод print или println. При использовании класса PrintWriter вы можете отказаться от автоматического сброса буферов, выполняя его явным образом при помощи метода flush. В классе PrintWriter предусмотрено два конструктора, позволяющих работать с выходными потоками класса OutputStream:      public PrintWriter(OutputStream out)  - создает поток без автоматического сброса буферов.     public PrintWriter(OutputStream out, boolean autoFlush)  - способ сброса буферов при использовании второго конструктора зависит от значения параметра autoFlush. Если он равен true, автоматический сброс буферов выполняется, а если false - нет.  Набор реализаций основных методов print и println класса PrintWriter аналогичен набору реализация этих методов класса PrintStream. Здесь же мы упомянем только методы flush и checkError. Метод flush вызывает принудительный сброс буфера вывода. Если поток PrintWriter создан на базе стандартного потока вывода System.out, то записанные в него данные появятся на консоли только после выполнения сброса буфера (автоматического или сделанного методом flush). Что же касается метода checkError, то в случае возникновения ошибок он возвращает значение true. ;;;;;;;;;;;;;;;;;;;;;;
Потоки ввода/вывода в java.;Какой класс предназначен для работы с элементами файловой системы?; В отличие от большинства классов ввода/вывода, класс File работает не с потоками, а непосредственно с файлами. Данный класс позволяет получить информацию о файле: права доступа, время и дата создания, путь к каталогу. А также осуществлять навигацию по иерархиям подкаталогов. Класс java.io.File может представлять имя определённого файла, а также имена группы файлов, находящихся в каталоге. Если класс представляет каталог, то его метод list() возвращает массив строк с именами всех файлов. Для создания объектов класса File можно использовать один из следующих конструкторов.      File(File dir, String name) - указывается объекта класса File (каталог) и имя файла     File(String path) - указывается путь к файлу без указания имени файла     File(String dirPath, Sring name) - указывается путь к файлу и имя файла     File(URI url) - указывается объекта URI, описывающий файл ;;;;;;;;;;;;;;;;;;;;;;
Потоки ввода/вывода в java.;Какой символ является разделителем при указании пути в файловой системе?;" Для различных систем символ разделителя различается. Вытащить его можно используя file.separator, а так же в статическом поле File.separator.  Для Windows это ""\"".";;;;;;;;;;;;;;;;;;;;;;
Потоки ввода/вывода в java.;Какие методы класса File ви знаєте?; У класса File очень много методов, перечислим некоторые.      getAbsolutePath() - абсолютный путь файла, начиная с корня системы. В Android корневым элементом является символ слеша (/)     canRead() - доступно для чтения     canWrite() - доступно для записи     exists() - файл существует или нет     getName() - возвращает имя файла     getParent() - возвращает имя родительского каталога     getPath() - путь     lastModified() - дата последнего изменения     isFile() - объект является файлом, а не каталогом     isDirectory - объект является каталогом     isAbsolute() - возвращает true, если файл имеет абсолютный путь     renameTo(File newPath) - переименовывает файл. В параметре указывается имя нового имени файла. Если переименование прошло неудачно, то возвращается false     delete() - удаляет файл. Также можно удалить пустой каталог  ;;;;;;;;;;;;;;;;;;;;;;
Потоки ввода/вывода в java.;Что вы знаете об интерфейсе FileFilter?;Интерфейс FileFilter применяется для проверки, попадает ли объект ли объект File под некоторое условие. Этот интерфейс содержит единственный метод boolean accept(File pathName). Этот метод необходимо переопределить и реализовать.;;;;;;;;;;;;;;;;;;;;;;
Потоки ввода/вывода в java.;Какие классы позволяют архивировать объекты?; DeflaterOutputStream, InflaterInputStream, ZipInputStream, ZipOutputStream,  GZIPInputStream, GZIPOutputStream.;;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Чем отличается процесс от потока?;Процесс это некоторая единица операционной системы, которой выделена память и другие ресурсы. Поток это единица исполнения кода. Поток имеет стэк - некоторую свою память для исполнения. Остальная память процесса - общая для всех его потоков. Потоки исполняются на ядрах процессора.  В некоторых OS разница между процессами и потоками сведена к минимуму.;;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Каким образом можно создать поток?;Есть несколько способов создания и запуска потоков:      С помощью класса, реализующего Runnable:         Создать объект класса Thread.         Создать объект класса, реализующего интерфейс Runnable.         Вызвать у созданного объекта Thread метод start() (после этого запустится метод run() у переданного объекта, реализующего Runnable).     С помощью класса, расширяющего Thread:         Создать объект класса ClassName extends Thread.         Переопределить run() в этом классе (смотрите примере ниже, где передается имя потока 'Second').     С помощью класса, реализующего java.util.concurrent.Callable:         Создать объект класса, реализующего интерфейс Callable.         Создать объект ExecutorService с указанием пула потоков.         Создать объект Future. Запуск происходит через метод submit()  Сигнатура: <T> Future<T> submit(Callable<T> task).   ;;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Что такое монитор?;Контроль за доступом к объекту-ресурсу обеспечивает понятие монитора. Монитор экземпляра может иметь только одного владельца. При попытке конкурирующего доступа к объекту, чей монитор имеет владельца, желающий заблокировать объект-ресурс поток должен подождать освобождения монитора этого объекта и только после этого завладеть им и начать использование объекта-ресурса.  ;;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Какие способы синхронизации в Java?;"Ниже приведены некоторые способы синхронизации в Java:      Системная синхронизация с использованием wait/notify. Поток, который ждет выполнения каких-либо условий, вызывает у этого объекта метод wait, предварительно захватив его монитор. На этом его работа приостанавливается. Другой поток может вызвать на этом же самом объекте метод notify (опять же, предварительно захватив монитор объекта), в результате чего, ждущий на объекте поток ""просыпается"" и продолжает свое выполнение.      Системная синхронизация с использованием join. Метод join, вызванный у экземпляра класса Thread, позволяет текущему потоку остановиться до того момента, как поток, связаный с этим экземпляром, закончит работу.      Использование классов из пакета java.util.concurrent, который предоставляет набор классов для организации межпоточного взаимодействия. Примеры таких классов - Lock, семафор (Semaphore), etc. Концепция данного подхода заключается в использовании атомарных операций и переменных. ";;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Как работают методы wait и notify/notifyAll?;"Эти метеоды предназначены для межпоточной синхронизации, для взаимодействия потоков между собой. Как работают эти методы. Во-первых они могут вызваны только потоком, который захватил монитор объекта, для которого эти методы вызываются. То есть они вызываются внутри блока synchronized и для объекта, монитор которого этим synchronized захвачен. Если внутри synchronized метода - то для класса, к которому относятся эти методы. Что делает метод wait(). Метод wait() отдает (освобождает) монитор объекта, так что другие потоки теперь могут его (монитор) захватить, то есть войти в блок synchronized для этого объекта. Затем метод wait() переходит в состояние ожидания, до тех пор пока другой поток не вызывет метод notify() или notifyAll() для этого же объекта. После чего поток, в котором был вызван wait(), пытается снова захватить монитор объекта и когда монитор становится свободным, то есть когда другой поток освобождает его, захватывает монитор и продолжает выполнение со следующего после wait() оператора. Причем у потока вызвашего wait() нет никакого преимущества перед другими потоками, ожидающими захвата того же монитора. Что делают методы notify(), notifyAll(). Они ""пробуждают"" поток, ожидающий методом wait() (если такой есть), и переводят его в состояние ожидания освобождения монитора. Разница между notify() и notifyAll() в том, что notify() пробуждает только один поток , ожидающий методом wait(), какой именно будет пробужден - определить нельзя, а notifyAll() - все такие потоки.  ";;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Чем отличается работа метода wait с параметром и без параметра?;Разница методов в следующем:      final void wait()  - метод используется в многопоточной среде, может вызываться только потоком, владеющим объектом синхронизации. При этом объект синхронизации освобождается, а текущий поток переходит в режим ожидания сигнала освобождения объекта синхронизации другим потоком путем вызова метода notify() либо notifyAll().     final void wait(long time)  - аналогично wait() данный метод используется в многопоточной среде, переходит текущий поток в режим ожидания сигнала освобождения объекта синхронизации другим потоком путем вызова метода notify() либо notifyAll(), или ожидание происходит заданное время time, затем выполнение продолжается безусловно.   ;;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Как работает метод Thread.yield()? Чем отличаются методы Thread.sleep() и Thread.yield()?;"Основные отличия:      метод yield() - пытается сказать планировщику потоков, что нужно выполнить другой поток, что ожидает в очереди на выполнение. Метод не пытается перевести текущий поток в состояние блокировки, сна или ожидания. Он просто пытается его перевести из состояние ""работающий"" в состояние ""работоспособный"". Однако выполнение метода может вообще не произвести никакого эффекта. состояние потока остатается RUNNABLE      метод sleep() - приостанавливает поток на указанное. состояние меняется на TIMED_WAITING, по истечению - RUNNABLE     метод wait() - меняет состояние потока на WAITING может быть вызвано только у объекта владеющего блокировкой, в противном случае выкинется исключение IllegalMonitorStateException. при срабатывании метода блокировка отпускается, что позволяет продолжить работу другим потокам ожидающим захватить ту же самую блокировку . в случае wait(int) с аргументом состояние будет TIMED_WAITING.   ";;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Как работает метод Thread.join()?;Метод join() вызывается для того, чтобы привязать текущий поток в конец потока для которого вызывается метод. То есть второй поток будет в режиме блокировки пока первый поток не выполнится.;;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Что такое dead lock?;Это когда один поток А получил блокировку на объект А1, а поток В получил блокировку на объект В1. В то время как поток А пытается получит блокировку на объект В1, а поток В на А1.;;;;;;;;;;;;;;;;;;;;;;
Multithreading.;На каком объекте происходит синхронизация при вызове static synchronized метода?;Представьте себе ситуацию что два потока одновременно изменяют состояние какого-то объекта, это недопустимо. Для этого необходимо синхронизировать потоки. Как это сделать? Ключевое слово synchronized позволяет это сделать установив в сигнатуре метода. Или же в методе можно описать блок synchronized, только в качестве параметра необходимо передать объект, который будет блокироватся. Представьте себе ситуацию когда один поток ждет пока разблокируется объект… а если это ждут несколько потоков? Нет гарантии что тот объект что больше всех ждал снятия блокировки будет выполнятся первым.  Статические синхронизированные методы и нестатические  синхронизированные методы не будет  блокировать друг друга, никогда. Статические  методы блокируются на экземпляре класса Class в то время как нестатические методы блокируются на текущем экземпляре (this). Эти действия не мешают друг другу. wait() - отказывается от блокировки остальные методы сохраняют блокировку.;;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Для чего используется ключевое слово volatile, synchronized, transient, native?;Краткое описание ключевых слов:      volatile - указывает на то, что поле синхронизировано для нескольких потоков     synchronized - указывает на то что метод синхронизированный или же в методе может находится такой блок синхронизации.     transient - указывает на то, что переменная не подлежит сериализации     native - говорит о том, что реализация метода написана на другой программной платформе   ;;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Что значит приоритет потока?;Приоритет потока - это число от 1 до 10, в  зависимости от которого, планировщик потоков выбирает какой поток  запускать. Однако полагаться на приоритеты для предсказуемого выполнения многопоточной  программы нельзя!;;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Что такое потоки –демоны в джава?; Это потоки, которое работают в фоновом  режиме и не гарантируют что они завершатся. Тоеть если все потоки завершились, то поток демон просто обрывается вместе с закрытием приложения.;;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Что значит усыпить поток?;"Перевести поток в спящее состояние можно  с помощью метода sleep(long ms) ms - время в миллисекундах.  При вызове этого метода, поток переходит  в спящее состояние, после сна, поток переходит в пул потоков и  находится в состоянии ""работоспособный"", т.е. не гарантируется что после пробуждения он будет сразу выполняться. Также поток не может усыпить другой поток, так как метод sleep - это статический метод! Вы просто усыпите текущий поток и не более того! Также метод sleep() может возбуждать InterruptedException().  ";;;;;;;;;;;;;;;;;;;;;;
Multithreading.;В каких состояниях может быть поток в джава? Как вообще работает поток?;" нас есть текущий поток, в котором  выполняется метод main. Этот поток имеет свой стек и этот стек начинается с вызова метода main. Далее в методе main мы создаем новый поток, что происходит… создается новый поток и для него выделяется свой стек с первоначальным методом run(). Когда мы запускаем несколько потоков, то мы не можем гарантировать определенный порядок их вызовов. Планированием  потоков занимается планировщик  потоков JVM, выбирая из пулов потоков  поток. Мы даже не можем гарантировать  что если первый поток начался  выполнятся первым, то он и закончит выполнятся первым, он может закончить выполнятся последним. Еще такой ньюанс, что поток, который закончил свое выполнение, не может быть повторно запущен! Он находится в состоянии ""мертвый"", а для запуска потока нового потока, объект должен находится в состоянии ""новый"". Потоки  имеют такие состояния:      новый(это когда только создали экземпляр класса Thread)     живой  или работоспособный(переходит в это состояние после запуска метода start(), но это не означает что поток уже работает! Или же он может перейти в это состояние из состояние работающий или блокированный)     работающий(это когда метод run() начал выполнятся)     ожидающий (waiting)/Заблокированный (blocked)/Спящий(sleeping). Эти состояния характеризуют поток как не готовый к работе. Я объединил эти состояния т.к. все они имеют общую черту – поток еще жив (alive), но в настоящее время не может быть выполнен. Другими словами поток уже не работает, но он может вернутся в рабочее состояние. Поток может быть заблокирован, это может  означать что он ждет освобождение каких-то ресурсов. Поток может спать, если встретился метод sleep(long s) , или же он может ожидать, если встретился метод wait(), он будет ждать пока не вызовится метод notify() или notifyall().     мертвый(состояние когда метод run() завершил свою работу) ";;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Чем отличаются два интерфейса для реализации задач Runnable и Callable?;Основные различия:      Интерфейс Runnable появиля в Java 1.0, а интерфейс Callable был введен в Java 5.0 в составе библиотеки java.util.concurrent.     Классы, реализующие  интерфейс Runnable должны реализовывать метод run() для выполнения задачи. Классы, реализующие интерфейс Callable должны реализовывать метод call() для выполнения задачи.     Метод Runnable.run() не возвращает никакого значения, его тип void, а метод Callable.call() может возвращать значение типа T. Интерфейс Callable является параметризированным  Callable<T> и тип значения, которое будет возвращаться в методе call() задается этим параметром T.      Метод run() не может бросить проверяемое исключение, в то время как метод call() может бросить проверяемое исключение.   ;;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Различия между CyclicBarrier и CountDownLatch?; Хоть оба эти синхронизаторы позволяют нитям дожидаться друг друга, главное различие между ними в том, что вы не можете заново использовать CountDownLatch после того, как его счётчик достигнет нуля, но вы можете использовать CyclicBarrier снова, даже после того, как барьер сломается.;;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Что такое состояние гонки (race condition)?;Состояние гонки - причина трудноуловимых багов. Как сказано в самом названии, состояние гонки возникает из-за гонки между несколькими нитями, если нить, которая должна исполнятся первой, проиграла гонку и исполняется вторая, поведение кода изменяется, из-за чего возникают недетерменированные баги. Это одни из сложнейших к отлавливанию и воспроизведению багов, из-за беспорядочной природы гонок между нитями. Пример состояния гонки - беспорядочное исполнение.;;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Как остановить нить?;Java предоставляет богатые API для всего, но, по иронии судьбы, не предоставляет удобных способов остановки нити. В JDK 1.0 было несколько управляющих методов, например stop(), suspend() и resume(), которые были помечены как deprecated в будущих релизах из-за потенциальных угроз взаимной блокировки, с тех пор разработчики Java API не предприняли попыток представить стойкий, ните-безопасный и элегантный способ остановки нитей. Программисты в основном полагаются на факт того, что нить останавливается сама, как только заканчивает выполнять методы run() или call(). Для остановки вручную, программисты пользуются преимуществом volatile boolean переменной и проверяют её значение в каждой итерации, если в методе run() есть циклы, или прерывают нити методом interrupt() для внезапной отмены заданий.  ;;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Что происходит, когда в нити появляется исключение?;Это один из хороших вопросов с подвохом. Простыми словами, если исключение не поймано - нить мерта, если установлен обработчик непойманных исключений, он получит колбек. Thread.UncaughtExceptionHandler – интерфейс, определённый как вложенный интерфейс для обработчиков, вызываемых, когда нить внезапно останавливается из-за непойманного исключения. Когда нить собирается остановится из-за непойманного исключения, JVM проверит её на наличие UncaughtExceptionHandler, используя Thread.getUncaughtExceptionHandler(), и вызовет у обработчика метод uncaughtException(), передав нить и исключение в виде аргументов.;;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Что такое ThreadLocal переменная?;ThreadLocal переменные - специальный вид переменных, доступных Java программисту. Так же, как для состояний есть переменная состояния, для нитей есть ThreadLocal переменные. Это неплохой способ достичь ните-безопасности для затратных-для-создания объектов, например вы можете сделать SimpleDateFormat ните-безопасным, используя ThreadLocal. Так как это затратный класс, его нежелательно использовать в локальной области, которая требует отдельных экземпляров на каждый вызов. Предоставляя каждой нити её собственную копию, вы убиваете двух зайцев. Во-первых, вы уменьшаете количество экземпляров затратных объектов, используя по новой фиксированное количество экземпляров, и во-вторых, вы достигаете ните-безопасности, без потерь синхронизации и неизменяемости. Ещё один хороший пример локальной переменной у нити - класс ThreadLocalRandom, который уменьшает количество экземпляров затратных-для-создания объектов Random в много-нитиевой среде.;;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Что такое FutureTask?;FutureTask представляет собой отменяемое асинхронное вычисление в параллельном Java приложении. Этот класс предоставляет базовую реализацию Future, с методами для запуска и остановки вычисления, методами для запроса состояния вычисления и извлечения результатов. Результат может быть получен только когда вычисление завершено, метод получения будет заблокирован, если вычисление ещё не завершено. Объекты FutureTask могут быть использованы для обёртки объектов Callable и Runnable. Так как FutureTask реализует Runnable, его можно передать Executor’у на выполнение.;;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Различие между interrupted и isInterrupted?;Основное различие между interrupted() и isInterrupted() в том, что первый сбрасывает статус прерывания, а второй нет. Механизм прерывания в Java реализован с использованием внутреннего флага, известного как статус прерывания. Прерывание нити вызовом Thread.interrupt() устанавливает этот флаг. Когда прерванная нить проверяет статус прерывания, вызывая статический метод Thread.interrupted(), статус прерывания сбрасывается. Нестатический метод isInterrupted(), который используется нитью для проверки статуса прерывания у другой нити, не изменяет флаг прерывания. Условно, любой метод, который завершается, выкинув InterruptedException сбрасывает при этом флаг прерывания. Однако, всегда существует возможность того, что флаг тут же снова установится, если другая нить вызовет interrupt().;;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Почему методы wait и notify вызываются в синхронизированном блоке?;Основная причина вызова wait и notify из синхронизированого блока или метода в том, что Java API обязательно требует этого. Если вы вызовете их не из синхронизированного блока, ваш код выбросит IllegalMonitorStateException. Более хитрая причина в том, чтобы избежать состояния гонки между вызовами wait и notify.;;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Что такое пул нитей?;" Создание нити затратно в плане времени и ресурсов. Если вы создаёте нить во время обработки запроса, это замедлит время отклика, также процесс может создать только ограниченное число нитей. Чтобы избежать этих проблем, во время запуска приложения создаётся пул нитей и нити повторно используются для обработки запросов. Этот пул нитей называется ""thread pool"", а нити в нём – рабочая нить. Начиная с Java 1.5 Java API предоставляет фреймворк Executor, который позволяет вам создавать различные пулы нитей, например single thread pool, который обрабатывает только одно задание за единицу времени, fixed thread pool, пул с фиксированным количеством нитей, и cached thread pool, расширяемый пул, подходящий для приложений с множеством недолгих заданий.  ";;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Различия между livelock и deadlock?;Livelock схож с deadlock, только в livelock состояния нитей или вовлечённых процессов постоянно изменяются в зависимости друг от друга. Livelock - особый случай нехватки ресурсов. Реальный пример livelock'а - когда два человека встречаются в узком коридоре и каждый, пытаясь быть вежливым, отходит в сторону, и так они бесконечно двигаются из стороны в сторону.;;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Как проверить, удерживает ли нить lock?;Я и не подозревал, что можно проверять, удерживает ли нить lock в данный момент, до тех пор, пока не столкнулся с этим вопросом в одном телефонном интервью. В java.lang.Thread есть метод holdsLock(), он возвращает true, тогда и только тогда, когда текущая нить удерживает монитор у определённого объекта.;;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Как получить дамп нити?;Дамп нити позволяет узнать, чем нить занимается в данный момент. Существует несколько способов получения дампа нити, зависящих от операционной системы. В Windows вы можете использовать комбинацию ctrl + Break, в Linux - команду kill -3. Также вы можете воспользоваться утилитой jstack, она оперирует над id процесса, который вы можете узнать с помощью другой утилиты jps.;;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Какой JVM параметр используется для контроля размера стека нити?; Это один из простых, -Xss параметер используется для контроля размера стека нити в Java.;;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Различия между synchronized и ReentrantLock?;Были времена, когда единственный способ достижения взаимного исключения был через ключевое слово synchronized, но он имеет несколько недостатков, например нельзя расширить lock за пределами метода или блока кода и т.д. Java 5 решает эту проблему, предоставляя более утончённый контроль через интерфейс Lock. ReentrantLock – распространённая реализация Lock, которая предоставляет Lock с таким же базовым поведением и семантикой, как у неявного монитора, достигаемый использованием синхронизированных методов, но с расширенными возможностями.;;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Что такое Semaphore?;Semaphore - это новый тип синхронизатора. Это семафор со счётчиком. Концептуально, семафор управляет набором разрешений. Каждый acquire() блокируется, если необходимо, до того, как разрешение доступно, затем получает его. Каждый release() добавляет разрешение, потенциально освобождая блокирующий получатель (acquirer). Однако при этом не используются фактические объекты разрешений  Semaphore просто хранит количество доступных и действует соответственно. Semaphore используется для защиты дорогих ресурсов, которые доступны в ограниченном количестве, например подключение к базе данных в пуле.;;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Что будет, если очередь пула нитей уже заполнена, а вы подадите задачу?;" Если очередь пула нитей заполнилась, то поданная задача будет ""отклонена"". Метод submit() у ThreadPoolExecutor'а выкидывает RejectedExecutionException, после чего вызывается RejectedExecutionHandler.";;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Различия между методами submit() и execute() у пула нитей?;Оба метода являются способами подачи задачи в пул нитей, но между ними есть небольшая разница. Execute(Runnable command) определён в интерфейсе Executor и выполняет поданную задачу в будущем, но, что более важно, ничего не возвращает. С другой стороны submit() – перегруженный метод, он может принимать задачи типов Runnable и Callable и может возвращать объект Future, который можно использовать для отмены выполнения и/или ожидания результата вычислений. Этот метод определён в интерфейсе ExecutorService, который наследуется от интерфейса Executor, и каждый класс пула нитей, например ThreadPoolExecutor или ScheduledThreadPoolExecutor, наследует эти методы.;;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Что такое блокирующий метод?;Блокирующий метод - метод, который блокируется, до тех пор, пока не выполнится задание, например метод accept() у ServerSocket блокируется в ожидании подключения клиента. Здесь блокирование означает, что контроль не вернётся к вызывающему методу до тех пор, пока не выполнится задание. С другой стороны, существуют асинхронные или не блокирующиеся методы, которые завершаются до выполнения задачи.;;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Что такое ReadWriteLock?;В целом, ReadWriteLock - это результат техники разбора lock'а для улучшения производительности параллельных приложений. Это интерфейс, который был добавлен в Java 5. Он оперирует парой связанных lock’ов, один для операций чтения, один для записи. Читающий lock может удерживаться одновременно несколькими читающими нитями, до тех пор пока не будет записывающих. Записывающий lock эксклюзивен. Если хотите, вы можете реализовать интерфейс с вашим набором правил, или вы можете использовать ReentrantReadWriteLock, который поддерживает максимум 65535 рекурсивных записывающих lock'ов и 65535 читающих lock'ов.;;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Что такое double checked locking Синглтона?;Это старый способ создания ните-безопасного синглтона, который пытается оптимизировать производительность, блокируясь только когда экземпляр синглтона создаётся впервые.;;;;;;;;;;;;;;;;;;;;;;
Multithreading.;Что такое фреймворк Fork/Join?;"Фреймворк Fork/Join, представленный в JDK 7, - это мощная утилита, позволяющая разработчику пользоваться преимуществами нескольких процессоров у современных серверов. Он разработан для работы, которую можно рекурсивно разбить на маленькие частицы. Цель - использовать всю доступную вычислительную мощь, для увеличения производительности вашего приложения. Одного значительное преимущество этого фреймворка в том, что он использует work-stealing алгоритм (от work - работа и steal - красть). Рабочие нити, у которых закончились свои задания, могут ""своровать"" задания у других нитей, которые всё ещё заняты.";;;;;;;;;;;;;;;;;;;;;;
Сериализация.;Что такое сериализация?;Сериализация - это процес чтения или записи объекта. Это процесс сохранения состояния объекта и считывание этого состояния. Для реализации сериализации нужен интерфейс - маркер Serializable. Обратная операция - перевод байтов в объект, называется десериализацией.;;;;;;;;;;;;;;;;;;;;;;
Сериализация.;Как исключить поля из сериализации?;Для того чтоб исключить поля из сериализуемого потока, необходимо пометить поле модификатором transient.;;;;;;;;;;;;;;;;;;;;;;
Сериализация.;transient что значит?; Свойства класса, помеченные модификатором transient, не сериализуются. Обычно в таких полях хранится промежуточное состояние объекта, которое, к примеру, проще вычислить, чем сериализовать, а затем десериализавать. Другой пример такого поля - ссылка на экземпляр объекта, который не требует сериализации или не может быть сериализован.;;;;;;;;;;;;;;;;;;;;;;
Сериализация.;Как изменить стандартное поведение сериализации/десериализации?; В большинстве случаев мы не определяем поведение вручную, а полагаемся на стандартную реализацию, и очень не удобно постоянно переопределять какие-то методы сериализации + постоянно следить за добавлением новых полей, добавлять их в методы. Ну и специально для этих целей есть Externalizable. Тем не менее, мы знаем, что можно изменить стандартное поведение сериализации предопределив и поместив в свои файлы классов два метода: Обратите внимание, что оба метода объявлены как private, поскольку это гарантирует что методы не будут переопределены или перезагружены. Весь фокус в том, что виртуальная машина при вызове соответствующего метода автоматически проверяет, не были ли они объявлены в классе объекта. Виртуальная машина в любое время может вызвать private методы вашего класса, но другие объекты этого сделать не смогут. Таким образом обеспечивается целостность класса и нормальная работа протокол сериализации.  ;;;;;;;;;;;;;;;;;;;;;;
Сериализация.;Вы создали класс, чей суперкласс сериализуемый, но при этом вы не хотите чтобы ваш класс был сериализуемым, как остановить сериализацию?;" Вы не можете ""разреализовать"" интерфейс, поэтому если суперкласс реализует Serializable, то и созданный вами новый класс также будет реализовать его. Чтобы остановить автоматическую сериализацию вы можете применить private методы для создания исключительной ситуации NotSerializableException. Вот как это можно сделать: Любая попытка записать или прочитать этот объект теперь приведет к возникновению исключительной ситуации. Запомните, если методы объявлены как private, никто не сможет модифицировать ваш код не изменяя исходный код класса. Java не позволяет переопределять такие методы.";;;;;;;;;;;;;;;;;;;;;;
Сериализация.;Как создать собственный протокол сериализации?; Вместо реализации интерфейса Serializable, вы можете реализовать интерфейс Externalizable, который содержит два метода: Для создания собственного протокола нужно просто переопределить эти два метода. В отличие от двух других вариантов сериализации, здесь ничего не делается автоматически. Протокол полностью в ваших руках. Хотя это и наиболее сложный способ, при этом он наиболее контролируемый.;;;;;;;;;;;;;;;;;;;;;;
Сериализация.;Какая роль поля serialVersionUID в сериализации?; Поле private static final long serialVersionUID содержит уникальный идентификатор версии сериализованного класса. Оно вычисляется по содержимому класса - полям, их порядку объявления, методам, их порядку объявления. Соответственно, при любом изменении в классе это поле поменяет свое значение. Это поле записывается в поток при сериализации класса. Кстати, это, пожалуй, единственный известный случай, когда static-поле сериализуется.;;;;;;;;;;;;;;;;;;;;;;
Сериализация.;В чем проблема сериализации Singleton-ов?; Проблема в том что после десериализации мы получим другой объект. Таким образом, сериализация дает возможность создать Singleton еще раз, что не совсем не нужно. Конечно можно запретить сериализовать Singleton-ы, но это, фактически, уход от проблемы, а не ее решение. Решение же заключается в следующем. В классе определяется метод со следующей сигнатурой Модификатор доступа может быть private, protected и по умолчанию (default). Можно, наверное, сделать его и public, но смысла я в этом не вижу. Назначение этого метода - возвращать замещающий объект вместо объекта, на котором он вызван.;;;;;;;;;;;;;;;;;;;;;;
Design patterns.;Что такое шаблоны проектирования?;Шаблоны проектирования GoF - это многократно используемые решения широко распространенных проблем, возникающих при разработке программного обеспечения.;;;;;;;;;;;;;;;;;;;;;;
Design patterns.;Из каких элементов состоит шаблон?; В общем случае шаблон состоит из четырех основных элементов:      имя. Точное имя предоставляет возможность сразу понять проблему и определить решение. Уровень абстракции при проектировании повышается      задача. Область применения в рамках решения конкретной проблемы      решение. Абстрактное описание элементов дизайна задачи проектирования и способа ее решения с помощью обобщенного набора классов      результаты.   ;;;;;;;;;;;;;;;;;;;;;;
Design patterns.;Какие есть типы шаблонов?; Выделяются порождающие шаблоны, структурные шаблоны и шаблоны поведения а также антышаблоны.;;;;;;;;;;;;;;;;;;;;;;
Design patterns.;Назовите порождающие шаблоны, и кратко опишите их.; Порождающие шаблоны предназначаются для организации процесса создания объектов и все до единого соответствуют шаблону Creator из GRASP. К порождающим шаблонам относятся:      Abstract Factory (Абстрактная Фабрика) - предоставляет интерфейс для создания связанных между собой объектов семейств классов без указания их конкретных реализаций (families of product objects)      Factory Method (Фабричный метод) - определяет интерфейс для создания объектов из иерархического семейства классов на основе передаваемых данных (subclass of object that is instantiated)      Builder (Строитель) - создает объект конкретного класса различными способами (how a composite object gets created)      Singleton (Одиночка) - гарантирует существование только одного или конечного числа экземпляров класса (the sole instance of a class)      Prototype (Прототип) - применяется при создании сложных объектов. На основе прототипа объекты сохраняются и воссоздаются, например, путем копирования (class of object that is instantiated).   ;;;;;;;;;;;;;;;;;;;;;;
Design patterns.;Назовите шаблоны поведения, и кратко опишите их.; Шаблоны поведения GoF характеризуют способы взаимодействия классов или объектов между собой. К шаблонам поведения относятся:      Chain of Responsibility (Цепочка Обязанностей) - организует независимую от объекта-отправителя цепочку не знающих возможностей друг друга объектов-получателей, которые передают запрос друг другу (object that can fulfill a request)      Command (Команда) - используется для определения по некоторому признаку объекта конкретного класса, которому будет передан запрос для обработки (when and how a request is fulfilled)      Iterator (Итератор) - позволяет последовательно обойти все элементы коллекции или другого составного объекта, не зная деталей внутреннего представления данных (how an aggregate’s elements are accessed, traversed)      Mediator (Посредник) - позволяет снизить число связей между классами при большом их количестве, выделяя один класс, знающий все о методах других классов (how and which objects interact with each other)      Memento (Хранитель) - сохраняет текущее состояние объекта для дальнейшего восстановления (what private information is stored outside an object, and when)      Observer (Наблюдатель) - позволяет при зависимости между объектами типа «один ко многим» отслеживать изменения объекта (number of objects that depend on another object  how the dependent objects stay up to date)      State (Состояние) - позволяет объекту изменять свое поведение за счет изменения внутреннего объекта состояния (states of an object)      Strategy (Стратегия) - задает набор алгоритмов с возможностью выбора одного из классов для выполнения конкретной задачи во время создания объекта (an algorithm)      Template Method (Шаблонный Метод) - создает родительский класс, использующий несколько методов, реализация которых возложена на производные классы (steps of an algorithm)      Visitor (Посетитель) - представляет операцию в одном или нескольких связанных классах некоторой структуры, которую вызывает специфичный для каждого такого класса метод в другом классе (operations that can be applied to object(s) without changing their class(es))      Interpreter (Интерпретатор) - для определенного способа представления информации определяет правила (grammar and interpretation of a language).   ;;;;;;;;;;;;;;;;;;;;;;
Design patterns.;Назовите структурные шаблоны, и кратко опишите их.; Структурные шаблоны GoF отвечают за композицию объектов и классов, и не только за объединение частей приложения, но и за их разделение. К структурным шаблонам относятся:      Adapter (Адаптер) - применяется при необходимости использовать классы вместе с несвязанными интерфейсами. Поведение адаптируемого класса при этом изменяется на необходимое (interface to an object)      Bridge (Мост) - разделяет представление класса и его реализацию, позволяя независимо изменять то и другое (implementation of an object)      Composite (Компоновщик) - группирует объекты в иерархические древовидные структуры и позволяет работать с единичным объектом так же, как с группой объектов (structure and composition of an object)      Decorator (Декоратор) - представляет способ изменения поведения объекта без создания подклассов. Позволяет использовать поведение одного объекта в другом (responsibilities of an object without subclassing)      Facade (Фасад) - создает класс с общим интерфейсом высокого уровня к некоторому числу интерфейсов в подсистеме (interface to a subsystem)      Flyweight (Легковес) - разделяет свойства класса для оптимальной поддержки большого числа мелких объектов (storage costs of objects)      Proxy (Заместитель) - подменяет сложный объект более простым и осуществляет контроль доступа к нему (how an object is accessed... its location).   ;;;;;;;;;;;;;;;;;;;;;;
Design patterns.;Какие антишаблоны вы знаете?; Некоторые антишаблоны:      Big ball of mud (Большой Ком Грязи) - термин для системы или просто программы, которая не имеет хоть немного различимой архитектуры. Как правило, включает в себя более одного антишаблона. Этим страдают системы, разработанные людьми без подготовки в области архитектуры ПО.     Yo-Yo problem (Проблема Йо-Йо) - возникает, когда необходимо разобраться в программе, иерархия наследования и вложенность вызовов методов которой очень длинны и сложны. Программисту вследствие этого необходимо лавировать между множеством различных классов и методов, чтобы контролировать поведение программы. Термин происходит от названия игрушки йо-йо.     Magic Button - возникает, когда код обработки формы сконцентрирован в одном месте и, естественно, никак не структурирован.     Magic Number - наличие в коде многократно повторяющихся одинаковых чисел или чисел, объяснение происхождения которых отсутствует.      Gas Factory (Газовый Завод) - необязательный сложный дизайн для простой задачи.     Analiys paralisys. В разработке ПО (Паралич анализа) - проявляет себя через чрезвычайно длинные фазы планирования проекта, сбора необходимых для этого артефактов, программного моделирования и дизайна, которые не имеют особого смысла для достижения итоговой цели.     Interface Bloat (Распухший Интерфейс) - термин, используемый для описания интерфейсов, которые пытаются вместить в себя все возможные операции над данными.     Accidental complexity (Случайная сложность) - проблема в программировании, которой легко можно было избежать. Возникает вследствие неправильного понимания проблемы или неэффективного планирования.  ;;;;;;;;;;;;;;;;;;;;;;
Design patterns.;Что такое OOAD?;OOAD, Object Oriented Analysis and Design (Объектно-ориентированный анализ и проектирование) - дисциплина, описывающая способы (варианты) задания (определения) объектов и их взаимодействие для решения проблемы, которая определена и описана в ходе объектно-ориентированного анализа. Основная идея объектно-ориентированного анализа и проектирования (object-oriented analysis and design) состоит в рассмотрении предметной области и логического решения задачи с точки зрения объектов (понятий и сущностей). В процессе объектно-ориентированного анализа основное внимание уделяется определению и описанию объектов (или понятий) в терминах предметной области. В процессе объектно-ориентированного проектирования определяются логические программные объекты, которые будут реализованы средствами объектно-ориентированного языка программирования. Эти программные объекты включают в себя атрибуты и методы. И, наконец, в процессе конструирования (construction) или объектно-ориентированного программирования (object-oriented programming) обеспечивается реализация разработанных компонентов и классов.;;;;;;;;;;;;;;;;;;;;;;
Design patterns.;Что такое OOD?;OOD, Object Oriented Design (Объектно-ориентированное проектирование) - это методология проектирования, соединяющая в себе процесс объектной декомпозиции и приемы представления логической и физической, а также статической и динамической моделей проектируемой системы.;;;;;;;;;;;;;;;;;;;;;;
Design patterns.;Что такое OOA?;OOA, Object  Oriented Analysis (Объектно-ориентированный анализ) - это методология, при которой требования к системе воспринимаются с точки зрения классов и объектов, выявленных в предметной области, это методология проектирования, соединяющая в себе процесс объектной декомпозиции и приемы представления логической и физической, а также статической и динамической моделей проектируемой системы.  ;;;;;;;;;;;;;;;;;;;;;;
Design patterns.;Что такое DRY principles?;DRY, Don’t repeat yourself (не повторяй себя) - этот принцип настолько важен, что не требует повторения! Это принцип разработки программного обеспечения, нацеленный на снижение повторения информации различного рода, особенно в системах со множеством слоёв абстрагирования, простими словами НЕ пишите повторяющегося кода, используйте принцип абстракции, обобщая простые вещи в одном месте.  ;;;;;;;;;;;;;;;;;;;;;;
Design patterns.;Что такое KISS?;KISS, Keep it short and simple или Keep it simple, stupid (делайте вещи проще) -  это принцип проектирования и программирования, запрещающий использование более сложных средств, чем необходимо. Принцип декларирует простоту системы в качестве основной цели и/или ценности.  ;;;;;;;;;;;;;;;;;;;;;;
Design patterns.;Что такое YAGNI?;YAGNI, You ain't gonna need it (Вам это не понадобится) - процесс и принцип проектирования ПО, при котором в качестве основной цели и/или ценности декларируется отказ от избыточной функциональности. Суть в том, чтобы реализовать только поставленные задачи и отказаться от избыточного функционала.;;;;;;;;;;;;;;;;;;;;;;
Design patterns.;Что такое Yoda conditions?;"Yoda conditions (Условия Йоды в жаргоне программистов) - ""безопасный"" стиль записи выражений сравнения при программировании на языках с Си-синтаксисом, заключающийся в написании константного члена выражения (константы или вызова функции) слева от оператора сравнения (то есть 5 == a вместо привычного а == 5). Такой стиль призван предотвратить свойственную данным языкам ошибку - использование оператора присваивания ""="" вместо сравнения ""=="". Ошибочное использование присваивания превращает нотацию Йоды в попытку изменить константу, вызывая ошибку на этапе компиляции, что исключает возможность появления в готовой программе ошибок данного вида, а также облегчает их поиск и исправление в новом коде.  ";;;;;;;;;;;;;;;;;;;;;;
Design patterns.;Что такое CRC cards?;CRC cards, Class-responsibility-collaboration card (Класс-Ответственность-Кооперация) - метод мозгового штурма, предназначенный для проектирования объектно-ориентированного программного обеспечения. Как правило, CRC-карты используются в тех случаях, когда сначала в процессе проектирования ПО определяются классы и способы их взаимодействий. CRC-карты акцентируют внимание дизайнера на сущности класса и скрывают от него детали, рассмотрение которых на данном этапе будет контрпродуктивным. CRC-карты также заставляют дизайнера воздержаться от назначения классу слишком многих обязанностей.  ;;;;;;;;;;;;;;;;;;;;;;
Design patterns.;Что такое SOLID?;"SOLID, (single responsibility, open-closed, Liskov substitution, interface segregation и dependency inversion) -  акроним для первых пяти принципов, которые означали пять основных принципов объектно-ориентированного программирования и проектирования. Эти принципы, когда применяются вместе, предназначены для повышения вероятности того, что программист создаст систему, которую будет легко поддерживать и расширять в течение долгого времени. Принципы SOLID - это руководства, которые могут применяться во время работы над программным обеспечением для удаления ""кода с запашком"" предписывая программисту выполнять рефакторинг исходного кода, пока тот не станет разборчиво написанным и расширяемым. Это часть общей стратегии гибкой и адаптивной разработки.  ";;;;;;;;;;;;;;;;;;;;;;
Design patterns.;Что такое Single responsibility principle?;Single responsibility principle - принцип единственной обязанности (на каждый класс должна быть возложена одна-единственная обязанность). Если один класс java реализует 2 набора функций, их сцепление создает ситуацию, при которой изменение одного нарушит имеющееся сочетание.  ;;;;;;;;;;;;;;;;;;;;;;
Design patterns.;Что такое Open/closed principle?;"Open/closed principle - принцип объектно-ориентированного программирования, устанавливающий следующее положение: ""программные сущности (классы, модули, функции и т. п.) должны быть открыты для расширения, но закрыты для изменения""  это означает, что такие сущности могут позволять менять свое поведение без изменения их исходного кода.";;;;;;;;;;;;;;;;;;;;;;
Design patterns.;Что такое Liskov substitution principle?;Liskov substitution principle - принцип подстановки Барбары Лисков (функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом. Подклассы не могут замещать поведения базовых классов. Подтипы должны дополнять базовые типы).;;;;;;;;;;;;;;;;;;;;;;
Design patterns.;Что такое Interface segregation principle?;Interface segregation principle - принцип разделения интерфейса (много специализированных интерфейсов лучше, чем один универсальный). Иными словами большие, объемные интерфейсы надо разбивать на мелкие таким образом, чтобы клиенты маленьких интерфейсов знали только о тех методах которые необходимы им в работе. И чтобы при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют.;;;;;;;;;;;;;;;;;;;;;;
Design patterns.;Что такое Dependency inversion principle?;Dependency inversion principle -  принцип инверсии зависимостей (зависимости внутри системы строятся на основе абстракций. Модули верхнего уровня не зависят от модулей нижнего уровня. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций).;;;;;;;;;;;;;;;;;;;;;;
Design patterns.;Что такое GRASP?;GRASP, General Responsibility Assignment Software Patterns (общие шаблоны распределения обязанностей) -  шаблоны проектирования, используемые для решения общих задач по назначению обязанностей классам и объектам. Известно девять GRAPS шаблонов.;;;;;;;;;;;;;;;;;;;;;;
Design patterns.;Кратко опишите шаблоны GRAPS;GRASP выделяет следующие 9 принципов-шаблонов:      Information Expert (Информационные эксперт) - информационный эксперт описывает основополагающие принципы назначения обязанностей классам и объектам. Согласно описанию, информационным экспертом (объектом наделенным некоторыми обязанностями) является объект, обладающий максимумом информацией, необходимой для выполнения назначенных обязанностей.     Creator (Создатель) - суть ответственности такого объекта в том, что он создает другие объекты. Сразу напрашивается аналогия с фабриками. Так оно и есть. Фабрики тоже имеют именно ответственность - Создатель.     Controller (Контроллер) - отвечает за обработку входных системных событий, делегируя обязанности по их обработке компетентным классам. В общем случае, контроллер реализует один или несколько вариантов использования. Использование контроллеров позволяет отделить логику от представления, тем самым повышая возможность повторного использования кода.     Low Coupling (Слабая связанность) - если объекты в приложении сильно связаны, то любой их изменение приводит к изменениям во всех связанных объектах. А это неудобно и порождает баги. Вот по-этому везде пишут, что необходимо, чтобы код был слабо связан и зависел только от абстракций.     High Cohesion (Высокая сцепленность) - этот принцип тесно соотносится с слабой связанностью, и они идут в паре, когда одно всегда приводит к другому, это как мера того, что мы не нарушаем single resposibility principle. Вернее сказать, высокая сцепленность получается в результате соблюдения такого принципа из SOLID, как single resposibility principle (SRP).     Pure Fabrication (Чистая выдумка или чистое синтезирование) -  это класс, не отражающий никакого реального объекта предметной области, но специально придуманный для усиления связности, ослабления связанности или увеличения степени повторного использования. Pure Fabrication отражает концепцию сервисов в модели Программирование от предметной области.     Indirection (Посредник) - шаблон перенаправление реализует низкую связность между классами, путем назначения обязанностей по их взаимодействию дополнительному объекту - посреднику.     Protected Variations (Сокрытие реализации или защищенные изменения) - защищает элементы от изменения других элементов (объектов или подсистем) с помощью вынесения взаимодействия в фиксированный интерфейс. Всё взвимодействие между элементами должно происходить через него. Поведение может варьироваться лишь с помощью создания другой реализации интерфейса.     Polymorphism (Полиморфизм) - позволяет обрабатывать альтернативные варианты поведения на основе типа и заменять подключаемые компоненты системы. Обязанности распределяются для различных вариантов поведения с помощью полиморфных операций для этого класса. Все альтернативные реализации приводятся к общему интерфейсу. ;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Что такое котлин?;Kotin - это язык программирования с открытым исходным кодом, который выполняется с использованием виртуальной машины Java в качестве своей платформы. Он был разработан JetBrains. Он сравнительно проще, чем Java, и предлагает несколько функций, которые Java не может удержать. это комбинация процедурного и объектно-ориентированного языка программирования.;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Как работает Котлин?;Kotlin работает на виртуальной машине Java для ее выполнения. Весь код kotlin конвертируется в собственный код, и этот процесс преобразования байт-кода также может быть достигнут с помощью других относительных виртуальных машин.;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Ключевые особенности котлина, которых нет в Java?;Есть несколько ключевых функций, которые недоступны в Java.      Функции расширения     Перегрузка оператора     Умные броски     Классы данных     Выражения диапазона     Нулевая безопасность     Сопрограммы     Сопутствующие объекты;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Важные преимущества котлина;Синтаксически напоминает Java, а также легко выучить язык     Функциональный язык встроенная ссылка на JVM     Читаемость и понятность кода очень высока;;;;;;;;;;;;;;;;;;;;;;
Kotlin;В списке java.io.file методы расширения, которые предоставляет kotlin?;Некоторый метод расширения обеспечивает:      bufferedReader (): чтение файла в BufferedReader     readBytes (): чтение файла в ByteArray     readText (): чтение файла в одну строку     forEachLine (): использовать для чтения файла построчно в Kotlin     readLines (): чтение файла в список;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Kotlin const vs val?;Ключевое слово const используется для инициализации во время компиляции     Ключевое слово val используется для инициализации во время выполнения;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Первичные конструкторы против вторичных конструкторов?;Первичные конструкторы утверждаются по существу в определении класса. Вторичные Конструкторы утверждаются исключительно внутри тела класса. В следующем примере в первой строке ключевое слово constructor, включающее переменные, объявленные сразу после того, как он является первичным конструктором. Вторичный конструктор - это тот, который объявлен внутри тела класса.  конструктор класса A (var nme: String, var age: Int)  (var обозначение: String = «Не упоминается» конструктор класса A (var nme: String, var age: Int) (  конструктор (nme: String, age: Int, обозначение: String): this (имя, возраст) (  this.designation = обозначение;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Есть ли возможность перенести код с Kotlin на Java? ;Да, миграция Kotlin в java-код, безусловно, возможна. Для решения этой задачи по миграции используется встроенный инструмент, разработанный компанией Jet BRAINS.;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Поддерживает ли Kotlin примитивные типы данных, как в Java, если да, пожалуйста, объясните их подробно?;Ни один kotlin не поддерживает примитивные типы данных, как в Java.;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Перечислите ключевые модификаторы, которые связаны с Kotlin?;    общественности     частный     защищенный     интервал;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Что за тип такой — Unit? Зачем нужен?;;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Как компилируются object declarations и companion objects?;;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Какая польза от typealias? Во что он компилируется?;;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Зачем нужен тип Nothing, какие выражения имеют такой тип? Какие ограничения накладываются на Nothing?;;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Когда компилятор использует примитивные типы? В каких случаях происходит автобоксинг? *;;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Какие объекты выделяются при вызове forEach, map, reduce, fold и т. п. на Iterable? на Sequence?;;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Зачем вообще нужны Sequences?;;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Что такое функциональный тип, какие у него ограничения?;;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Как работают SAM-conversions?;;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Что такое функции высшего порядка (higher-order functions), лямбда-выражения (lambda-expressions), анонимные функции (anonymous functions), указатели на методы (method references, bound callable references)?;;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Какой толк от inline-функций, как компилируется сама функция и места её использования?;;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Как работают crossinline и noinline?;;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Можно ли в лямбде изменить значение переменной, захваченной из внешней области видимости? Как это работает в inline-функциях? noinline-функциях? во многопоточном окружении?;;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Что использовать вместо try-with-resources?;;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Как компилируются default-методы в интерфейсах? *;;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Как компилируются extension-функции и как использовать их из Java?;;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Можно ли сделать extension к интерфейсу? Тайпалиасу? Функциональному типу?;;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Может ли функция быть одновременно member и extension? Как её использовать?;;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Почему присваивания — не выражения (assignments are not expressions)?;;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Что такое exhaustive when, на каких типах он возможен?;;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Чем дженерики в Kotlin отличаются от джавовых?;;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Что такое declaration-site variance? Где помогает, где затрудняет разработку, как выглядит из Java?;;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Как устроен reified, почему работает только в inline-функциях? *;;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Как с помощью reified получить не сырой тип (класс), а параметризованный тип (parameterized type) со всеми его аргументами (actual type arguments)?;;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Зачем нужны корутины? Почему бы не наплодить обычных тредов?;;;;;;;;;;;;;;;;;;;;;;;
Kotlin;Как устроена трансформация suspend-функций? *;;;;;;;;;;;;;;;;;;;;;;;
JDBC.;Что такое JDBC?;API JDBC (Java DataBase Connectivity) - стандартный прикладной интерфейс языка Java для организации взаимодействия между приложением и СУБД. Взаимодействие осуществляется с помощью драйверов JDBC, обеспечиваю щих реализацию общих интерфейсов для конкретных СУБД и конкретних протоколов. В JDBC определяются четыре типа драйверов.;;;;;;;;;;;;;;;;;;;;;;
JDBC.;Этапы работы с базой данных с использованием JDBC?;Этапы работы с базой данных с использованием JDBC:      Подключение библиотеки с классом-драйвером базы данных.     Установка соединения с БД.     Создание объекта для передачи запросов.     Выполнение запроса.     Обработка результатов выполнения запроса.     Закрытие соединения, statement ;;;;;;;;;;;;;;;;;;;;;;
JDBC.;Как создать Connection?; Для установки соединения с БД вызывается статический метод getConnection() класса java.sql.DriverManager. В качестве параметров методу передаються URL базы данных, логин пользователя БД и пароль доступа. Загрузка класса драйвера базы данных при отсутствии ссылки на экземпляр этого класса в JDBC 4.1 происходит автоматически при установке соединения екземпляром DriverManager. Метод возвращает объект Connection. URL базы данных, состоящий из типа и адреса физического расположения БД, может создаваться в виде отдельной строки или извлекаться из файла ресурсов. Соответственно: В результате будет возвращен объект Connection и будет одно установленное соединение с БД с именем testphones. Класс DriverManager предоставляет средства для управления набором драйверов баз данных.  ;;;;;;;;;;;;;;;;;;;;;;
JDBC.;Чем отличается Statement от PreparedStatement?;" Объект Statement используется для выполнения SQL-запросов к БД. Существует три типа объектов Statement. Все три служат как бы конейнерами для выполнения SQL-выражений через данное соединение: Statement, PreparedStatement, наследующий от Statement, и CallableStatement, наследующий от PreparedStatement. Они специализируются на различных типах запросов: Statement используется для выполнения простых SQL-запросов без параметров  PreparedStatement используется для выполнения прекомпилированных SQL-запросов с или без входных (IN) параметров  CallableStatement используется для вызовов хранимых процедур. Интерфейс Statement предоставляет базовые методы для выполнения запросов и извлечения результатов. Интерфейс PreparedStatement добавляет методы управления входными (IN) параметрами  CallableStatement добавляет методы для манипуляции выходними (OUT) параметрами. Интерфейс PreparedStatement наследует от Statement и отличается от последнего следующим: Экземпляры PreparedStatement ""помнят"" скомпилированные SQL-выражения. Именно поэтому они называются ""prepared"" (""подготовленные""). SQL-выражения в PreparedStatement могут иметь один или более входной (IN) параметр. Входной параметр - это параметр, чье значение не указывается при создании SQL-выражения. Вместо него в выражении на месте каждого входного параметра ставится знак (""?""). Значение каждого вопросительного знака устанавливается методами setXXX перед выполнением запроса.  ";;;;;;;;;;;;;;;;;;;;;;
JDBC.;Как вызвать хранимую процедуру?;Хранимые процедуры – это именованный набор операторов Transact-SQL хранящийся на сервере. Такую процедуру можно легко вызвать из Java-класса с помощью специального синтаксиса. При вызове такой процедуры необходимо указать ее имя и определить список параметров. Имя и список параметров посылаются по JDBC-соединению в СУБД, которая выполняет вызываемую процедуру и возвращает результат (если таковой имеется) обратно, используя это же соединение. JDBC Java-код для выполнения хранимой процедуры, использующий объект Statement без параметров. ;;;;;;;;;;;;;;;;;;;;;;
JDBC.;Как правильно закрыть Connection?;st.close cn.close После того, как база больше не нужна, соединение закрывается. Для того, чтобы правильно пользоваться приведенными методами, программисту требуется знать типы полей БД. В распределенных системах это знание предполагается изначально. В Java 7 для объектов-ресурсов, требующих закрытия, реализована технология try with resources.;;;;;;;;;;;;;;;;;;;;;;
JDBC.;Какие есть уровни изоляции транзакций?; Уровни изоляции транзакций определены в виде констант интерфейса Connection (по возрастанию уровня ограничения):      TRANSACTION_NONE - информирует о том, что драйвер не поддерживает транзакции      TRANSACTION_READ_UNCOMMITTED - позволяет транзакциям видеть несохраненные изменения данных, что разрешает грязное, неповторяющееся и фантомное чтения      TRANSACTION_READ_COMMITTED - означает, что любое изменение, сделанное в транзакции, не видно вне ее, пока она не сохранена. Это предотвращает грязное чтение, но разрешает неповторяющееся и фантомное      TRANSACTION_REPEATABLE_READ - запрещает грязное и неповторяющееся чтение, но фантомное разрешено      TRANSACTION_SERIALIZABLE - определяет, что грязное, неповторяющееся и фантомное чтения запрещены.   ;;;;;;;;;;;;;;;;;;;;;;
JDBC.;Какие есть типов чтения транзакций?; Для транзакций существует несколько типов чтения:      грязное чтение (dirty reads) происходит, когда транзакциям разрешено видеть несохраненные изменения данных. Иными словами, изменения, сделанные в одной транзакции, видны вне ее до того, как она была сохранена. Если изменения не будут сохранены, то, вероятно, другие транзакции выполняли работу на основе некорректных данных      неповторяющееся чтение (nonrepeatable reads) происходит, когда транзакция А читает строку, транзакция Б изменяет эту строку, транзакция А читает ту же строку и получает обновленные данные      фантомное чтение (phantom reads) происходит, когда транзакция А считывает все строки, удовлетворяющие WHERE-условию, транзакция Б вставляет новую или удаляет одну из строк, которая удовлетворяет этому условию, транзакция А еще раз считывает все строки, удовлетворяющие WHERE-условию, уже вместе с новой строкой или недосчитавшись старой.  ;;;;;;;;;;;;;;;;;;;;;;
Базы данных.;Что такое База Данных?;Под базой данных (БД) понимается некий организованный набор информации. В качестве примера простейшей БД можно привести список товаров, каждый из которых обладает набором стандартных характеристик (наименование, единица измерения, количество, цена и т. д.).;;;;;;;;;;;;;;;;;;;;;;
Базы данных.;Модель данных в реляционных СУБД?;Прежде чем сохранять какие-либо данные в СУБД, необходимо описать их модель. По типу модели данных СУБД делятся на сетевые, объектные, иерархические и реляционные. СУБД реляционного типа являются наиболее распространенными и часто используемыми. В качестве примеров можно привести Oracle и Microsoft SQL Server.;;;;;;;;;;;;;;;;;;;;;;
Базы данных.;Что такое нормализация?; Процесс приведения базы данных к виду, в котором она будет соответствовать правилам нормальных форм, называется нормализацией базы данных. Нормализация базы данных сводит к минимуму количество избыточной информации. Ее целью является сохранять данные только один раз, но в нужном месте. Нормализованная база данных исключает дублирование и многократное обслуживание данных, а также появление проблем с целостностью данных, возникающих при повторном вводе одинаковых данных. Первоначально доктором Эдгаром Коддом были определены только 3 нормальные формы. Дальнейшая разработка реляционной теории привела к появлению еще нескольких форм и на данный момент их насчитывается 8. На практике соответствие базы данных правилам 3-ей нормальной формы вполне достаточно.      Первая нормальная форма гласит: информация в каждом поле таблицы является неделимой и не может быть разбита на подгруппы.     Вторая нормальная форма гласит: таблица соответствует 1НФ и в таблице нет неключевых атрибутов, зависящих от части сложного (состоящего из нескольких столбцов) первичного ключа.     Третья нормальная форма гласит: таблица соответствует первым двум НФ, и все неключевые атрибуты зависят только от первичного ключа и не зависят друг от друга. ;;;;;;;;;;;;;;;;;;;;;;
Базы данных.;Какие есть типы связей в базе данных. Приведите пример.;" Связь работает путем сопоставления данных в ключевых столбцах  обычно это столбцы с одним и тем же именем в обеих таблицах. В большинстве случаев связь сопоставляет первичный ключ одной таблицы, являющийся уникальным идентификатором каждой строки этой таблицы, с записями внешнего ключа другой таблицы. Существует три типа связей между таблицами. Тип создаваемой связи зависит от того, как определены связанные столбцы. Один-к-одному - в связи ""одному к одному"" строке таблицы А может сопоставляться только одна строка таблицы Б, и наоборот. Связь ""один к одному"" создается, если для обоих связанных ключей определены ограничения первичного ключа или уникальности. Этот тип связи обычно не используется, так как большую часть связанных таким образом данных можно хранить в одной таблице. Связь ""один к одному"" можно использовать для:      Разделения таблицы со многими столбцами.     Изоляции части таблицы из соображений безопасности.     Хранения кратковременных данных, которые можно легко удалить вместе со всей таблицей.     Хранения данных, которые относятся только к части основной таблицы.  Столбец, являющийся первичным ключом в связи ""один к одному"", отмечается символом ключа. Столбец, являющийся внешним ключом, также отмечается символом ключа. Один-ко-многим - самая распространенная. В этом типе связей у строки таблицы А может быть несколько совпадающих строк таблицы Б, но каждой строке таблицы Б может соответствовать только одна строка из А. Например, между таблицами publishers и titles установлена связь ""один ко многим"": каждый издатель публикует много книг, но каждая книга публикуется только у одного издателя. Используйте связь ""один ко многим"", если только у одного из связанных столбцов есть ограничение первичного ключа или уникальности. Столбец, являющийся первичным ключом в связи ""один ко многим"", отмечается символом ключа. Столбец, являющийся внешним ключом в связи ""один ко многим"", отмечается символом бесконечности. Многие-ко-многим - строке таблицы А может сопоставляться несколько строк таблицы Б, и наоборот. Такие связи создаются определением третьей таблицы, которая называется таблицей соединения, чей первичный ключ состоит из внешних ключей А и Б. Например, между таблицами authors и titles связь ""многие ко многим"" определена через связи ""один ко многим"" каждой из этих таблиц с таблицей titleauthors. Первичный ключ таблицы titleauthors представляет собой сочетание столбца au_id (первичный ключ таблицы authors) и столбца title_id (первичный ключ таблицы titles).  ";;;;;;;;;;;;;;;;;;;;;;
Базы данных.;Что такое primary key (первичный ключ)?;Первичный ключ (или главный ключ, primary key, PK). Представляет собой столбец или совокупность столбцов, значения которых однозначно идентифицируют строки. В данном примере первичным ключом в таблице Сотрудники является столбец Табельный №, ибо в одной организации не бывает сотрудников с одинаковыми табельными номерами. Очевидно, что в таблице Отделы первичным ключом является столбец, содержащий номер отдела.;;;;;;;;;;;;;;;;;;;;;;
Базы данных.;Что такое foreign key (внешний ключ)?;Вторичный (или внешний ключ, foreign key, FK). Столбец или совокупность столбцов, которые в данной таблице не являются первичными ключами, но являются первичными ключами в другой таблице. В рассматриваемом примере(в предыдущем вопросе) столбец № отдела таблицы Сотрудники содержит вторичный ключ, с помощью которого может быть установлена логическая взаимосвязь строк таблицы с соответствующими строками таблицы Отделы.;;;;;;;;;;;;;;;;;;;;;;
Базы данных.;Что такое индексы в базе данных? Для чего их используют? Чем они хороши и чем плохи?;Индексы - это специальные структуры в базах данных, которые позволяют ускорить поиск и сортировку по определенному полю или набору полей в таблице, а также используются для обеспечения уникальности данных. Проще всего индексы сравнить с указателями в книгах. Если нет указателя, то нам придется просмотреть всю книгу, чтобы найти нужное место, а с указателем то же действие можно выполнить намного быстрее. Обычно чем больше индексов, тем больше производительность запросов к базе данных. Однако при излишнем увеличении количества индексов падает производительность операций изменения данных (вставка/изменение/удаление), увеличивается размер БД, поэтому к добавлению индексов следует относиться осторожно. Некоторые общие принципы, связанные с созданием индексов:      индексы необходимо создавать для столбцов, которые используются в джойнах, по которым часто производится поиск и операции сортировки. При этом необходимо учесть, что индексы всегда автоматически создаются для столбцов, на которые накладывается ограничение primary key. Чаще всего они создаются и для столбцов с foreign key (в Access - автоматически)      индекс обязательно в автоматическом режиме создается для столбцов, на которые наложено ограничение уникальности      лучше всего индексы создавать для тех полей, в которых - минимальное число повторяющихся значений и данные распределены равномерно. В Oracle есть специальные битовые индексы для столбцов с большим количеством повторяющихся значений, в SQL Server и Access такой разновидности индексов не предусмотрено      если поиск постоянно производится по определенному набору столбцов (одновременно), то в этом случае, возможно, есть смысл создать композитный индекс (только в SQL Server) - один индекс для группы столбцов      при внесении изменений в таблицы автоматически изменяются и индексы, наложенные на эту таблицу. В результате индекс может быть сильно фрагментирован, что сказывается на производительности. Периодически следует проверять степень фрагментации индексов и дефрагментировать их. При загрузке большого количества данных иногда есть смысл вначале удалить все индексы, а после завершения операции создать их заново      индексы можно создавать не только для таблиц, но и для представлений (только в SQL Server). Преимущества - возможность вычислять поля не в момент запроса, а в момент появления новых значений в таблицах.   ;;;;;;;;;;;;;;;;;;;;;;
Базы данных.;Какие есть типы индекса?;В базе данных, в зависимости от ее функциональных возможностей, можно создавать индексы четырех типов: уникальный, кластерный, полнотекстовый и индекс первичного ключа. Индексы создаются в конструкторе баз данных. Сведения о функциях индексации, поддерживаемых в той или иной базе данных.      Уникальный индекс - уникальным является индекс, в котором не может быть двух строк с одним и тем же значением индекса. В большинстве баз данных не допускается сохранение таблицы с созданным в ней уникальным индексом, если в существующих данных имеются повторяющиеся значения ключа. В базе данных может быть также запрещено добавление новых данных, приводящее к появлению дубликатов значений ключа в таблице. Например, если создать уникальный индекс по фамилии сотрудника (lname) в таблице employee, в ней не должно быть двух сотрудников с одинаковыми фамилиями.     Индекс первичного ключа - в таблице базы данных обычно имеется столбец или комбинация столбцов, значения которых однозначно идентифицируют каждую строку таблицы. Такой столбец называется первичным ключом таблицы. Определение первичного ключа для таблицы в схеме базы данных автоматически приводит к созданию индекса первичного ключа, который является разновидностью уникального индекса. Этот индекс требует уникальности каждого значения первичного ключа. Он также обеспечивает быстрый доступ к данным при использовании индекса первичного ключа в запросах.      Кластерный индекс - в кластерном индексе физический порядок строк в таблице совпадает с логическим (индексированным) порядком значений ключа. У таблицы может быть только один кластерный индекс. Если индекс не кластеризован, физический порядок строк таблицы отличается от логического порядка значений ключа. Кластерный индекс обычно обеспечивает более быстрый доступ к данным, чем прочие индексы.     Полнотекстовый индекс - полнотекстовый индекс создается, если нужно выполнять полнотекстовый поиск по текстовым столбцам таблиц базы данных. Полнотекстовый индекс зависит от обычного индекса, поэтому сначала надо будет создать его. Обычный индекс должен быть создан для одного столбца, не допускающего значения NULL, и лучше всего выбирать столбцы с маленькими значениями, а не большими. ;;;;;;;;;;;;;;;;;;;;;;
SQL.;Что такое SQL?;"SQL (structured query language - ""язык структурированных запросов"") - формальный непроцедурный язык программирования, применяемый для создания, модификации и управления данными в произвольной реляционной базе данных, управляемой соответствующей системой управления базами данных (СУБД). SQL основывается на исчислении кортежей.";;;;;;;;;;;;;;;;;;;;;;
SQL.;Какие есть типы JOIN'ов. Кратко опишите каждый из типов.;(INNER)JOIN - внутреннее соединение. В результирующем наборе присутствуют только записи, значения связанных полей в которых совпадают. LEFT JOIN - левое внешнее соединение. В результирующем наборе присутствуют все записи из Table1 и соответствующие им записи из Table2. Если соответствия нет, поля из Table2 будут пустыми. RIGHT JOIN - правое внешнее соединение. В результирующем наборе присутствуют все записи из Table2 и соответствующие им записи из Table1. Если соответствия нет, поля из Table1 будут пустыми. FULL JOIN - полное внешнее соединение. Комбинация двух предыдущих. В результирующем наборе присутствуют все записи из Table1 и соответствующие им записи из Table2. Если соответствия нет - поля из Table2 будут пустыми. Записи из Table2, которым не нашлось пары в Table1, тоже будут присутствовать в результирующем наборе. В этом случае поля из Table1 будут пустыми. CROSS JOIN - Cartesian product. Результирующий набор содержит все варианты комбинации строк из Table1 и Table2. Условие соединения при этом не указывается.  ;;;;;;;;;;;;;;;;;;;;;;
SQL.;Что такое LEFT JOIN, RIGHT JOIN? Чем они отличаются?;LEFT JOIN - левое внешнее соединение. В результирующем наборе присутствуют все записи из Table1 и соответствующие им записи из Table2. Если соответствия нет, поля из Table2 будут пустыми. RIGHT JOIN - правое внешнее соединение. В результирующем наборе присутствуют все записи из Table2 и соответствующие им записи из Table1. Если соответствия нет, поля из Table1 будут пустыми.  ;;;;;;;;;;;;;;;;;;;;;;
SQL.;Для чего используется слово HAVING?;Секция HAVING определяет условие, которое затем применяется к групам строк. Следовательно, это предложение имеет тот же смысл для группы строк, что и предложение WHERE в отношении соодержимого соответствующей таблицы. Синтаксис предложения HAVING  HAVING  condition где condition содержит агрегатные функции или константы. Важно понимать, что секции HAVING и WHERE взаимно дополняют друг друга. Сначала с помощью ограничений WHERE формируется итоговая выборка, затем выполняется разбивка на группы по значениям полей, заданных в GROUP BY. Далее по каждой группе вычисляется групповая функция и в заключение накладывается условие HAVING. Пример: SELECT DeptNum, MAX(SALARY) FROM Employees GROUP BY DeptNum HAVING MAX(SALARY) > 1000 В приведенном примере в результат попадут только отделы, максимальная зарплата в которых превышает 1000.  ;;;;;;;;;;;;;;;;;;;;;;
SQL.;Что такое DDL?;DDL(Data Definition Language) - Команды определения структуры данных. В состав DDL-группы входят команды, позволяющие определять внутреннюю структуру базы данных. Перед тем, как сохранять данные в БД, необходимо создать в ней таблицы и, возможно, некоторые другие сопутствующие объекты Пример некоторых DDL-команд:(CREATE TABLE, DROP TABLE);;;;;;;;;;;;;;;;;;;;;;
SQL.;Что такое DML?;DML(Data Manipulation Language) - Команды манипулирования данными. DML-группа содержит команды, позволяющие вносить, изменять, удалять и извлекать данные из таблиц. Примеры DML-команд: UPDATE,DELETE,INSERT, SELECT;;;;;;;;;;;;;;;;;;;;;;
SQL.;Что такое TCL?;TCL(Transaction Control Language) - TCL-команды используются для управления изменениями данных, производимыми DML-командами. С их помощью несколько DML-команд могут быть объединены в единое логическое целое, называемое транзакцией. При этом все команды на изменение данных в рамках одной транзакции либо завершаются успешно, либо все могут быть отменены в случае возникновения каких-либо проблем с выполнением любой из них. COMMIT,ROLLBACK,SETTRANSACTION;;;;;;;;;;;;;;;;;;;;;;
SQL.;Что такое DCL?;DCL(Data Control Language) - Команды управления доступом. DCL-команды управляют доступом пользователей к БД и отдельным объектам:GRANT,REVOKE;;;;;;;;;;;;;;;;;;;;;;
SQL.;Какой общий синтаксис команди SELECT?;;;;;;;;;;;;;;;;;;;;;;;
SQL.;Про NULL в SQL.;Необходимо отметить, что язык SQL, в отличие от языков программирования, имеет встроенные средства поддержки факта отсутствия каких-либо данных. Осуществляется это с помощью NULL-концепции. NULL не является каким-то фиксированным значением, хранящимся в поле записи вместо реальных данных. Значение NULL не имеет определенного типа. NULL — это индикатор, говорящий пользователю (и SQL) о том, что данные в поле записи отсутствуют. Поэтому его нельзя использовать в операциях сравнения. Для проверки факта наличия-отсутствия данных в SQL введены специальные выражения.;;;;;;;;;;;;;;;;;;;;;;
SQL.;Если вы собираетесь соединить несколько таблиц в запросе (например, n таблиц), сколько условий соединения вам нужно использовать?;Тогда нужно использовать n-1 условий соединения чтоб исключить декартовой соединения, может быть и такое, что потребуется больше чем n-1 условий соединения, и совсем другие условия соединения для дальнейшего сокращения результирующего набора данных.;;;;;;;;;;;;;;;;;;;;;;
SQL.;Какое практическое применение временных таблиц?;Временная таблица - это объект базы данных, который хранится и управляется системой базы данных на временной основе. Они могут быть локальными или глобальными. используется для сохранения результатов вызова хранимой процедуры, уменьшение числа строк при соединениях, агрегирование данных из различных источников или замена курсоров и параметризованных представлений.  ;;;;;;;;;;;;;;;;;;;;;;
SQL.;Как оператор GROUP BY обрабатывает значение NULL? Ли это общем трактовке таких значений?;При использовании GROUP BY все значения NULL считаются равными. Значение NULL - это специальное значение, которое можно присвоить ячейке таблицы. Это значение обычно применяется, когда информация в ячейке неизвестна или неприемлема.;;;;;;;;;;;;;;;;;;;;;;
SQL.;В чем разница между COUNT (*) и COUNT (столбец)?;"форма COUNT (столбец) подсчитывает количество значений в ""столбец"". При подсчете количества значений столбца эта форма функции COUNT не принимает во внимание значение NULL. функция COUNT (*) подсчитывает количество строк в таблице, не игнорирует значение NULL, поскольку эта функция оперирует строками, а не столбцами.";;;;;;;;;;;;;;;;;;;;;;
SQL.;В чем разница между операторами DISTINCT и GROUP BY?;DISTINCT - указывает, что для вычислений используются только уникальные значения столбца. NULL считается как отдельное значение. Если нужно удалить только дубликаты лучше использовать DISTINCT. GROUP BY группирует выбранный набор строк для получения набора сводных строк по значениям одного или нескольких столбцов или выражений. GROUP BY создает отдельную группу для всех возможных значений (включая значение NULL). GROUP BY лучше использовать для определения групп выходных строк, к которым могут применяться агрегатные функции (COUNT, MIN, MAX, AVG и SUM).  ;;;;;;;;;;;;;;;;;;;;;;
SQL.;Есть таблица table1 с колонками id и datetime написать запрос который вернет максимальное значение id и значение даты для этого id.;;;;;;;;;;;;;;;;;;;;;;;
SQL.;Для чего нужны операторы UNION, INTERSECT, EXCEPT?;Оператор UNION - применяется для объединения результатов двух SQL-запросов в единую таблицу, состоящую из похожих срок. Оба запроса Должны возвращать одинаковое число столбцов и совместимые типы данных в соответствующих столбцах. Оператор INTERSECT - используется для нахождения пересечения двух множеств. Результатом его выполнения будет множество строк, которые присутствуют в обоих множествах. Оператор EXCEPT - используется для нахождения разности двух множеств. Результатом выполнения является множество строк из множества 1, которые отсутствуют в множестве 2. Приоритет выполнения операторов над множествами: INTERSECT -> EXCEPT -> UNION  ;;;;;;;;;;;;;;;;;;;;;;
SQL.;Что лучше использовать соединение или подзапросы?;Обычно лучше использовать JOIN, поскольку в большинстве случаев он понятен, и лучше оптимизируется с помощью Database Engine. но не всегда. Соединение имеет преимущество над подзапросов в случае, когда список выбора SELECT в запросе содержит столбцы более чем одной таблицы. Подзапросы лучшие тогда, когда нужно вычислять агрегатные значение и использовать их во внешних запросах для сравнений.;;;;;;;;;;;;;;;;;;;;;;
SQL.;Что делает функция EXISTS?;Аргументом функции EXISTS есть внутренний запрос. она возвращает истину, если запрос возвращает один или более строк, и возвращает ложь если запрос вернет ноль строк.;;;;;;;;;;;;;;;;;;;;;;
SQL.;Использование оператора PIVOT.;Реляционный оператор PIVOT можно использовать для изменения возвращающего табличное значение выражения в другой таблице. Оператор PIVOT разворачивает возвращающее табличное значение выражение, преобразуя уникальные значения одного столбца выражения в несколько выходных столбцов, а также, в случае необходимости, объединяет оставшиеся повторяющиеся значения столбца и отображает их в выходных данных.;;;;;;;;;;;;;;;;;;;;;;
SQL.;Опишите разницу типов данных DATETIME и TIMESTAMP.;DATETIME предназначен для хранения целого числа: YYYYMMDDHHMMSS. И это время не зависит от временной зоны настроенной на сервере.Хранит: 8 байт TIMESTAMP хранит значение равное количеству секунд, прошедших с полуночи 1 января 1970 года по усреднённому времени Гринвича. При получении из базы отображается с учётом часового пояса. Хранит: 4 байта.;;;;;;;;;;;;;;;;;;;;;;
SQL.;Для каких числовых типов недопустимо использовать операцию сложения (вычитания), а значит и функцию SUM()?;В качестве операндов операций сложения и вычитания допустимо любое корректное выражение любого типа данных числовой категории, кроме типа данных bit.;;;;;;;;;;;;;;;;;;;;;;
SQL.;Что такое хранимые процедуры?;Хранимая процедура - компилируемый набор SQL-инструкций, являющийся частью базы данных и хранимый на сервере. Есть много общего между ХП и обычными процедурами языков программирования: они могут иметь входные параметры и выходной результат, они могут как выполнять различные численные вычисления, так и выполнять стандартные операции с БД. Как и в процедурах других языков программирования, в них могут быть циклы и ветвления.;;;;;;;;;;;;;;;;;;;;;;
SQL.;Функции ранжирования что это и какие существует?;       Ранжирующие функции возвращают ранжирующее значение для каждой строки в секции. В зависимости от используемой функции значения некоторых строк могут совпадать. Ранжирующие функции являются недетерминированными.  Transact-SQL содержит следующие ранжирующие функции:      RANK     NTILE     DENSE_RANK     ROW_NUMBER ;;;;;;;;;;;;;;;;;;;;;;
SQL.;Может ли значение в столбце(ах), на который наложено ограничение foreign key, равняться null?;Может, если на данный столбец не наложено ограничение not null, пример: при построении таблицы дерева файловой системы, где столбец foreign key - ссылка на эту же самую таблицу, на кортеж с информацией о родительской директории, тогда для корневой директории файловой системы в столбце родительской директории будет - null.;;;;;;;;;;;;;;;;;;;;;;
SQL.;Назовите основные свойства транзакции.;ACID - atomicity (атомарность), consistency (непротиворечивость), isolation (изолированность), durability (устойчивость).      Свойство атомарности гарантирует неделимость набора операторов, которые изменяют данные в базе данных и являются частью транзакции. Это означает, что или выполняются все изменения данных в транзакции, или в случае любой ошибки все уже выполненные изменения отменяются.     Согласованность гарантирует, что транзакция не даст возможности базе данных содержать несогласованные данные. Другими словами, трансформация данных в рамках одной транзакции переводит базу данных из одного согласованного состояния в другое согласованное состояние.     Свойство изолированности разделяет все одновременно выполняющиеся транзакции. Другими словами, ни одна активная транзакция не может видеть изменения данных, выполненные в параллельной, но не завершенной транзакции. Это означает, что для обеспечения изолированности для некоторых транзакций может быть выполнен откат.     Устойчивость - после своего завершения транзакция сохраняется в системе, которую ничто не может вернуть в исходное (до начала транзакции) состояние, т.е. происходит фиксация транзакции, означающая, что ее действие постоянно даже при сбое системы.  ;;;;;;;;;;;;;;;;;;;;;;
SQL.;Как удалить повторяющиеся строки с использованием ключевого слова Distinct?;SELECT DISTINCT columnsName FROM tableName  где: columnsName - одно или несколько реальных имен столбцов,перечисленных через запятую  tableName - имя той таблицы, из которой выбираются эти столбцы. Если в предложение SELECT DISTINCT включить более одного столбца, то в результате уникальность любой строки будет определяться уникальностью соответствующей комбинации всех значений столбцов, включенных в предложение, на этой самой строке среди аналогичных комбинаций, соответствующих другим строкам.  Несмотря на то что значения null никогда не бывают равны друг другу (поскольку считаются неизвестными), предложение DISTINCT , напротив, считает их дубликатами. Поэтому команда SELECT DISTINCT вернет только одно значение null, независимо от того, сколько значений null она встретит.  ;;;;;;;;;;;;;;;;;;;;;;
SQL.;Когда полное сканирование таблицы выгоднее доступа по индексу? Опишите вкратце общие принципы, как оптимизатор выбирает производить ли полное сканирование таблицы или доступ по индексу.;Полное сканирование производится многоблочным чтением. Сканирование по индексу - одноблочным. Также, при доступе по индексу сначала идет сканирование самого индекса, а затем чтение блоков из таблицы. Число блоков, которые надо при этом прочитать из таблицы зависит от фактора кластеризации. Если суммарная стоимость всех необходимых одноблочных чтений больше стоимости полного сканирования многоблочным чтением, то полное сканирование выгоднее и оно выбирается оптимизатором. Таким образом, полное сканирование выбирается при слабой селективности предикатов зароса и/или слабой кластеризации данных, либо в случае очень маленьких таблиц.      Им;;;;;;;;;;;;;;;;;;;;;;
SQL.;Имеет ли смысл индексировать поля таблицы, имеющих тип boolean или подобные им - с небольшим количеством возможных значений?;Индекс по логическим полям имеет смысл, только в случае, если значения ИСТИНА и ЛОЖЬ распределены примерно равномерно по таблице. Предельный случай - две трети и одна треть.;;;;;;;;;;;;;;;;;;;;;;
SQL.;Что такое агрегатная функция? Приведите примеры агрегатных функций в SQL.;Агрегатная функция - это функция, которая возвращает одиночное значение на основании множества записей. Вот список некоторых агрегатных функций SQL:      COUNT(*) - Возвращает количество строк источника записей     COUNT - Возвращает количество значений в указанном столбце     SUM - Возвращает сумму значений в указанном столбце     AVG - Возвращает среднее значение в указанном столбце     MIN - Возвращает минимальное значение в указанном столбце     MAX - Возвращает максимальное значение в указанном столбце ;;;;;;;;;;;;;;;;;;;;;;
SQL.;Дайте определение третьей нормальной форме БД.;Определение третьей нормальной форме БД.      Любое поле любой записи хранит только одно значение. (1NF) Например, если в поле хранится список идентификаторов, разделённых запятыми, то это нарушение данного определения.     Выполняется условие 1NF и любое неключевое поле полностью зависит от ключа. (2NF) Например, у нас есть запись с полями (Идентификатор, Название CD-Диска, Название группы), где ключом является поле «Идентификатор». При этом, очевидно, что поле «Название группы» зависит не только от «Идентификатора» но и от поля «Название CD-Диска». Поэтому такая БД не находится во второй нормальной форме.     Выполняется условие 2NF и нет неключевых полей зависящих от значения других неключевых полей. Например у нас в записи хранятся код региона и его название. Понятно, что название региона зависит от кода, и наоборот, поэтому такая БД не будет находиться в третьей нормальной форме.   ;;;;;;;;;;;;;;;;;;;;;;
SQL.;Что такое денормализация БД? Для чего она нужна?;Денормализация - это процесс осознанного приведения базы данных к виду, в котором она не будет соответствовать правилам нормализации. Обычно это необходимо для повышения производительности и скорости извлечения данных, за счет увеличения избыточности данных. Если приложению необходимо часто выполнять выборки, которые занимают слишком много времени (например, объединение данных из множества таблиц), то следует рассмотреть возможность проведения денормализации. Возможное решение следующее: вынести результаты выборки в отдельную таблицу. Это позволит увеличить скорость выполнения запросов, но также означает появление необходимости в постоянном обслуживании этой новой таблицы. Прежде чем приступать к денормализации, необходимо убедится, что ожидаемые результаты оправдывают издержки, с которыми придется столкнуться.  ;;;;;;;;;;;;;;;;;;;;;;
SQL.;Что такое триггер?;       Триггер - это SQL процедура, которая срабатывает при каком-нибудь событии (INSERT, DELETE или UPDATE). Триггеры хранятся и управляются СУБД. Триггеры используются для поддержания ссылочной целостности данных в одинаковый манер реагируя на события изменения этих данных. Триггер не может быть вызван или выполнен вручную, СУБД автоматически вызывает его после модификации данных в соответствующей таблице. В этом и есть его отличие от хранимых процедур, которые нужно выполнять вручную вызовом CALL. Также триггер может вызывать другие процедуры. Триггер также может содержать вызовы INSERT, DELETE и UPDATE внутри себя, таким образом вызывая другой триггер. Такие триггеры называются вложенными (nested).  ;;;;;;;;;;;;;;;;;;;;;;
SQL.;Что такое курсоры в базах данных?;"Курсор - это объект базы данных, который позволяет приложениям работать с записями ""по-одной"", а не сразу с множеством, как это делается в обычных SQL командах. Порядок работы с курсором такой:      Определить курсор (DECLARE)     Открыть курсор (OPEN)     Получить запись из курсора (FETCH)     Обработать запись     Закрыть курсор (CLOSE)   ";;;;;;;;;;;;;;;;;;;;;;
SQL.;Какие компромиссы предлагает использование индексов?;Некоторые из них:      Более быстрые выборки, но более медленные изменения. (При изменениях тратиться время на перестройку индекса).     Для хранения индексов необходимо дополнительное дисковое пространство.   ;;;;;;;;;;;;;;;;;;;;;;
SQL.;Что делает SQL операция MERGE?;Операция MERGE официально появилась в стандарте ANSI SQL:2008. Она позволяет одновременно вставлять или изменять записи таблицы согласно критерию. При выполнении критерия строки изменяются, иначе - вставляются. Ее можно заменить последовательным вызовом INSERT и UPDATE. В некоторых базах данных похожая операция называется UPSERT.  ;;;;;;;;;;;;;;;;;;;;;;
SQL.;В чем различие между выражениями HAVING и WHERE?;WHERE - это ограничивающее выражение. Оно выполняется до того, как будет получен результат операции. HAVING - фильтрующее выражение. Оно применяется к результату операции и выполняется уже после того как этот результат будет получен, в отличии от where. Выражения WHERE используются вместе с операциями SELECT, UPDATE, DELETE, в то время как HAVING только с SELECT и предложением GROUP BY. Например, WHERE нельзя использовать таким образом: В данном случае больше подходит HAVING: То есть, использовать WHERE в запросах с агрегатными функциями нельзя, для этого и был введен HAVING.  ;;;;;;;;;;;;;;;;;;;;;;
SQL.;Что такое целостность данных? Объясните, что такое ограничения.;Целостность данных - важное свойство SQL. При правильном использовании оно обеспечивает корректность и валидность хранимых данных в любой момент времени. Также, с их помощью можно обнаруживать ошибки в приложениях, которые тяжело найти другими способами. Целостность данных поддерживается с помощью ограничений. В SQL стандарта ANSI есть 4 основных ограничения: PRIMARY KEY, CHECK, UNIQUE и FOREIGN KEY. Они не являются обязательными для таблицы.      PRIMARY KEY - набор полей (1 или более), значения которых образуют уникальную комбинацию и используются для однозначной идентификации записи в таблице. Для таблицы может быть создано только одно такое ограничение. Данное ограничение используется для обеспечения целостности сущности, которая описана таблицей.     CHECK используется для ограничения множества значений, которые могут быть помещены в данный столбец. Это ограничение используется для обеспечения целостности предметной области, которую описывают таблицы в базе.     Ограничение UNIQUE обеспечивает отсутствие дубликатов в столбце или наборе столбцов. Разница между PRIMARY KEY и UNIQUE описана в primary и unique ключи     Ограничение FOREIGN KEY защищает от действий, которые могут нарушить связи между таблицами. FOREIGN KEY в одной таблице указывает на PRIMARY KEY в другой. Поэтому данное ограничение нацелено на то, чтобы не было записей FOREIGN KEY, которым не отвечают записи PRIMARY KEY. Таким образом, FOREIGN KEY поддерживает ссылочную целостность данных.   ;;;;;;;;;;;;;;;;;;;;;;
SQL.;В чем отличие между кластерными индексами и некластерными?;Некластерные индексы создаются СУБД по умолчанию. Данные физически расположены в произвольном порядке, но логически упорядочены согласно индексу. Такой тип индексов подходит для таблиц, где часто изменяются значения. При кластерном индексировании данные физически упорядочены, что серьезно повышает скорость выборок данных (но только в случае последовательного доступа к данным). Для одной таблицы может быть создан только один кластерный индекс.  ;;;;;;;;;;;;;;;;;;;;;;
SQL.;Какие отличия между ограничениями primary и unique?;Ограничения primary и unique призваны обеспечить уникальность значений столбца, на котором они определены. Но по умолчанию ограничение primary создает кластерный индекс на столбце, а unique - некластерный. Другим отличием является то, что primary не разрешает NULL записей, в то время как unique разрешает только одну NULL запись.  ;;;;;;;;;;;;;;;;;;;;;;
MongoDB;Что такое NoSQL?;NoSQL (Not only SQL) - это ряд технологий, подходов, проектов направленных на реализацию моделей баз данных, имеющих существенные отличия от традиционных СУБД, работающих с языком SQL. Концепция NoSQL не отрицает SQL, она лишь стремится решить проблемы и вопросы, с которыми не достаточно хорошо справляется РСУБД. Чаще всего данные в NoSQL решении представляются в виде хеш-таблиц, деревьев, документов и пр.;;;;;;;;;;;;;;;;;;;;;;
MongoDB;Какие есть типы хранилищ данных в NoSQL?  ;" В зависимости от модели данных и подходов к распределённости и репликации можно выделить четыре типа хранилищ:      ""ключ-значение"" (key-value store)     документно-ориентированные (document store)     хранилища семейств колонок (column database)     графовые базы данных (graph database). ";;;;;;;;;;;;;;;;;;;;;;
MongoDB;Что такое MongoDB?;MongoDb - это документо-ориентированная база данных, в отличие от традиционных реляционных баз данных, таких как MySQL или PostgreSQL не использует табличный способ представления со связями через внешние ключи, основанная на принципе хранении документов в BSON(Binary JSON) формате. Т.е. каждая запись это документ, без жестко заданной схемы, который может содержать вложенные документы. ;;;;;;;;;;;;;;;;;;;;;;
MongoDB;На каком языке написана MongoDB?  ;MongoDB написана и реализована на С++;;;;;;;;;;;;;;;;;;;;;;
MongoDB;Какие языки программирования можно использовать с MongoDB?; Клиентские драйверы MongoDB поддерживают все популярные языки программирования, так что выбор языка не является проблемой. Вы можете использовать любой язык, какой хотите.;;;;;;;;;;;;;;;;;;;;;;
MongoDB;Использует ли таблицы для хранения данных, база данных MongoDB?;" Нет. Для хранения данных вместо таблиц, MongoDB использует ""Коллекции"" (collections).";;;;;;;;;;;;;;;;;;;;;;
MongoDB;Какие преимущества MongoDB?;" Основные возможности MongoDB:      Документо-ориентированное хранилище (простая и мощная JSON-подобная схема данных)     Достаточно гибкий язык для формирования запросов     Динамические запросы     Полная поддержка индексов     Профилирование запросов     Быстрые обновления ""на месте""     Эффективное хранение двоичных данных больших объёмов, напр., фото и видео     Журналирование операций, модифицирующих данные в БД     Поддержка отказоустойчивости и масштабируемости: асинхронная репликация, набор реплик и шардинг     Может работать в соответствии с парадигмой MapReduce     Имеет распределенный доступ к данным, расположенных на нескольких серверах   ";;;;;;;;;;;;;;;;;;;;;;
MongoDB;Какие недостатки MongoDB?  ;"       Недостатки:      Отсутствует оператор ""join"". Обычно данные могут быть организованы более денормализованным способом, но на разработчиков ложится дополнительная нагрузка по обеспечению непротиворечивости данных.     Нет такого понятия, как ""транзакция"". Атомарность гарантируется только на уровне целого документа, т.е. частичное обновление документа произойти не может.     Отсутствует понятие ""изоляции"". Любые данные, которые считываются одним клиентом, могут параллельно изменяться другим клиентом.     Менее чем более стабильна, не рекомендовано использовать в биллинге     Требовательна к ресурсам - память и место на диске ";;;;;;;;;;;;;;;;;;;;;;
MongoDB;Что такое пространство имен в MongoDB?; Пространство имен в MongoDB это конкатенация имени базы данных и названия коллекции. Для например school.students, где school - имя базы данных и students - название коллекции.;;;;;;;;;;;;;;;;;;;;;;
MongoDB;Что такое репликация?; Репликация - это процесс синхронизации данных между несколькими серверами. Позволяет добиться большей масштабируемости, и повысить доступность и сохранность данных. Репликация также позволяет восстанавливать даные после сбоя аппаратного обеспечения. С помощью дополнительных копий данных, вы можете выделить один сервер для аварийного восстановления, отчетности или резервного копирования. MongoDB поддерживает 2 формы репликации:      реплисеты(Replica Sets )     ведущий-ведомый(Master-Slave). ;;;;;;;;;;;;;;;;;;;;;;
MongoDB;Поддерживает ли MongoDB ограничения внешнего ключа(foreign key)?  ;Нет;;;;;;;;;;;;;;;;;;;;;;
MongoDB;Как мы можем достичь primary key - foreign key отношения в MongoDB?;"По умолчанию MongoDB не поддерживает primary key - foreign key отношения. Тем не менее, мы можем достичь этой концепции путем встраивания одного документа внутри другого. Для например документ ""адрес"" может быть встроен внутри документа ""клиент"".";;;;;;;;;;;;;;;;;;;;;;
MongoDB;Объясните структуру ObjectID в MongoDB.; ObjectID ето 12-байт типа BSON, имеющий следующую структуру:.      Первые 4 байта, представляющие секунды с эпохи Unix      Следующие 3 байта являются идентификатором машины     Следующие 2 байта являются идентификатором процесса     Последние 3 байта ето случайная величина счетчика:   MongoDB использует ObjectID как значение по умолчанию поля _id каждого документа, который генерируется во время создания любого документа. ObjectID делает все поля _id уникальными. Для создания нового ObjectID используется следующий код: NewObjectId = ObjectId();;;;;;;;;;;;;;;;;;;;;;
MongoDB;Если удалить документ из базыданных, удалится ли он с диска?; Да. Удаление документа из базы данных приведет к его удалению с диска.;;;;;;;;;;;;;;;;;;;;;;
MongoDB;Что такое индексы в MongoDB?; Индексы - ето специальная структура данных, которая хранит небольшую часть набора данных. Индекс сохраняет значение конкретного поля или набора полей, упорядоченых по величине поля, как указано в индексе.  Индексы поддерживать эффективное выполнение запросов. Без индексов, MongoDB должна сканировать каждый документ коллекции, чтобы выбрать те документы, которые соответствуют оператору запроса. Это сканирование крайне неэффективно и требует от  MongoDB обработки большого объема данных. Индексы в MongoDB работают схожим образом с индексами в реляционных базах данных: они ускоряют выборку и сортировку данных. Индексы создаются с помощью ensureIndex.  ;;;;;;;;;;;;;;;;;;;;;;
MongoDB;Сколько индексов создается по умолчанию в MongoDB для новой коллекции?  ;По умолчанию, MongoDB создает только _id для каждой коллекции.;;;;;;;;;;;;;;;;;;;;;;
MongoDB;Что такое скрытый запрос в MongoDB?;В соответствии с официальной документации MongoDB, скрытый запрос ето запрос в котором:      все поля в запросе являются частью индекса используемого в запросе     все поля в запросе возвращаются в том же индексе ;;;;;;;;;;;;;;;;;;;;;;
MongoDB;Поддерживает ли MongoDB поиск текста?;Да. MongoDB поддерживает создание текстовых индексов для поддержки поиска текста внутри строки. Эта функция, была введена в версии 2.6.;;;;;;;;;;;;;;;;;;;;;;
MongoDB;Какая команда позволяет получить все индексы определенной коллекции?;db.collections.getIndexes();;;;;;;;;;;;;;;;;;;;;;
MongoDB;Что такое Шардинг в MongoDB?;       Шардинг - это подход к масштабируемости, когда отдельные части данных хранятся на разных серверах. Шардинг решает проблему горизонтального масштабирования. Примитивный пример: хранить данные пользователей, чьё имя начинается на буквы A-M на одном сервере, а остальных - на другом.;;;;;;;;;;;;;;;;;;;;;;
MongoDB;По умолчанию, MongoDB пишет и читает данные из primary и secondary наборов реплик. Правда ето или ложь?; Ложь. MongoDB записывает данные только в primary набор реплик.;;;;;;;;;;;;;;;;;;;;;;
MongoDB;Почему MongoDB не является предпочтительным решением для 32-битных систем?;При работе с 32-разрядной сборкой MongoDB, общий размер хранилища для сервера, включая данные и индексы, составляет 2 гигабайта. По этой причине, не рекомендуеться развертывать MongoDB для продакшина на 32-разрядных машинах. Если вы используете 64-разрядную сборку MongoDB, практически нет никаких ограничений на размер хранилища.;;;;;;;;;;;;;;;;;;;;;;
MongoDB;Какая команда,позволяет проверить, являетесь ли вы на главном сервере или нет?;db.isMaster();;;;;;;;;;;;;;;;;;;;;;
MongoDB;Что такое GridFS?; GridFS - это спецификация, определённая в базе данных MongoDB для хранения и извлечения файлов, размер которых превышает 16 Мб. Такое ограничение размера обусловлено использованием в MongoDB формата BSON. Согласно спецификации GridFS файл разбивается на несколько фрагментов (англ. chunks), каждый из которых не может быть больше, чем 255 Кб. Каждый такой фрагмент хранится как отдельный файл и к нему может быть осуществлён доступ как к отдельному файлу. Для обеспечения корректной сборки разбитого на фрагменты файла GridFS хранит коллекцию метаданных - отдельных файлов, содержащих информацию о хранящихся в файловой системе документах.  ;;;;;;;;;;;;;;;;;;;;;;
MongoDB;Что такое Map/Reduce?; Map/Reduce - это подход к обработке больших объемов данных, который состоит из двух фаз: Map - предварительная обработка входных данных и Reduce - обработка тем или иным способом выборки, полученной на стадии Map. Map/Reduce не является свойством исключительно NoSQL-решений. Аналогичным образом можно работать с большими объемами данных и в РСУБД. Но большинство NoSQL-систем (за исключением, может быть, самых простых key-value хранилищ) реализуют Map/Reduce в том или ином виде. Map/Reduce имеет два серьёзных преимущества по сравнению с традиционными решениями. Первое и самое главное преимущество - это производительность. Теоретически MapReduce может быть распараллелен, что позволяет обрабатывать огромные массивы данных на множестве ядер/процессоров/машин. Это пока не является преимуществом MongoDB. Вторым преимуществом MapReduce является возможность описывать обработку данных нормальным кодом. По сравнению с тем, что можно сделать с помощью SQL, возможности кода внутри MapReduce намного богаче и позволяют расширить рамки возможного даже без использования специализированных решений.;;;;;;;;;;;;;;;;;;;;;;
MongoDB;Как создать/удалить коллекцию в MongoDB?; db.createCollection(name,options) - для создания коллекции в MongoDB db.collection.drop() - для удаления коллекции в MongoDB;;;;;;;;;;;;;;;;;;;;;;
MongoDB;Какова роль профайлера в MongoDB?; Профайлера базы данных MongoDB показывает рабочие характеристики каждой операции с базой данных. Для примера вы можете найти запросы с помощью профилировщика которие на самом деле медленнее, чем они должны быть. Профайлер MongoDB можно включить с помощью следующего вызова: db.setProfilingLevel(2) чтобы выключить профайлер, нужно повторно вызвать setProfileLevel, только передав 0 в качестве аргумента.  ;;;;;;;;;;;;;;;;;;;;;;
MongoDB;Какая команда позволяет вставить документ?; database.collection.insert(document) - для вставки документа в колекцию.;;;;;;;;;;;;;;;;;;;;;;
MongoDB;Приведите пример использования индекса в MongoDB.;db.COOLECTION_NAME.ensureIndex({ KEY : 1 });;;;;;;;;;;;;;;;;;;;;;
MongoDB;Какой метод вернёт список всех документов в колекции? ;db.unicorns.find();;;;;;;;;;;;;;;;;;;;;;
MongoDB;Что такое селекторы запросов в MongoDB?;Селектор - это JSON-объект, в простейшем случае это может быть даже {}, что означает выборку всех документов (аналогичным образом работает null). Селектор запросов MongoDB аналогичен предложению where SQL-запроса. Как таковой он используется для поиска, подсчёта, обновления и удаления документов из коллекций.;;;;;;;;;;;;;;;;;;;;;;
MongoDB;Что вы знаете об обновлении/вставке в MongoDB?; Один из приятных сюрпризов операции обновления - это возможность обновления/вставки (upsert от update - обновить и insert - вставить) Обновление/вставка обновляет документ, если он найден, или создаёт новый - если не найден. Обновление/вставка - полезная вещь в некоторых случаях когда столкнётесь с подобным, сразу поймёте. Чтобы разрешить вставку при обновлении, установите третий параметр в true. Пример из жизни - счётчик посещений для веб-сайта. Если мы хотим в реальном времени видеть количество посещений страницы, мы должны посмотреть, существует ли запись, и - в зависимости от результата - выполнить update либо insert.;;;;;;;;;;;;;;;;;;;;;;
MongoDB;Что вы знаете об  условных оператораторах в MongoDB?  ;В MongoDB в запросах можно использовать условные:      $gt - больше чем     $lt - меньше чем     $gte  - больше или равно     $lte - меньше или равно     $ne  - извлекает все документы, не соответствующие некоторому условию     $or - определяет набор пар ключ-значение, которые должны иметься в документе. И если документ имеет хоть одну такую пару ключ-значение, то он соответствует данному запросу и извлекается из бд     $size - используется для нахождения документов, в которых массивы имеют число элементов, равным значению $size     $exists - позволяет извлечь только те документы, в которых определенный ключ присутствует или отсутствует     $regex - задает регулярное выражение, которому должно соответствовать значение поля  Поиск по массивам и операторы $in, $nin, $all      $in - определяет массив возможных выражений и ищет те ключи, значение которых имеется в массиве     $nin - определяет массив возможных выражений и ищет те ключи, значение которых отсутствует в этом массиве     $all - похож на $in: он также определяет массив возможных выражений, но требует, чтобы документы имели весь определяемый набор выражений ;;;;;;;;;;;;;;;;;;;;;;
MongoDB;Как удалить документ в MongoDB?;"Для удаления документов в MongoDB предусмотрен метод remove: db.users.remove({name: ""Tom""})";;;;;;;;;;;;;;;;;;;;;;
Тестирование. JUNIT.;Чем стаб (stub) отличается от мока (mock)?;"Stub - объекты, которые предоставляют заранее заготовленные ответы на вызовы во время выполнения теста и обычно не отвечающие ни на какие другие вызовы, которые не требуются в тесте. Также могут запоминать какую-то дополнительную информацию о количестве вызовов, параметрах и возвращать их потом тесту для проверки. Используется для ""затычки"" сервисов, методов, классов и т.д. Абсолютно все равно что они вернут при работе или сколько раз произойдет вызов. Mock - объекты, которые заменяют реальный объект в условиях теста и позволяют проверять вызовы своих членов как часть системы или unit-теста. Содержат заранее запрограммированные ожидания вызовов, которые они ожидают получить. Применяются в основном для т.н. interaction (behavioral) testing. Используется для подмены результатов вызова функций в юнит тестах (важен результат), для учета количества вызовов функций и просто ожидания их вызовов. Используется в области Assert юнит теста. ";;;;;;;;;;;;;;;;;;;;;;
Тестирование. JUNIT.;Что такое unit testing?;Модульное тестирование или unit testing - процесс проверки на корректность функционирования отдельных частей исходного кода программы путем запуска тестов в искусственной среде.;;;;;;;;;;;;;;;;;;;;;;
Тестирование. JUNIT.;Что такое Фикстуры?;Фикстура (Fixture) - состояние среды тестирования, которое требуется для успешного выполнения тестового метода. Может быть представлено набором каких-либо объектов, состоянием базы данных, наличием определенных файлов, соединений и проч.;;;;;;;;;;;;;;;;;;;;;;
Тестирование. JUNIT.;Какие есть аннотации фикстур?;Предусмотрено четыре аннотации фикстур - две для фикстур уровня класса и две для фикстур уровня метода.      @BeforeClass - запускается только один раз при запуске теста.     @Before - запускается перед каждым тестовым методом.     @After - запускается после каждого метода.     @AfterClass - запускается после того, как отработали все тестовые методы. ;;;;;;;;;;;;;;;;;;;;;;
Тестирование. JUNIT.;Для чего нужна Аннотация @Ignore?;Аннотация @Ignore заставляет инфраструктуру тестирования проигнорировать данный тестовый метод. Аннотация предусматривает наличие комментария о причине игнорирования теста, полезного при следующем к нему обращении.;;;;;;;;;;;;;;;;;;;;;;
Тестирование. JUNIT.;Что такое интеграционные тесты?; Интеграционные тесты - это тесты, проверяющие работоспособность двух или более модулей системы, но в совокупности - то есть нескольких объектов как единого блока.;;;;;;;;;;;;;;;;;;;;;;
Log4j.;Из чего состоит логгер?; Любой регистратор событий состоит из трех элементов:      cобственно регистрирующего - logger      направляющего вывод - appender      форматирующего вывод - layout.  ;;;;;;;;;;;;;;;;;;;;;;
Log4j.;Какие есть уровни сообщении в log4j?; Приоритетов может быть ШЕСТЬ (log4j1.2.*):      FATAL - произошла фатальная ошибка - у этого сообщения наивысший приоритет     ERROR - в программе произошла ошибка     WARN - предупреждение в программе что-то не так     INFO - информация.     DEBUG - детальная информация для отладки     TRACE– трассировка всех сообщений в указанный аппендер  OFF< TRACE< DEBUG< INFO< WARN< ERROR< FATAL< ALL;;;;;;;;;;;;;;;;;;;;;;
Log4j.;Что такое Appender?; Вывод регистратора может быть направлен в различные места назначения: файл, консоль и т. д. Каждому из них соответствует класс, реализующий интерфейс org.apache.log4j.Appender. Кроме того, вывод в базу данных можно произвести с помощью класса JDBCAppender, в журнал событий ОС - NTEventLogAppender, на SMTP-сервер - SMTPAppender. Если логгер - это та точка, откуда уходят сообщения в коде, то аппендер - это та точка, куда они приходят в конечном итоге. Например, файл или консоль. Список таких точек, поддерживаемых Log4J:      консоль      файлы (несколько различных типов)      JDBC      темы (topics) JMS      NT Event Log      SMTP      Сокет      Syslog      Telnet      любой java.io.Writer или java.io.OutputStream.   ;;;;;;;;;;;;;;;;;;;;;;
Log4j.;Какие основные аппендеры Log4j?; Основными аппендерами, использующимися наиболее широко, являются файловые аппендеры. Их есть несколько типов:      org.apache.log4j.FileAppender     org.apache.log4j.RollingFileAppender     org.apache.log4j.DailyRollingFileAppender  ;;;;;;;;;;;;;;;;;;;;;;
Log4j.;Что такое Layout?; Вывод регистратора может иметь различный формат. Каждый формат представлен классом, производным от Layout. Все методы класса Layout предназначены только для создания подклассов.      org.apache.log4j.SimpleLayout - наиболее простой вариант. На выходе читается уровень вывода и сообщение.     org.apache.log4j.HTMLLayout - данный компоновщик форматирует сообщения в виде HTML-страницы.     org.apache.log4j.xml.XMLLayout - формирует сообщения в виде XML.     org.apache.log4j.PatternLayout и org.apache.log4j.EnhancedPatternLayout используют шаблонную строку для форматирования выводимого сообщения.  ;;;;;;;;;;;;;;;;;;;;;;
UML.;Что такое UML?;Унифицированный язык моделирования (Unified Modeling Language) - графический язык визуализации, специфицирования, конструирования и документирования программного обеспечения.;;;;;;;;;;;;;;;;;;;;;;
UML.;Что такое Нотации и метамодель в UML?; Нотация - совокупность графических объектов, которые используются в моделях. В качестве примера на диаграмме показано, как в нотации диаграммы класса определяют понятия и предметы типа «класс», «ассоциацция»,«множественность» и т. д. Метамодель - диаграмма, определяющая нотацию. Метамодель помогает понять, что такое хорошо организованная, т. е. синтаксически правильная, модель. ;;;;;;;;;;;;;;;;;;;;;;
UML.;Какие есть типы диаграмм?;" Структурные диаграммы:      диаграммы классов (class diagrams) предназначены для моделирования структуры объектно-ориентированных приложений - классов, их атрибутов и заголовков методов, наследования, а также связей классов друг с другом      диаграммы компонент (component diagrams) используются при моделировании компонентной структуры распределенных приложений  внутри каждая компонента может быть реализована с помощью множества классов      диаграммы объектов (object diagrams) применяются для моделирования фрагментов работающей системы, отображая реально существующие в runtime экземпляры классов и значения их атрибутов      диаграммы композитных структур (composite structure diagrams) используются для моделирования составных структурных элементов моделей - коопераций, композитных компонент и т.д.      диаграммы развертывания (deployment diagrams) предназначены для моделирования аппаратной части системы, с которой ПО непосредственно связано (размещено или взаимодействует)      диаграммы пакетов (package diagrams) служат для разбиения объемных моделей на составные части, а также (традиционно) для группировки классов моделируемого ПО, когда их слишком много.  Поведенческие диаграммы:      диаграммы активностей (activity diagrams) используются для спецификации бизнес-процессов, которые должно автоматизировать разрабатываемое ПО, а также для задания сложных алгоритмов      диаграммы случаев использования(use case diagrams) предназначены для ""вытягивания"" требований из пользователей, заказчика и экспертов предметной области      диаграммы конечных автоматов (state machine diagrams) применяются для задания поведения реактивных систем      диаграммы взаимодействий (interaction diagrams):     диаграммы последовательностей (sequence diagrams) используются для моделирования временных аспектов внутренних и внешних протоколов ПО      диаграммы схем взаимодействия (interaction overview diagrams) служат для организации иерархии диаграмм последовательностей      диаграммы коммуникаций (communication diagrams) являются аналогом диаграмм последовательностей, но по-другому изображаются (в привычной, графовой, манере)      временные диаграммы (timing diagrams) являются разновидностью диаграмм последовательностей и позволяют в наглядной форме показывать внутреннюю динамику взаимодействия некоторого набора компонент системы.  Основные понятия. К основным понятиям UML относятся:      сущности - абстракции, являющиеся основными элементами модели      отношения - связывают различные сущности      диаграммы - группируют представляющие интерес совокупности сущностей.   ";;;;;;;;;;;;;;;;;;;;;;
UML.;Какие отношение обобщения реализуется при наследовании классов.; Реализацией (Realization) называется отношение между классификаторами (классами, интерфейсами), при котором один описывает контракт (интерфейс сущности), а другой гарантирует его выполнение. Ассоциация (Association) показывает, что объект одного класса связан с объектом другого класса и отражает некоторое отношение между ними. Агрегация - ассоциация, моделирующая взаимосвязь «часть/целое» между классами, которые в то же время могут быть равноправными. Оба класса при этом находятся на одном концептуальном уровне, и ни один не является более важным, чем другой. ;;;;;;;;;;;;;;;;;;;;;;
XML.;Что такое XML?;XML(eXtensible Markup Language - расширяемый язык разметки) - текстовый формат, предназначенный для хранения структурированных данных (взамен существующих файлов баз данных), для обмена информацией между программами, а также для создания на его основе более специализированных языков разметки (например, XHTML).;;;;;;;;;;;;;;;;;;;;;;
XML.;Как определяется корректность XML-документа?;Корректность XML-документа определяют следующие два компонента:      синтаксическая корректность (well-formed) - то есть соблюдение всех синтаксических правил XML      действительность (valid) - то есть данные соответствуют некоторому набору правил, определенных пользователем  правила определяют структуру и формат данных в XML. Валидность XML-документа определяется наличием DTD или XML-схемы (XSD) и соблюдением правил, которые там приведены.   ;;;;;;;;;;;;;;;;;;;;;;
XML.;Чем well-formed XML отличается от valid?; Отличие:      well-formed XML - тот, который пропускается парсером     valid XML - тот, который пропускается парсером И валидатором   ;;;;;;;;;;;;;;;;;;;;;;
XML.;Что такое пространство имен?; Пространство имен (namespace) - введено для разделения наборов элементов с соответствующими правилами, описанными схемой. Пространство имен объявляется с помощью атрибута xmlns и префикса, который используется для элементов из данного пространства.  ;;;;;;;;;;;;;;;;;;;;;;
XML.;Что такое простые типы в XSD?; Элементы, которые не имеют атрибутов и дочерних элементов, называются простыми и должны иметь простой тип данных. Существуют стандартные простые типы, например string (представляет строковое значение), boolean (логическое значение), integer (целое значение), float (значение с плавающей точкой), ID (уникальный идентификатор), gYear (год) и др.;;;;;;;;;;;;;;;;;;;;;;
XML.;Что такое сложныетипы в XSD?;Элементы, содержащие в себе атрибуты и/или дочерние элементы, называются сложными. Сложные элементы создаются с помощью элемента complexType. Так же, как и в простом типе атрибут name задает имя типа.;;;;;;;;;;;;;;;;;;;;;;
XML.;Какие элементы и атрибуты XSD Вы знаете? Кратко опишите их.;"Ниже приведён список  элементов и атрибутов ХСД:      schema - корневой элемент любой схемы XML. Может содержать несколько атрибутов, например версию схемы.     xmlns - каждый элемент схемы имеет стандартный префикс xs: (или xsd:, может быть использован любой префикс), который связан с пространством имен схемы XML (xmlns) путем объявления: xmlns:xsd=""http://www.w3.org/2001/XMLSchema"".     element - элементы объявляются с помощью элемента element. Например, order - это элемент, который в документе выглядит как <order id=""1234"" date=""11/08/2013"" total_amount=""93.48"">.     type - элемент может иметь простой тип, например string, decimal, long или double (type=""xs:long"") или сложный (type=""customer"").     minOccurs, maxOccurs - определяет минимальное или максимальное количество появлений типа. Может быть положительным целым числом или иметь значение unbounded, которое говорит о том, что верхней границы нет.     complexType - определяет комплексный тип, имеющий собственные элементы, подэлементы и атрибуты. Элемент типа complexType может содержать другие элементы типа complexType. Например, комплексный тип order содержит другой комплексный элемент.     sequence - элемент может содержать другие элементы, которые называются элементами-потомками. Элемент такого типа указывает, что элементы-потомки должны следовать в цепочке. Каждый потомок может встречаться от 0 до неограниченного количества раз.     attribute - комплексный тип может иметь один или несколько атрибутов, которые определены с помощью элементов типа attribute. Тип orderLine имеет два атрибута: item и quantity.     choice - используется для указания, что может присутствовать только один набор элементов.     complexContent - комплексный тип может расширять или ограничивать другой комплексный тип с помощью элемента типа complexContent.     extension - элемент такого типа расширяет существующий элемент типа simpleType или complexType.   ";;;;;;;;;;;;;;;;;;;;;;
XML.;Какие существуют XML парсеры?; Существуют SAX, DOM, JDOM парсеры. А STAX, TRAX, XPATH  - это API для работы с ними.;;;;;;;;;;;;;;;;;;;;;;
XML.;Что такое XPath?;XPath (XML Path Language) - это язык запросов  который предназначен для произвольного обращения к частям XML или XHTML документа. В документе всегда имеется корневой элемент. У элемента дерева всегда существуют предки (кроме корневого элемента, у которого предков нет) и могут существовать потомки. Каждый элемент дерева находится на определенном уровне вложенности. У элементов на одном уровне бывают предыдущие и следующие за ним элементы. Строка XPath - это фактически путь к элементу в дереве, где каждый уровень разделяется косой чертой «/». В результате обработки выражения XPath получается объект, который может быть:      набор узлов (node-set) - неупорядоченный набор узлов без дубликатов     булево значение (boolean) - true или false     число (number) - число с плавающей точкой     строка (string) - последовательность UCS символов   ;;;;;;;;;;;;;;;;;;;;;;
XML.;Что такое XQuery?;XQuery - это универсальный язык запросов к XML-данным, содержащий средства как для выборки, так и для трансформации XML-данных. XQuery синтаксически похож на SQL, его набор ключевых слов включает в себя FOR, LET, WHERE, ORDER BY или RETURN. С помощью XQuery можно выполнять сложные запросы, создавая сложные условия или упорядочивая результаты.  ;;;;;;;;;;;;;;;;;;;;;;
XML.;Каким парсером можно сделать изменения в XML структуре и сохранить в файл?; Изменение можно сделать с помощью DOM  и XPATH.;;;;;;;;;;;;;;;;;;;;;;
XML.;Кратко опишите DOM, SAX, StAX анализаторы.; DOM (Document Object Model - объектная модель документов) - платформенно-независимый программный интерфейс, позволяющий программами скриптам управлять содержимым документов HTML и XML, а также изменять их структуру и оформление. Модель DOM не накладывает ограничений на структуру документа. Любой документ известной структуры с помощью DOM может быть представлен в виде дерева узлов, каждый узел которого содержит элемент, атрибут, текстовый, графический или любой другой объект. Узлы связаны между собой отношениями родитель-потомок. SAX (Simple API for XML) базируется на модели последовательной одноразовой обработки и не создает внутренних деревьев. При прохождении по XML вызывает соответствующие методы у классов, реализующих интерфейсы, предоставляемые SAX-парсером. StAX (Streaming API for XML) не создает дерево объектов в памяти, но, в отличие от SAX-парсера, за переход от одной вершины XML к другой отвечает приложение, которое запускает разбор документа.  ;;;;;;;;;;;;;;;;;;;;;;
XML.;Когда следует использовать DOM, а когда - SAX, StAX анализаторы?; DOM-анализаторы следует использовать тогда, когда нужно знать структуру документа и может понадобиться изменять эту структуру либо использовать информацию из XML-документа несколько раз. SAX/StAX-анализаторы используются тогда, когда нужно извлечь информацию о нескольких элементах из XML-файла либо когда информация из документа нужна только один раз.  ;;;;;;;;;;;;;;;;;;;;;;
XML.;Недостатки XML DTD перед XML Schema; Недостатки XML DTD.      Отличный от XML синтаксис языка. То есть, DTD не является XML. В связи с этим могут возникать разнообразные проблемы с кодировкой и верификацией XML-документов.     Нет проверки типов данных. В XML DTD существует лишь один тип данных – строка. В связи с этим, например, если в числовом поле будет текст, документ все равно пройдет верификацию, так как XML DTD не может проверить тип данных.     Нельзя поставить в соответствие одному XML-документу больше одного DTD описания. То есть, верифицировать документ можно лишь одним DTD описанием. Если их несколько, то придется переделывать описания и совмещать все в одном файле, что очень неудобно.     Это были основные недостатки XML DTD, которые с успехом исправлены в промышленном стандарте описания XML-документов XML Schema.   ;;;;;;;;;;;;;;;;;;;;;;
XML.;XML Schema - промышленный стандарт описания XML-документов; Если быть кратким, то XML Schema делает следующее:      Описывает названия элементов и атрибутов (словарь).     Описывает взаимосвязь между элементами и атрибутами, а также их структуру (модель содержания).     Описывает типы данных.  Также хочу заметить, что на данный момент при помощи схем можно описывать практически все. То есть, схема - это универсальный способ описания грамматики данных, который может применяться не только для верификации XML-документов, но и описания баз данных и т.д. Таким образом, область применения схем на данный момент очень широкая.  ;;;;;;;;;;;;;;;;;;;;;;
XML.;Что такое XSLT?;XSLT (eXtensible Stylesheet Language Transformations) - расширяемый язык преобразования листов стилей. Язык XSLT служит транслятором, с помощью которого можно свободно модифицировать исходный текст. XLST играет решающую роль в утверждении XML в качестве универсального языка хранения и передачи данных. Область применения XSLT широка - от электронной коммерции до беспроводного Web.  ;;;;;;;;;;;;;;;;;;;;;;
XML.;Что такое маршаллизация и демаршализация?;Маршаллизация - механизм преобразования данных из java-объектов в конкретное хранилище, будь то документ XML, база данных или простой текстовый файл. Демаршаллизация - обратный процесс преобразования данных из внешних источников в структуру хранения, поддерживаемую виртуальной машиной. Проблемой остается организация взаимно однозначного соответствия информации в источнике, например, XML-документе, и экземпляре типа данных,принимающем эту информацию.  ;;;;;;;;;;;;;;;;;;;;;;
XML.;Что такое JAXP?;JAXP (Java API for XML Processing) - набор абстрактных API, упрощающих обработку XML данных с помощью программ, написанных на Java. Усиливает стандартные анализаторы SAX (Simple API for XML Parsing) и DOM (Document Object Model). JAXP также поддерживает преобразования расширяемого языка таблиц стилей (XSLT) стандарт, давая вам контроль над представлением данных и позволяя преобразовать данные в другие XML-документы или в другие форматы, такие как HTML. JAXP обеспечивает поддержку пространств имен (namespace), то есть имеется возможность работать с DTD. JAXP дает приложению возможность производить лексический разбор и модификацию документов XML независимо от конкретной реализации обработки XML. С версии 1.4, JAXP реализует API Потоковой передачи для XML (StAX) стандарт. Архитектура JAXP: ;;;;;;;;;;;;;;;;;;;;;;
XML.;Назовите основные пакеты JAXP.;JAXP (Java API for XML Processing) - набор абстрактных API, упрощающих обработку XML данных с помощью программ, написанных на Java. Усиливает стандартные анализаторы SAX (Simple API for XML Parsing) и DOM (Document Object Model). JAXP также поддерживает преобразования расширяемого языка таблиц стилей (XSLT) стандарт, давая вам контроль над представлением данных и позволяя преобразовать данные в другие XML-документы или в другие форматы, такие как HTML. JAXP обеспечивает поддержку пространств имен (namespace), то есть имеется возможность работать с DTD. JAXP дает приложению возможность производить лексический разбор и модификацию документов XML независимо от конкретной реализации обработки XML. С версии 1.4, JAXP реализует API Потоковой передачи для XML (StAX) стандарт. Архитектура JAXP: ;;;;;;;;;;;;;;;;;;;;;;
XML.;Что такое JAXB?;JAXB (Java Architecture for XML Binding) - это мост между XML и Java, Java API для маршалинга объекта в XML и восстановления (демаршалинг) объекта из XML файла. Часто используется в веб сервисах для представления объекта в виде XML схемы и передачи ее по сети. Также, такой способ передачи данных имеет свой плюс при обмене данных между системами, написанными на разных языках.;;;;;;;;;;;;;;;;;;;;;;
Android;Clean Architecture;;;;;;;;;;;;;;;;;;;;;;;
Android;Расскажите об операционной системе Android;<br>Android представляет собой операционную систему, написанную на основе ядра Linux. Ядро является главной частью ОС Linux, и практически полностью было перенесено в ОС Android, но с некоторыми модификациями, их около 250.  <br>По умолчанию система назначает каждому приложению уникальный идентификатор пользователя Linux, этот идентификатор используется только системой и для приложения не доступен. Система устанавливает полномочия для всех файлов в приложении, с тем чтобы доступ к ним был разрешен только пользователю с идентификатором, назначенным этому приложению. Android запускает процесс, когда требуется выполнить какой-либо компонент приложения, а затем завершает процесс, когда он больше не нужен либо когда системе требуется освободить память для других приложений.  <br>Над ядром операционной системы располагается Android Runtime – среда выполнения приложений. Ключевыми её составляющими являются виртуальная машина Dalvik (Art), а также набор стандартных библиотек. Каждое приложение в ОС Android запускается в собственном экземпляре виртуальной машины.;;;;;;;;;;;;;;;;;;;;;;
Android;Как работает приложение на Android?;<br>Программный код написанный разработчиком и все требуемые файлы данных и ресурсов, необходимые для корректной работы приложения компилируются в файл APK – программный пакет Android, который представляет собой файл архива с расширением .apk. В файле APK находится все, что требуется для работы Android-приложения, он позволяет установить приложение на любом устройстве под управлением системы Android.  <br>Android не использует виртуальную машину Java (JVM) для выполнения файлов классов, вместо этого, в нём используется виртуальная машина Dalvik, не являющаяся истинной JVM и не работающая с Java байт-кодом. Начиная с версии Android 4.4 начала использоваться виртуальная машина Art (Android Runtime) и в версии Android 5.0 она полностью заменила Dalvik. На схеме приведены примеры исполнения обычного java-приложения, приложения для Android, а также приложения, созданного на фреймворке Xamarin.  <br>Для платформы Android исходный java код транслируется в байт код и далее в далвик байт-код, с расширением .dex (Dalvik Executable Format), который понятен виртуальной машине Android.;;;;;;;;;;;;;;;;;;;;;;
Android;Опишите структуру Android приложения;Основные каталоги приложения: <brsrc – cодержит исходный код приложения <br>animator – содержит XML файлы, которые определяют свойства анимации <br>anim – содержит XML файлы, которые определяют анимацию преобразований <br>color – содержит XML файлы, которые определяют списки цветов <br>drawable – содержит графические файлы или XML файлы, которые компилируются в графические ресурсы <br>layout – содержит XML файлы, которые определяют расположение элементов пользовательского интерфейса <br>menu – содержит XML файлы, которые определяют все меню приложения <br>values – содержит XML файлы, которые определяют простые значения, таких ресурсов как, строки, числа, цвета. <br>mipmap – содержит изображение для лаунчера приложения <br>AndroidManifest.xml – содержит основную информацию о приложении <br>.gitignore – текстовый файл, содержащий список файлов и папок, которые будут игнорироваться системой контроля версий (VCS) и не будут загружены в удалённый репозиторий. <br>proguard-rules.pro –  конфигурационный файл с правилами для утилиты Proguard <br>setting.gradle – все модули, которые содержит проект указываются в данным файле <br>build.gradle – содержит информацию, используемую при построении проекта. Каждый модуль имеет свой файл build.gradle, который определяет подключенные библиотеки, конфигурацию построения проекта, специфичную для данного модуля <br>gradle.proeprties – файл, содержащий настройки используемые при сборке проекта <br>gradlew – используется Gradle Wrapper <br>local.properties – файл используется только Gradle, содержит путь к Android SDK <br>External Libraries – представляет собой перечень библиотек с расширением .jar, которые были подключены к нашему проекту;;;;;;;;;;;;;;;;;;;;;;
Android;Что такое Android Manifest?;Каждое приложение в обязательном порядке должно содержать файл AndroidManifest.xml, который находится в корневой папке приложения.  Файл содержит в себе всю необходимую информацию о приложении, которая требуется системе Android. Проанализировав информацию файла AndroidManifest.xml, система может выполнить необходимый код приложения.;;;;;;;;;;;;;;;;;;;;;;
Android;Назовите основные компоненты  Android приложение;<br>Основными компонентами приложения Android являются: <br>– Activity <br>– Service <br>– Broadcast receiver <br>– Content provider <br>Все компоненты Также некоторые относят к ним Intent, но на официальном сайте по разработке на Android он отсутствует.;;;;;;;;;;;;;;;;;;;;;;
Android;Что такое Activity?;Это компонент приложения, который представляет собой экран, с которым пользователи могут взаимодействовать для выполнения каких-либо действий, например набрать номер телефона, сделать фото, отправить письмо или просмотреть карту. Каждой Activity присваивается окно для прорисовки соответствующего пользовательского интерфейса.;;;;;;;;;;;;;;;;;;;;;;
Android;Опишите жизненный цикл Activity;Жизненный цикл представляет собой последовательность методов, которые вызываются в определенной последовательности во время создания/уничтожения/приостановки Activity.  <br>– onCreate()Необходимо обязательно реализовать, поскольку система вызывает его при создании Activity. Важно именно здесь вызвать метод setContentView() для определения пользовательского интерфейса. Вызывается первым, во время создания Activity. Вызывается один раз, после чего наше Activity переходит в состояние Created. В данном методе мы инициализируем интерфейс нашего Activity, а также выполняем некоторую базовую логику, которая необходима нам для корректной работы Activity, например, создаём список с какими-либо данными. Также, в качестве аргумента метода onCreate нам передаётся объект Bundle, который содержит в себе информацию, которая была предварительно сохранена, во время пересоздания Activity. <br>– onStart() Переводит нашу Activity в состояние Started, после чего Activity становится видно для пользователя. Метод может использоваться для какой-либо логики, которая взаимодействует с UI. <br>– onResume() Наше Activity переходит на передний план приложения (foreground) изменяя своё состояние на Resumed. После вызова данного метода, пользователь может взаимодействовать с Activity. В данном состоянии Activity остается до тех пор, пока не потеряет фокус, это может произойти, например, при переходе на другую Activity, либо при входящем телефонном звонке. <br>– onPause() Наше Activity теряет фокус, больше не видно для пользователя и выходит из состояния foreground. При этом Activity не уничтожается и продолжает существовать. В этом методе, например, мы можем приостановить логику связанную с GPS навигацией, чтобы минимизировать расход батареи. <br>– onStop() Состояние Activity изменяется на Stopped. Вызывается, когда Activity не видно пользователю, например, при переходе на другой экран или при сворачивании приложения, а также при подготовке к полному уничтожению нашей Activity. системой. <br>– onDestroy() Метод вызывается непосредственно перед уничтожением нашей Activity, например, после вызова метода finish(), или переходе на предыдущую Activity, путём нажатия кнопки “назад”. <br>Если активность завершается, onDestroy() – это последний метод жизненного цикла, который вызывает Activity. Если onDestroy() вызывается в результате изменения конфигурации, система немедленно создает новый экземпляр активности вызывает onCreate() в новом экземпляре и новой конфигурации. Метод onDestroy() должен освобождать все ресурсы нашей Activity.  <br>При повороте экрана система полностью пересоздаёт экземпляр Activity. Для того, что сохранить какие-либо пользовательские данные и затем восстановить их в нашей Activity, используются следующие методы:  <br>– onSaveInstanceState() Данный метод вызывается перед тем, как Activity будет уничтожена. Параметром метода является Bundle, в который мы будем складывать необходимые для сохранения данные. Рекомендуется сохранять данным способом информацию, объём которой не превышает 1 мегабайт, в случае превышения лимита мы получим ошибку TransactionTooLargeException. <br> – onRestoreInstanceState() Вызывается после метода onStart(). В данный метод мы получим наш Bundle, в котором была сохранена информация.  <br>Стоит заметить, что Bundle с сохранёнными данными мы также получаем в методе onCreate(), но данную ситуацию нужно отдельно обрабатывать, чтобы не получить NullPointerException.;;;;;;;;;;;;;;;;;;;;;;
Android;Опишите Broadcast receiver?;"<br>Приёмник широковещательных сообщений — это компонент для получения сообщений (Intent) и реагирования на них. Сообщения отправляются при помощи метода sendBroadcast(). Для обработки широковещательных сообщений необходимо создать объект IntentFilter и связать его с Broadcast receiver:  <br>IntentFilter intentFilter = new IntentFilter() <br>intentFilter.addAction(""SOME_ACTION"") <br>registerReceiver(receiver, intentFilter)  <br>Либо зарегистрировать его в манифесте при помощи тега <intent-filter>.  <br>BroadcastReceiver можно динамически зарегистрировать с помощью метода registerReceiver(), или статически создать его в тэге <receiver> в файле AndroidManifest приложения. Запускается в главном потоке приложения.  <br>BroadcastReceiver может принимать сообщения от системы, например, если телефон был установлен на зарядку либо система Android была запущена.";;;;;;;;;;;;;;;;;;;;;;
Android;Способ применения ContentProvider?;Поставщик содержимого представляет собой оболочку над базой данных приложения. Если наше приложение использует базу данных SQLite, то только оно имеет к ней доступ. Поставщик содержимого применяется лишь в тех случаях, когда необходимо использовать данные совместно с другими приложениями, работающими на устройстве. Запускается в главном потоке приложения, поэтому для обработки запросов к базе данных, необходимо использовать другой поток. Например при помощи ContentProvider мы можем получить контакты из записной книги телефона или SMS.;;;;;;;;;;;;;;;;;;;;;;
Android;Что такое ContentResolver?;ContentResolver необходим для выполнения запросов к ContentProvider другого приложения. ContentResolver включает в себя методы CRUD (create, retrieve, update, delete) для запросов и транзакций. Объекту ContentResolver необходимо передать путь URI, в котором указано, к какому объекту ContentProvider необходимо обращаться.;;;;;;;;;;;;;;;;;;;;;;
Android;Что такое Fragment?;<br>Fragment  представляет собой часть пользовательского интерфейса, который находится внутри Activity. Fragment имеет свой жизненный цикл и самостоятельно обрабатывает события ввода. В Activity одновременно может находиться несколько фрагментов. <br>Жизненный цикл фрагмента выглядит следующим образом:  <br>– onAttach()Вызывается, когда Fragment связывается со своей Activity, при этом элементы не инициализированы до конца. Можно использовать для получения ссылки для Activity и последующей работы с ней. <br>– onCreate()Вызывается при создании фрагмента. В методе можно инициализировать компоненты, которые необходимы для работы фрагмента, но не связанные с пользовательским интерфейсом. <br>– onCreateView()Фрагмент готов для инициализации пользовательского интерфейса. В данном методе необходимо указать R.layout.xxx, который содержит интерфейс фрагмента. <br>– onActivityCreated()Вызывается после полной инициализации фрагмента и его родительской Activity. С текущего момента можно обращаться к объекту Context. <br>– onStart()Переводит наш Fragment в состояние Started, после чего он становится виден для пользователя. Метод может использоваться для какой-либо логики, которая взаимодействует с UI. <br>– onResume()Fragment становится доступен для взаимодействия с пользователем. <br>– onPause()Метод вызывается когда пользователь покинул Fragment, например перешёл на другой фрагмент, либо закрыл родительскую Factivity. <br>– onStop()Fragment переходит в состояние Stopped. <br>– onDestroyView()Интерфейс Fragment уничтожается. <br>– onDestroy()Вызывается для выполнения окончательного удаления Fragment из системы. Android не гарантирует вызов данного метода.;;;;;;;;;;;;;;;;;;;;;;
Android;Как добавить Fragment к Activity?;<br>Для добавления/удаления/замены  Fragment в Activity необходимо воспользоваться классами FragmentManager и FragmentTransaction. <br>FragmentManager fragmentManager = getSupportFragmentManager() <br>FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction()  <br>Замечу, что getFragmentManager() является deprecated методом, необходимо использовать getSupportFragmentManager() из пакета android.support.v4.app.  <br>После создания необходимых объектов, необходимо вставить наш Fragment в xml разметку нашей Activity.  <br>StackOfSkills fragment = new StackOfSkills() <br>fragmentTransaction.add(R.id.fragment_container, fragment) <br>fragmentTransaction.commit();;;;;;;;;;;;;;;;;;;;;;
Android;Как гарантированно добавить Fragment к Activity?;При выполнении транзакции и добавлении Fragment к Activity можно использовать асинхронный метод commit(). При передаче данных в Fragment, например отправка Broadcast или через EventBus, нет гарантии, что Fragment получит их. Гарантированную доставку данных в Fragment можно обеспечить путём использования метода commitNow() который вызывается синхронно.;;;;;;;;;;;;;;;;;;;;;;
Android;Предназначение методов add, remove, hide, show, replace?;<br>– add()Добавляет Fragment в контейнер и отображает его UI, если метод onCreateView() возвращает не null. <br>– remove()Удаляет существующий Fragment и его UI из контейнера, к которому он был добавлен. <br>– hide()Если Fragment был добавлен к контейнеру, то метод скрывает его UI, при этом Fragment не уничтожается. Применимо только к Fragment находящемся в контейнере. <br>– show()Делает Fragment видимым, который был скрыт методом hide(). Применимо только к Fragment находящемся в контейнере. <br>– replace()Заменяет Fragment, которой был добавлен в контейнер, другим Fragment. Метод работает по принципу вызова remove() и затем add().;;;;;;;;;;;;;;;;;;;;;;
Android;Как сохранить данные в Fragment при повороте экрана (изменении конфигурации)?;<bt>Fragment содержит переменную, отвечающую за сохранение экземпляра Fragment во время изменения конфигурации. По умолчанию она равна false. Для сохранения данных, в классе Fragment необходимо установить значение в true:  <bt>@Override     <bt>public void onCreate(Bundle savedInstanceState) {         <bt>super.onCreate(savedInstanceState)         <bt>setRetainInstance(true)     <bt>};;;;;;;;;;;;;;;;;;;;;;
Android;Service;Службы (Сервисы) в Android работают как фоновые процессы и представлены классом android.app.Service. Они не имеют пользовательского интерфейса и нужны в тех случаях, когда не требуется вмешательства пользователя. Сервисы работают в фоновом режиме, выполняя сетевые запросы к веб-серверу, обрабатывая информацию, запуская уведомления и т.д. Служба может быть запущена и будет продолжать работать до тех пор, пока кто-нибудь не остановит её или пока она не остановит себя сама. Сервисы предназначены для длительного существования, в отличие от активностей. Они могут работать, постоянно перезапускаясь, выполняя постоянные задачи или выполняя задачи, требующие много времени. <br> <br> Клиентские приложения устанавливают подключение к службам и используют это подключение для взаимодействия со службой. С одной и той же службой могут связываться множество клиентских приложений. <br> <br> Android даёт службам более высокий приоритет, чем бездействующим активностям, поэтому вероятность того, что они будут завершены из-за нехватки ресурсов, заметно уменьшается. По сути, если система должна преждевременно завершить работу запущенного сервиса, он может быть настроен таким образом, чтобы запускаться повторно, как только станет доступно достаточное количество ресурсов. В крайних случаях прекращение работы сервиса (например, задержка при проигрывании музыки) будет заметно влиять на впечатления пользователя от приложения, и в подобных ситуациях приоритет сервиса может быть повышен до уровня активности, работающей на переднем плане. <br> <br> Используя сервис, можете быть уверены, что ваши приложения продолжат работать и реагировать на события, даже если они в неактивном состоянии. Для работы службам не нужен отдельный графический интерфейс, как в случае с активностями, но они по-прежнему выполняются в главном потоке хода приложения. Чтобы повысить отзывчивость вашего приложения, нужно уметь переносить трудоёмкие процессы (например, сетевые запросы) в фоновые потоки, используя классы Thread и AsyncTask. <br> <br> Службы идеально подходят для проведения постоянных или регулярных операций, а также для обработки событий даже тогда, когда активности вашего приложения невидимы, работают в пассивном режиме или закрыты. <br> <br> Сервисы запускаются, останавливаются и контролируются из различных компонентов приложения, включая другие сервисы, активности и приёмники широковещательных намерений. Если ваше приложение выполняет задачи, которые не зависят от прямого взаимодействия с пользователем, сервисы могут стать хорошим выбором. <br> <br> Запущенные сервисы всегда имеют больший приоритет, чем бездействующие или невидимые активности, поэтому менее вероятно, что их работа завершится преждевременно при распределении ресурсов. Единственная причина, почему Android может досрочно остановить Сервис, — выделение дополнительных ресурсов для компонентов, работающих на переднем плане (как правило, для активностей). Если такое случится, ваш сервис автоматически перезапустится, когда будет достаточно доступных ресурсов. <br> <br> Когда сервис напрямую взаимодействует с пользователем (например, проигрывая музыку), может понадобиться повысить его приоритет до уровня активностей, работающих на переднем плане. Это гарантия того, что сервис завершится только в крайнем случае, но при этом снижается его доступность во время выполнения, мешая управлять ресурсами, что может испортить общее впечатление от приложения. <br> <br> Приложения, которые регулярно обновляются, но очень редко или нерегулярно взаимодействуют с пользователем, можно назвать первыми кандидатами на реализацию в виде сервисов. Проигрыватели MP3 и приложения, отслеживающие спортивные результаты, — примеры программ, которые должны постоянно работать и обновляться без необходимости отображать активность.;;;;;;;;;;;;;;;;;;;;;;
Android;Что такое Service?;"<br>Service (служба) — это компонент android-приложения без видимого интерфейса, который работает в фоновом режиме. Служба обязательно должна быть объявлена в файле AndroidManifest в теге application:  <br><application <br>... <br><service <br>android:name="".ExampleService"" <br>android:enabled=""true"" <br>android:label=""StackOfSkillsService""/> <br>... <br></application>  <br>Service запускается в главном потоке приложения, поэтому если необходимо обработать в нём какую либо тяжёлую логику, необходимо создавать в нём новый поток.  <br>Service бывает нескольких типов: <br>– Foreground Service <br>– Background Service <br>– Bound Service.";;;;;;;;;;;;;;;;;;;;;;
Android;Какой жизненный цикл у Service?;Какой жизненный цикл у Service?<br>– onCreate()Вызывается один раз при первом создании сервиса методом startService(). Не вызывается при повторном использовании метода startService().<br>– onStartCommand()Вызывается каждый раз при получении сервисом команды, отправленной с помощью метода startService(). Метод может возвращать флаг, который запускает сервис в определённом режиме<br>– onBind()Вызывается при привязке (сервис живёт, пока жив клиент)  сервиса к клиенту (Activity) при помощью метода bindService()<br>– onRebind()Вызывается при повторной привязке сервиса к клиенту<br>– onUnbind()Вызывается при отвязке сервиса от клиента<br>– onDestroy()Вызывается при уничтожении сервиса;;;;;;;;;;;;;;;;;;;;;;
Android;Какие существуют разновидности сервисов?;<br>Сервисы можно разделить на три вида: <br>– Foreground ServiceСервис запущенный в данном режиме имеет высокий приоритет и не будет уничтожен системой, в случае нехватки памяти. Такой Service связывается с Notification, которое будет отображаться в статус баре. Запускается при помощи метода startForeground(). <br>– Background ServiceРаботает в стандартном режиме, в фоне, в основном потоке приложения. Запускается при помощи метода startService(). <br>– Bound ServiceService запущенный в данном режиме привязывается к какому-либо клиенту, например к Activity, и работает по принципу клиент-сервер. Service может быть привязан к нескольким клиентам, при этом система уничтожит сервис в случае, если все клиенты связанные с ним были уничтожены. Запускается при помощи метода bindService(). Для открепления сервиса от клиента используется метод unbindService(). При помощи интерфейса IBinder можно получить ссылку на наш сервис и вызывать методы непосредственно в нашем сервисе.;;;;;;;;;;;;;;;;;;;;;;
Android;Что такое Intent Service?;Intent Service – наследник класса Service. В отличие от Service, выполняется асинхронно в отдельном потоке. Сервис запускается методом startService() в котором передается Intent с необходимыми данными для работы. Обрабатывает входящий Intent в методе onHandleIntent(). После завершения всех необходимых операций над данными сервис прекращает свою работу.;;;;;;;;;;;;;;;;;;;;;;
Android;Какие флаги запуска можно задать сервису?;Метод  жизненного цикла сервиса onStartCommand()С может возвращать флаг, который описывает поведение сервиса, в случае если он был неожиданно остановлен, например системой из-за нехватки памяти:  – START_STICKY Сервис будет заново запущен системой и продолжит работу – START_REDELIVER_INTENT Сервис будет заново запущен системой и заново получит Intent который был передан методом startService() при запуске сервиса – START_NOT_STICKY Сервис остается в остановленном положении и не будет заново запущен системой – STOP_FOREGROUND_REMOVE Используется для отмены режима foreground и удаления Notification с которым связан сервис.Метод  жизненного цикла сервиса onStartCommand()С может возвращать флаг, который описывает поведение сервиса, в случае если он был неожиданно остановлен, например системой из-за нехватки памяти:– START_STICKYСервис будет заново запущен системой и продолжит работу– START_REDELIVER_INTENTСервис будет заново запущен системой и заново получит Intent который был передан методом startService() при запуске сервиса– START_NOT_STICKYСервис остается в остановленном положении и не будет заново запущен системой– STOP_FOREGROUND_REMOVEИспользуется для отмены режима foreground и удаления Notification с которым связан сервис.<br>Метод  жизненного цикла сервиса onStartCommand()С может возвращать флаг, который описывает поведение сервиса, в случае если он был неожиданно остановлен, например системой из-за нехватки памяти:<br>– START_STICKYСервис будет заново запущен системой и продолжит работу<br>– START_REDELIVER_INTENTСервис будет заново запущен системой и заново получит Intent который был передан методом startService() при запуске сервиса<br>– START_NOT_STICKYСервис остается в остановленном положении и не будет заново запущен системой<br>– STOP_FOREGROUND_REMOVEИспользуется для отмены режима foreground и удаления Notification с которым связан сервис.;;;;;;;;;;;;;;;;;;;;;;
Android;Пересоздается ли Activity при смене языка системы?;Да, после смены языка происходит полный цикл создания Activity.;;;;;;;;;;;;;;;;;;;;;;
Android;Что такое Zygote?;Это служба, которая является обязательным компонентом Android-системы. Она отвечает за инициализацию, старт системных служб, запуск и остановку пользовательских приложений и запускается после виртуальной машины Dalvik.;;;;;;;;;;;;;;;;;;;;;;
Android;Что такое Doze Mode?;Режим работы системы Android, который запускается, в случае если устройство находится без активного использования и зарядки более одного часа. Данный режим ограничивает функциональность всех приложений, запрещая использовать сеть, Alarm’ы, планировщики.;;;;;;;;;;;;;;;;;;;;;;
Android;Что такое App Standby?;Режим работы приложения, который также ограничивает функциональные возможности. Система включает данный режим, если пользователь некоторое время не использует приложение и у приложения нет никаких уведомлений на экране блокировки или панели уведомлений.;;;;;;;;;;;;;;;;;;;;;;
Android;В чем отличие Dialog от DialogFragment?;Класс Dialog используется для отображения диалогового окна и не позволяет управлять его жизненным циклом. Класс DialogFragment представляет собой фрагмент, который содержит Dialog и позволяет управлять своим жизненным циклом, не допуская утечек памяти и других неявных проблем.;;;;;;;;;;;;;;;;;;;;;;
Android;Что такое Target Fragment?;Target Fragment используется для взаимодействия между фрагментами, когда один фрагмент, содержит в себе другой фрагмент. Таким образом можно взаимодействовать с родительским фрагментом, по аналогии с методом startActivityForResult() который используется для получения обратной связи в Activity.;;;;;;;;;;;;;;;;;;;;;;
Android;Для чего нужен SnapHelper?;Класс в Android, который предназначен для изменения поведения прокрутки элементов в RecyclerView. При помощи данного класса, можно сымитировать прокрутку элементов на одну позицию, как это делает ViewPager.;;;;;;;;;;;;;;;;;;;;;;
Android;Что такое Flavors?;"<br>Product flavors – это параметр в Gradle, который предоставляет возможность разделить наше приложение на несколько версий, которые будут иметь различный функционал, например, версии demo/full, разделение приложения для клиентов и администраторов.  <br>productFlavors {     <br>demo {         <br>dimension ""version""         <br>applicationId ""com.stackofskills.demo""         <br>resValue ""string"", ""flavoredName"", ""Demo App""     <br>}      <br>full {        <br> dimension ""version""       <br>  applicationId ""com.stackofskills.full""       <br>  resValue ""string"", ""flavoredName"", ""Full App""   <br>  } <br>}";;;;;;;;;;;;;;;;;;;;;;
Android;Что такое  BuildType?;"<br>Данный параметр в Gradle необходим для создания сборок нашего приложения с различными настройками, например каким сертификатом подписывать приложение, какие адреса использовать для сетевых запросов.  <br>signingConfigs {    <br> config {      <br>   keyAlias 'stackofskills'      <br>   keyPassword 'password'       <br>  storeFile file(C:/android/key/key.jks)      <br>   storePassword 'password'   <br>  } <br>} <br>buildTypes {    <br> release {     <br>    minifyEnabled false     <br>    proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'     <br>    buildConfigField ""String"", 'URL', '""https://stackofskills.com""'    <br>     signingConfig signingConfigs.config   <br>  }   <br>  debug {    <br>     minifyEnabled false    <br>     proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'   <br>      buildConfigField ""String"", 'URL', '""https://demo.stackofskills.com""'  <br>   } <br>}";;;;;;;;;;;;;;;;;;;;;;
Android;Что такое BuildVariant?;Это совокупность параметров BuildType и Flavors, для создания итоговых билдов приложения, содержащих все необходимые настройки.;;;;;;;;;;;;;;;;;;;;;;
Android; Что такое View?;View это базовый класс для создания элементов пользовательского интерфейса в Android приложении. Представляет из себя прямоугольную область и отвечает за обработку событий (например клика по экрану) и их отображение. UI элементы являются наследниками класса View, например Button, TextView и т.д. Обязательными параметрами у элементов являются ширина android:layout_width и высота android:layout_height.;;;;;;;;;;;;;;;;;;;;;;
Android;Что такое ViewGroup?;ViewGroup это класс, который наследуется от View. Представляет собой контейнер, предназначенный для хранения в себе других элементов View, например несколько Button и ImageView. Является базовым классом для контейнеров UI элементов, таких как LinearLayout, ConstraintLayout, RecyclerView и т.д.У любого объекта может быть связанный с ним целочисленный идентификатор, который служит для обозначения уникальности объекта View в иерархии.;;;;;;;;;;;;;;;;;;;;;;
Android;Что такое XML?;Extensible Markup Language (XML) – это язык разметки, предназначенный для структурирования, хранения и передачи информации. Язык имеет свой базовый синтаксис, благодаря которому можно размечать текст при помощи обрамляющих тегов, превращая каждое слово или предложение в идентифицируемую, сортируемую информацию. Язык XML не имеет предопределенных тегов.;;;;;;;;;;;;;;;;;;;;;;
Android; Виды разметки в Android?;В Android SDK имеется несколько типов контейнеров, позволяющие располагать элементы пользовательского интерфейса различными способами. Разметку можно создавать как программно, так и при помощи редактора XML файлов в Android Studio. Один макет может содержать один или несколько вложенных макетов, но рекомендуется использовать как можно более простую иерархию макетов. Чем меньше в макете вложенных элементов, тем быстрее выполняется его отрисовка, горизонтальная иерархия представлений эффективнее вертикальной.  <br>Основные виды разметки: <br>– LinearLayoutРазметка, в которой элементы располагаются цепочкой поочередно. При указании параметра android:orientation=”vertical” View элементы располагаются друг под другом вертикально. При указании параметра android:orientation=”horizontal” View элементы располагаются друг за другом горизонтально. <br>– FrameLayoutРазметка, в которой элементы прикрепляются к верхнему левому углу экрана и их местоположение нельзя изменить. При добавлении нескольких элементов в FrameLayout они будут рисоваться поверх предыдущих, если их размеры совпадают, либо частично перекрывать друг друга. <br>– ReiativeLayoutРазметка, в которой элементы располагаются относительно родительского компонента или относительно соседних View элементов (по идентификатору элемента). <br>– ConstraintLayoutРазметка, схожая по принципу с RelativeLayout. У каждого View элемента есть линии, на основании которых View располагается внутри ConstraintLayout. Эти линии (constraints) могут быть привязаны к сторонам самого ConstraintLayout или к сторонам других View внутри ConstraintLayout <br>– TableLayoutРазметка, в которой элементы располагаются в табличной форме со строками и столбцами. Внутри TableLayout необходимо создавать элементы TableRow, которые будут являться строками и выстраиваться вертикально. Внутри TableRow можно размещать другие элементы, которые будут выстраиваться горизонтально. TableLayout не отображает разделительных линий для их строк, столбцов и ячеек, их необходимо реализовывать самостоятельно. Может иметь строки с разным количеством ячеек.;;;;;;;;;;;;;;;;;;;;;;
Android;Как создать собственный View элемент?;<br>Есть несколько способов для создания кастомного View: <br>– Расширить стандартный Android элементНапример, нам не хватает стандартных возможностей такого View элемента, как Button. Для расширения возможностей мы создаём свой класс и наследуемся от класса android.widget.Button. После чего мы можем переопределять своё поведение для View элемента. <br>– Наследовать класс от класса ViewДанный способ предоставляет нам возможность нарисовать свой собственный UI элемент, наполнить его логикой обработки событий нажатия и т.д.  <br>Рассмотрим методы жизненного цикла View в Android  <br>– Constructor Создание View начинается с конструктора, с различными входными параметрами, такими как Context, AttributeSet, defStyleAttr и  defStyleRes. <br>– onAttachToWindow() После вызова данного метода, наша View прикрепляется к нашему Activity и знает о других элементах, которые также находятся на этом экране. <br>– onMeasure() Метод определяет ширину и высоту вашего View, подтягивая данные из layout файла. При переопределении данного метода, необходимо указать ширину и высоту Вашего View самостоятельно, используя метод setMeasuredDimension(). <br>– onLayout() Определяет размер и положение элементов каждого дочернего элемента View, если они имеются. <br>– onDraw() Метод отвечает за рисование различных элементов внутри нашего View. Входным параметром метода является объект Canvas, при помощи которого мы и создаем элементы, такие как круг, текст, изображение и т.д.  <br>Для обновления визуальной части нашего View, используется метод invalidate(). Например, мы нарисовали квадрат, и хотим изменить его цвет. Для этого мы вызываем метод invalidate() после чего у нашего View вызывается метод onDraw() и происходит перерисовка нашего квадрата с новым цветом.  <br>В случае, если у нашего View были изменены размеры, необходимо вызвать метод requestLayout(), после которого последует вызов методов, согласно жизненному циклу нашего View, т.е. onMeasure() → onLayout() → onDraw().;;;;;;;;;;;;;;;;;;;;;;
Android;Что такое Context?;<br>Context представляет собой абстрактный класс в Android, от которого наследуются важные классы Application, Activity, Service. Важно отметить, что Fragment не наследуется от Context.  <br>Класс Context предоставляет следующие возможности: <br>– получить доступ к различным ресурсам приложения, например к строковым ресурсам методом getString() или к графическим ресурсам getDrawable() <br>– запускать Activity <br>– отправлять широковещательное сообщения (broadcast) и регистрировать приёмники широковещательных сообщений (BroadcastReceiver) <br>– запускать/останавливать сервисы, а также биндить их к Activity <br>– получать пути к директориям приложения в памяти системы Android, например методом getFilesDir().  <br> <br>Чтобы получить объект класса Context, мы можем использовать следующие способы: <br>–  внутри вложенного класса или метода получить ссылку на объект MainActivity – Activity.this <br>– внутри фрагмента получить ссылку на объект родительской активности – getActivity <br>– получить ссылку на базовый контекст – getBaseContext <br>– получить ссылку на объект приложения – getApplicationContext <br>– внутри активности или сервиса получить ссылку на этот объект – getContext <br>– this (то же, что и getContext) ;;;;;;;;;;;;;;;;;;;;;;
Android;Для чего используется Intent?;"<br>Intent – это класс в Android, который используется для для следующих возможностей: <br>– запуск Activity, передав объект Intent методу startActivity класса Context <br>– запуск сервиса, передав объект Intent методу startService класса Context <br>– отправка широковещательных сообщений, передав объект Intent методу sendBroadcast класса Context  <br>Intent делится на два типа – явный (explicit) и неявный (Implicit). Явный объект Intent используется для запуска какого-либо конкретного компонента своего приложения, например.  <br>Intent i = new Intent(this, ActivityTwo.class) startActivity(i)  <br>Неявный объект Intent содержит в себе действие (Action), которое другому приложению необходимо выполнить, если оно это делать умеет, например отобразить карту или открыть PDF файл.  <br>Intent i = new Intent(Intent.ACTION_VIEW, Uri.parse(""https://stackofskills.com"")) <br>startActivity(i)";;;;;;;;;;;;;;;;;;;;;;
Android;Что такое Bundle?;"<br>Bundle это потокобезопасный класс, который предназначен для хранения пар ключ-значение, т.е. мы можем положить в объект Bundle данные в виде примитивов либо объектов, реализующих интерфейс Parcelable. Может использоваться для передачи данных между Activity, для сохранения/восстановления данных при смены состояния Activity.  <br>Bundle b = new Bundle() <br>String name = ""Ivan"" <br>b.putString(""name"", name) <br>Man man = new Man() <br>b.putParcelable(""man"", man)";;;;;;;;;;;;;;;;;;;;;;
Android;Расскажите про класс Application?;<br>Application – класс в Android который позволяет отслеживать состояние приложения в целом. При создании процесса Android приложения (запуске приложения через launcher), в первую очередь всегда инициализируется класс Application и далее все остальные необходимые части приложения.  <br>В классе есть интерфейс ActivityLifecycleCallbacks, содержащий все методы жизненного цикла Activity, которые вызываются после вызова методов в Activity приложения.  <br>public interface ActivityLifecycleCallbacks {     <br>void onActivityCreated(Activity activity, Bundle savedInstanceState)     <br>void onActivityStarted(Activity activity)     <br>void onActivityResumed(Activity activity)     <br>void onActivityPaused(Activity activity)     <br>void onActivityStopped(Activity activity)     <br>void onActivitySaveInstanceState(Activity activity, Bundle outState)     <br>void onActivityDestroyed(Activity activity) <br>}  <br>Также класс содержит такие методы, как onLowMemory() и onTrimMemory() по отслеживанию использования памяти приложением.  <br>Context ресурсоёмкий класс, но его можно использовать в классе Application в качестве Singleton, потому как Application повторяет жизненный цикл самого приложения и статический Context будет создаваться и умирать вместе с ним. Это не будет вызывать утечек памяти и такой подход весьма удобно использовать для работы приложения.;;;;;;;;;;;;;;;;;;;;;;
Android;Расскажите про класс R в Android?;final Класс R автоматически генерируется во время компиляции приложения инструментом aapt (Android Asset Packaging Tool), который предназначен для упаковки и компиляции всех ресурсов приложения. В классе находятся идентификаторы для всех ресурсов созданных в каталоге res, например для графических ресурсов класс R.drawable. Для каждого типа ресурсов предусмотрен свой подкласс (R.dimen, R.layout и т.д.). Также для каждого ресурса указанного типа создается статическая целочисленная переменная, например R.drawable.image. Эта переменная служит идентификатором ресурса, которую можно использовать для его получения.;;;;;;;;;;;;;;;;;;;;;;
Android;Что такое Looper и MessageQueue?;MessageQueue – класс, который хранит список из объектов Message, которые должны быть выполнены по принципу FIFO. и взаимодействует с Looper для обработки сообщений. <br> Looper – класс, предназначенный для обработки очереди MessageQueue, в которую Handler отправляет сообщения (объекты Message) о необходимости обработать изменения в приложении. После запуска приложения, в его основном потоке создаётся экземпляр Looper, главный UI Looper приложения, который при помощи метода loop() запускает бесконечный цикл и проверяет, появились ли новые сообщения в MessageQueue. <br> При создании нового потока, необходимо обязательно создать looper внутри него, при помощи последовательного вызова методов Looper.prepare() → Looper.loop(), иначе при попытке изменить данные в UI потоке приложения, произойдёт ошибка. <br> class StackOfSkillsThread extends Thread { <br>      public Handler mHandler     <br>  public void run() {         <br>  Looper.prepare()           <br>mHandler = new Handler() {              <br> public void handleMessage(Message msg) {                <br>   // some logic here               <br>}           <br>}           <br>Looper.loop()       <br>}   <br>} <br> Для завершения работы Looper необходимо вызвать метод quitSafely() для того чтобы завершить работу Looper и быть уверенным в том, что все сообщения в MessageQueue были обработаны.;;;;;;;;;;;;;;;;;;;;;;
Android;Что такое Handler и HandlerThread?;<br>Handler это класс, который предназначен для управления потоками в приложении. Получает сообщения от Looper из MessageQueue и он же отправляет сообщения в MessageQueue. С его помощью мы можем связать UI поток нашего приложения с другими потоками. <br> При создании нового объекта Handler, по умолчанию он привязывается к этому потоку и MessageQueue в этом же потоке. Т.е. если мы создаём новый Thread и в нём создаём Handler, то он не будет иметь доступа к UI потоку приложения. Для взаимодействия с UI потоком, необходимо инициализировать looper в этом потоке, либо предоставить Main Looper для нашего Handler <br> Handler mHandler = new Handler(Looper.getMainLooper()) <br> HandlerThread – класс, который наследуется от Thread. Уже включает в себя Looper, MessageQueue и готов для создания нового потока, с последующей передачей данных в UI поток.;;;;;;;;;;;;;;;;;;;;;;
Test;Android :  AsyncTask;;;;;;;;;;;;;;;;;;;;;;;
Test;Android :  что такое процесс;;;;;;;;;;;;;;;;;;;;;;;
Test;Android :  Inter Process Communication;;;;;;;;;;;;;;;;;;;;;;;
Test;Android :  многомодульность;;;;;;;;;;;;;;;;;;;;;;;
Test;Android что такое OkHttp и зачем он нужен;;;;;;;;;;;;;;;;;;;;;;;
Test;RxJava: Hot и Cold observables;;;;;;;;;;;;;;;;;;;;;;;
Test;RxJava: разница между map и flatMap;;;;;;;;;;;;;;;;;;;;;;;
Test;RxJava: как создавать Observable;;;;;;;;;;;;;;;;;;;;;;;
Test;RxJava: разница между RxJava 1 и RxJava 2;;;;;;;;;;;;;;;;;;;;;;;
Test;RxJava: что такое BackPressure.;;;;;;;;;;;;;;;;;;;;;;;
Test;Dagger 2: аннотация Named;;;;;;;;;;;;;;;;;;;;;;;
Test;Dagger 2: скоупы в Dagger 2.;;;;;;;;;;;;;;;;;;;;;;;
Test;Kotlin: Extension functions;;;;;;;;;;;;;;;;;;;;;;;
Test;Kotlin: Null Safety;;;;;;;;;;;;;;;;;;;;;;;
Test;Kotlin: Inline functions;;;;;;;;;;;;;;;;;;;;;;;
Test;Kotlin: Delegates;;;;;;;;;;;;;;;;;;;;;;;
Test;Kotlin: Sequences;;;;;;;;;;;;;;;;;;;;;;;
Test;Kotlin: Sealed classes;;;;;;;;;;;;;;;;;;;;;;;
Test;Kotlin: Unit, Any, Nothing.;;;;;;;;;;;;;;;;;;;;;;;
Test;Android: Mafinest;;;;;;;;;;;;;;;;;;;;;;;
Test;Android: Intent & Intent Filters;;;;;;;;;;;;;;;;;;;;;;;
Test;Android: Serialization/parcelization;;;;;;;;;;;;;;;;;;;;;;;
Test;Android: Android tasks and backstack;;;;;;;;;;;;;;;;;;;;;;;
Test;Android: Notifications;;;;;;;;;;;;;;;;;;;;;;;
Test;Android: Permissions;;;;;;;;;;;;;;;;;;;;;;;
Test;Android: Resources;;;;;;;;;;;;;;;;;;;;;;;
Test;Android: Styles and Themes;;;;;;;;;;;;;;;;;;;;;;;
Test;Android: RecyclerView;;;;;;;;;;;;;;;;;;;;;;;
Test;Android: Service (IBinder, Message Handler);;;;;;;;;;;;;;;;;;;;;;;
Test;Android: IPC/AIDL;;;;;;;;;;;;;;;;;;;;;;;
Test;Android: ContentProvider;;;;;;;;;;;;;;;;;;;;;;;
Test;Android: Fragment;;;;;;;;;;;;;;;;;;;;;;;
Test;Android: Context;;;;;;;;;;;;;;;;;;;;;;;
Test;Android: MVP/MVVM.;;;;;;;;;;;;;;;;;;;;;;;
Test;Common: Patterns (GoF);;;;;;;;;;;;;;;;;;;;;;;
Test;Common: DI;;;;;;;;;;;;;;;;;;;;;;;
Test;Common:Git;;;;;;;;;;;;;;;;;;;;;;;
Test;Common: Gradle + Flavours/Builds.;;;;;;;;;;;;;;;;;;;;;;;