[
  {
    "category": "Java",
    "question": "Модификаторы доступа Java (в порядке от private до public):",
    "answer": "private — ограничивает видимость данных и методов пределами одного класса.\n\nprotected — Поля и методы, обозначенные модификатором доступа protected, будут видны в пределах всех классов, находящихся в том же пакете, что и наш и в пределах всех классов-наследников нашего класса.\n\ndefault (package visible) — default или, как его еще называют, package visible. Он не обозначается ключевым словом, поскольку установлен в Java по умолчанию для всех полей и методов. Действует также, как и protected, за исключением наследования.\n\npublic — Не накладывает никаких ограничений на доступ; предназначаются для конечного пользователя."
  },
  {
    "category": "Java",
    "question": "Реализация «кучи» (где хранятся объекты):",
    "answer": "Эта область памяти используется для объектов и классов. Новые объекты всегда создаются в куче, а ссылки на них хранятся в стеке. Эти объекты имеют глобальный доступ и могут быть получены из любого места программы.\n\nЭта область памяти разбита на несколько более мелких частей, называемых поколениями:\n\nYoung Generation — область где размещаются недавно созданные объекты. Когда она заполняется, происходит быстрая сборка мусора.\n\nOld (Tenured) Generation — здесь хранятся долгоживущие объекты. Когда объекты из Young Generation достигают определенного порога “возраста”, они перемещаются в Old Generation.\n\nPermanent Generation — эта область содержит метаинформацию о классах и методах приложения, но начиная с Java 8 данная область памяти была упразднена.\n\nПомимо рассмотренных ранее, куча имеет следующие ключевые особенности:Когда эта область памяти полностью заполняется, Java бросает java.lang.OutOfMemoryError Доступ к ней медленнее, чем к стеку. Эта память, в отличие от стека, автоматически не освобождается. Для сбора неиспользуемых объектов используется сборщик мусора. В отличие от стека, куча не является потокобезопасной и ее необходимо контролировать, правильно синхронизируя код."
  },
  {
    "category": "Java",
    "question": "Memory стэк в java",
    "answer": "В Java стек памяти, также известный как стек вызовов или стек фреймов, играет важную роль в управлении выполнением программы и хранении данных во время вызова методов.\n\nКаждый раз, когда вы вызываете метод в Java, создается новый стековый фрейм и помещается в верхнюю часть стека памяти. Стековый фрейм содержит локальные переменные метода, аргументы метода, адрес возврата и другую информацию, необходимую для выполнения метода.\n\nКогда метод заканчивает свою работу, его стековый фрейм удаляется из верхней части стека, и управление возвращается к предыдущему методу, который вызвал данный метод. Этот процесс называется \"раскруткой стека\" (stack unwinding).\n\nСтек памяти в Java имеет фиксированный размер, который определяется при запуске виртуальной машины Java (JVM). Если стек памяти заполняется слишком быстро или превышает свой максимальный размер, возникает исключение \"StackOverflowError\".\n\nСтек памяти в Java также играет важную роль в рекурсивных вызовах методов. Каждый рекурсивный вызов создает новый стековый фрейм, и стек памяти может быть заполнен, если рекурсия происходит слишком глубоко. В этом случае также может возникнуть исключение \"StackOverflowError\".\n\nСтек памяти в Java обычно является потокобезопасным, так как каждый поток имеет свой отдельный стек памяти. Это позволяет нескольким потокам работать независимо друг от друга и эффективно использовать память.\n\nВажно отметить, что стек памяти в Java отличается от кучи (heap), где хранятся объекты и динамически выделяемая память. Стек памяти используется в основном для хранения временных данных и управления выполнением программы, в то время как куча используется для долгосрочного хранения объектов."
  },
  {
    "category": "Java",
    "question": "Где и как используются методы equals() и hashcode():",
    "answer": "Метод equals() являются ли два объекта одного происхождения логически равными. Создатель класса сам определяет характеристики, по которым проверяется равенство объектов этого класса.\n\nОбъекты должны быть экземплярами одного класса и не должны быть null. Переопределяя метод equals(), обязательно соблюдение этих требований:\n\nРефлексивность: Любой объект должен быть equals() самому себе.\n\nСимметричность: Если a.equals(b) == true, то и b.equals(a) должно возвращать true.\n\nТранзитивность: Если два объекта равны какому-то третьему объекту, значит, они должны быть равны друг и другу. Если a.equals(b) == true и a.equals(c) == true, значит проверка b.equals(c) тоже должна возвращать true.\n\nПостоянность: Результаты работы equals() должны меняться только при изменении входящих в него полей. Если данные двух объектов не менялись, результаты проверки на equals() должны быть всегда одинаковыми.\n\nСравнение с null для любого объекта a.equals(null) должно возвращать false.\n\nМетод hashCode() возвращает для любого объекта 32-битное число типа int. Если два объекта равны (т.е. метод equals() возвращает true), у них должен быть одинаковый хэш-код. Проверка по hashCode() должна идти первой для повышения быстродействия. Если метод hashCode() вызывается несколько раз на одном и том же объекте, каждый раз он должен возвращать одно и то же число. Одинаковый хэш-код может быть у двух разных объектов. Методы equals и hashCode необходимо переопределять вместе."
  },
  {
    "category": "Java",
    "question": "Что будет, если не переопределить метод hashcode():",
    "answer": "Тогда с точки зрения метода equals два объекта будут логически равны, в то время как с точки зрения метода hashCode они не будут иметь ничего общего."
  },
  {
    "category": "Java",
    "question": "Реализация HashMap:",
    "answer": "HashMap — основан на хэш-таблицах, реализует интерфейс Map (что подразумевает хранение данных в виде пар ключ/значение). Ключи и значения могут быть любых типов, в том числе и null. Сначала ключ проверяется на равенство с null. Если это проверка вернула true, будет вызван метод putForNullKey(value). Далее генерируется хэш на основе ключа. Для генерации используется метод hash(hashCode), в который передается key.hashCode(). С помощью метода indexFor(hash, tableLength), определяется позиция в массиве, куда будет помещен элемент. Теперь, зная индекс в массиве, мы получаем список (цепочку) элементов, привязанных к этой ячейке. Хэш и ключ нового элемента поочередно сравниваются с хэшами и ключами элементов из списка и, при совпадении этих параметров, значение элемента перезаписывается. Если же предыдущий шаг не выявил совпадений, будет вызван метод addEntry(hash, key, value, index) для добавления нового элемента"
  },
  {
    "category": "Java",
    "question": "Как разрешается коллизия в HashMap (метод цепочек или открытая адресация)",
    "answer": "Разрешение коллизий при помощи цепочек. Каждая ячейка массива H является указателем на связный список (цепочку) пар ключ-значение, соответствующих одному и тому же хеш-значению ключа. Коллизии просто приводят к тому, что появляются цепочки длиной более одного элемента."
  },
  {
    "category": "Java",
    "question": "Виды исключений в Java:",
    "answer": "Unchecked(Error, RunTimeException); Checked(Exception)"
  },
  {
    "category": "Java",
    "question": "Виды коллекций Java (перечисляете всё, что знаете):",
    "answer": "List, Set, Queue, Deque, Map."
  },
  {
    "category": "Java",
    "question": "Типы ссылок Java и где используются, в порядке убывания жёсткости:",
    "answer": "Strong reference, они же обычные, нужны для указания на объекты, которые должны обязательно оставаться в памяти всё то время, что эти ссылки на него существуют. Если не складывается, получите OutOfMemoryError. \n\n (Soft Reference) Мягкие ссылки полезны для кэшей, чувствительных к доступному объёму оперативной памяти. Объекты по ним могут зачиститься, но только в случае необходимости. Например, если нужно насоздавать ещё объектов с сильными ссылками, а уже негде, лучше освободить кэш и замедлить работу, чем уронить процесс напрочь. \n\n Weak Reference(слыбые) полезны для сопоставления объектов чему-нибудь без удерживания их от зачистки когда они больше не нужны (а-ля Map<Ключ, WeakRef<Значение>>). На возможность зачистки они не влияют вообще никак, слабые ссылки будут очищены при очередном запуске сборщика.   Phantom Reference   Фантомные ссылки возникают, когда объект уже признан мусором, финализирован и находится в процессе зачистки, о чём можно узнать с помощью класса Cleaner и выполнить в это время какие-то собственные действия."
  },
  {
    "category": "Java",
    "question": "Способы синхронизации Java:",
    "answer": "Синхронизация относится к многопоточности. Синхронизированый блок кода может быть выполнен только одним потоком одновременно. Синхронизация достигается в Java использованием зарезервированного слова synchronized. Вы можете использовать его в своих классах, определяя синхронизированные методы или блоки. Вы не сможете использовать synchronized в переменных или атрибутах в определении класса.\n\nБлокировка на уровне объекта-это механизм, когда требуется синхронизировать нестатический метод или нестатический блок кода таким образом, чтобы только один поток мог выполнить блок кода на данном экземпляре класса. Это всегда должно быть сделано, чтобы сделать потокобезопасными данные уровня экземпляра.\n\nБлокировка уровня класса предотвращает ввод нескольких потоков в синхронизированный блок в любом из всех доступных экземпляров во время выполнения. Это означает, что если во время выполнения есть 100 экземпляров DemoClass, то только один поток сможет выполнить demoMethod() в любом из экземпляров одновременно, а все остальные экземпляры будут заблокированы для других потоков."
  },
  {
    "category": "Java",
    "question": "Volatile — что это",
    "answer": "Запрещает помещать значение переменной в кэш. Ключевое слово volatile указывается для поля для того, чтобы указать компилятору, что все операции присвоения этой переменной и все операции чтения из неё должны быть атомарными. Более того, присвоение значения этой переменной имеет связь happens-before (произошло-до) для последующих чтений из этой переменной для любых потоков, то есть после присвоения нового значения переменной все потоки увидят это новое значение.\n\nДело в том, что Java позволяет потокам в целях производительности сохранять локальные копии переменной для каждого потока, который её использует (например в кешах или регистрах процессора). В таком случае после записи другим потоком нового значения в исходную переменную, первый поток будет видеть свою локальную копию со старым значением.\n\nИспользование ключевого слова volatile гарантирует, что все потоки всегда будут использовать общее, исходное значение, и они будут видеть изменения этого исходного значения другими потоками сразу же. Аналогично все изменения переменных, произошедшие внутри sychronized-методов и synchronized-блоков, а также блоков с другими блокировками вроде реализаций интерфейса java.util.concurrent.locks.Lock после выхода из блокировки будут гарантировано видны любым другим потокам после взятия блокировки над тем же самым объектом, но если более сложные блокировки не нужны, то можно использовать volatile."
  },
  {
    "category": "Java",
    "question": "StringBuilder vs String",
    "answer": "Благодаря неизменности, хэшкод экземпляра класса String кэшируется. Его не нужно вычислять каждый раз, потому что значения полей объекта никогда не изменятся после его создания. Это дает высокую производительность при использовании данного класса в качестве ключа для HashMap.\n\nStringBuilder — изменяемый класс, поэтому при работе с ним не возникает такого же количества мусора в памяти, как со String. Поэтому если над строками проводится много модификаций, лучше использовать StringBuilder."
  },
  {
    "category": "Java",
    "question": "Назовите синхронизированную версию HashMap (Hashtable, но устарела)",
    "answer": "SynchronizedMap и ConcurrentHashMap.\n\nМетоды SynchronizedMap удерживают блокировку на объекте, в то время как ConcurrentHashMap есть понятие «чередование блокировок», когда вместо блокировок удерживаются блоки содержимого. Таким образом улучшается масштабируемость и производительность."
  },
  {
    "category": "Java",
    "question": "Реализация ArrayList в Java (на базе массива):",
    "answer": "Класс ArrayList реализует интерфейс List и может менять свой размер во время исполнения программы, при этом не обязательно указывать размерность при создании объекта. Элементы ArrayList могут быть абсолютно любых типов в том числе и null. Внутри у него находится массив, в котором и хранятся элементы. УArrayListʼa есть специальный механизм по работе с ним: Когда этот внутренний массив заполняется, ArrayList создает внутри себя новый массив. Его размер = (размер старого массива * 1,5) +1. Все данные копируются из старого массива в новый Старый массив удаляется сборщиком мусора."
  },
  {
    "category": "Java",
    "question": "Модификатор final в Java — где используется и что даёт",
    "answer": "Применяться к классам, методам, переменным (в том числе аргументам методов) Для класса это означает, что класс не сможет иметь подклассов, т.е. запрещено наследование. Для метода final означает, что он не может быть переопределен в подклассах. Для переменных примитивного типа это означает, что однажды присвоенное значение не может быть изменено. Для ссылочных переменных это означает, что после присвоения объекта, нельзя изменить ссылку на данный объект. Ссылку изменить нельзя, но состояние объекта изменять можно"
  },
  {
    "category": "Kotlin",
    "question": "Что такое котлин?",
    "answer": "Kotin - это язык программирования с открытым исходным кодом, который выполняется с использованием виртуальной машины Java в качестве своей платформы. Он был разработан JetBrains. Он сравнительно проще, чем Java, и предлагает несколько функций, которые Java не может удержать. это комбинация процедурного и объектно-ориентированного языка программирования."
  },
  {
    "category": "Kotlin",
    "question": "Как работает Котлин?",
    "answer": "Kotlin работает на виртуальной машине Java для ее выполнения. Весь код kotlin конвертируется в собственный код, и этот процесс преобразования байт-кода также может быть достигнут с помощью других относительных виртуальных машин."
  },
  {
    "category": "Kotlin",
    "question": "Kotlin features (что такого классного в Kotlin?)",
    "answer": "Null-безопасность\n\nКлассы данных (Data Classes)\n\nSealed Classes\n\nФункции-расширения\n\nУмные приведения типов\n\nВ Kotlin необязательно явно указывать тип переменной\n\nФункциональное программирование"
  },
  {
    "category": "Kotlin",
    "question": "Scope-функции",
    "answer": "В языке Kotlin есть несколько встроенных функций, называемых \"scope-функциями\", которые облегчают и улучшают работу с объектами и контекстом. Эти функции предоставляют удобный синтаксис для выполнения операций на объектах с возможностью доступа к их контексту.\n\nВот некоторые из наиболее часто используемых scope-функций в Kotlin:\n\n    let: Функция let позволяет выполнить блок кода над объектом и возвращает результат последнего выражения в блоке. Она часто используется для выполнения операций над объектами, когда требуется выполнить дополнительные действия или изменения.\n\nkotlin\n\nval result = someObject.let {\n    // выполнение операций на someObject\n    // результат последнего выражения будет присвоен переменной result\n    \"Result: $it\"\n}\n\n    apply: Функция apply применяет блок кода к объекту и возвращает сам объект. Она используется для настройки свойств объекта или выполнения операций, когда требуется модифицировать объект и сохранить его состояние.\n\nkotlin\n\nval modifiedObject = someObject.apply {\n    // настройка свойств объекта\n    property1 = value1\n    property2 = value2\n    // ...\n}\n\n    run: Функция run выполняет блок кода и возвращает результат последнего выражения в блоке. Она часто используется для выполнения цепочки операций над объектом, когда требуется выполнять несколько операций или вызывать методы объекта.\n\nkotlin\n\nval result = someObject.run {\n    // выполнение операций на someObject\n    // результат последнего выражения будет присвоен переменной result\n    \"Result: $this\"\n}\n\n    also: Функция also выполняет блок кода над объектом и возвращает сам объект. Она используется для выполнения дополнительных действий, таких как логирование или выполнение побочных эффектов, без изменения объекта.\n\nkotlin\n\nval modifiedObject = someObject.also {\n    // выполнение дополнительных действий на someObject\n    // без изменения самого объекта\n    println(\"Additional actions on $it\")\n}\n\n    with: Функция with позволяет работать с объектом, неявно обращаясь к его членам без необходимости повторного указания имени объекта. Она используется для выполнения нескольких операций над объектом в контексте блока кода.\n\nkotlin\n\nval result = with(someObject) {\n    // доступ к свойствам и методам объекта без повторного указания имени\n    val value = property1 + property2\n    // ...\n    \"Result: $value\"\n}\n\nScope-функции упрощают и улучшают читаемость кода в Kotlin, позволяя выполнять операции на объектах и работать с их контекстом более компактным и выразительным способом. Выбор конкретной scope-функции зависит от требуемого поведения и контекста использования."
  },
  {
    "category": "Kotlin",
    "question": "В списке java.io.file методы расширения, которые предоставляет kotlin?",
    "answer": "Некоторый метод расширения обеспечивает:      bufferedReader (): чтение файла в BufferedReader     readBytes (): чтение файла в ByteArray     readText (): чтение файла в одну строку     forEachLine (): использовать для чтения файла построчно в Kotlin     readLines (): чтение файла в список"
  },
  {
    "category": "Kotlin",
    "question": "Kotlin const vs val?",
    "answer": "Ключевое слово const используется для инициализации во время компиляции     Ключевое слово val используется для инициализации во время выполнения"
  },
  {
    "category": "Kotlin",
    "question": "Первичные конструкторы против вторичных конструкторов?",
    "answer": "Первичные конструкторы утверждаются по существу в определении класса. Вторичные Конструкторы утверждаются исключительно внутри тела класса. В следующем примере в первой строке ключевое слово constructor, включающее переменные, объявленные сразу после того, как он является первичным конструктором. Вторичный конструктор - это тот, который объявлен внутри тела класса.  конструктор класса A (var nme: String, var age: Int)  (var обозначение: String = «Не упоминается» конструктор класса A (var nme: String, var age: Int) (  конструктор (nme: String, age: Int, обозначение: String): this (имя, возраст) (  this.designation = обозначение"
  },
  {
    "category": "Kotlin",
    "question": "Есть ли возможность перенести код с Kotlin на Java?",
    "answer": "Да, миграция Kotlin в java-код, безусловно, возможна. Для решения этой задачи по миграции используется встроенный инструмент, разработанный компанией Jet BRAINS."
  },
  {
    "category": "Kotlin",
    "question": "Поддерживает ли Kotlin примитивные типы данных, как в Java, если да, пожалуйста, объясните их подробно?",
    "answer": "Ни один kotlin не поддерживает примитивные типы данных, как в Java."
  },
  {
    "category": "Kotlin",
    "question": "Перечислите ключевые модификаторы, которые связаны с Kotlin?",
    "answer": "Классы, объекты, интерфейсы, конструкторы, функции, свойства и их сеттеры могут иметь модификаторы доступа. Геттеры всегда имеют тут же видимость, что и свойства, к которым они относятся.\n\nВ Kotlin предусмотрено четыре модификатора доступа: private, protected, internal и public. Если явно не использовать никакого модификатора, то по умолчанию применяется public.\n\nДля членов, объявленных в классе:\n\n    private означает видимость только внутри этого класса (включая его члены);\n    protected — то же самое, что и private + видимость в субклассах;\n    internal — любой клиент внутри модуля, который видит объявленный класс, видит и его internal члены;\n    public — любой клиент, который видит объявленный класс, видит его public члены.\n\n    В Kotlin внешний класс не видит private члены своих вложенных классов.\n"
  },
  {
    "category": "Kotlin",
    "question": "Типы Unit, Nothing, Any в Kotlin",
    "answer": "Система типов Kotlin несколько отличается от системы типов Java и может вызвать у незнающего человека много вопросов. Наиболее проблемными обычно оказываются типы Unit и Nothing.\n\n    Unit — эквивалент типа void в Java. Другими словами, он нужен для того, чтобы показать, что функция ничего не возвращает. Unit наследуется от типа Any, а при работе с Java-кодом автоматически транслируется в void.\n\n    Nothing — субкласс любого класса (именно так), не позволяющий создать объект своего типа (конструктор приватный). Используется для представления результата исполнения функции, которая никогда не завершается (например, потому что она выбрасывает исключение). Пример:\n\n    public inline fun TODO(): Nothing = throw NotImplementedError()\n    fun determineWinner(): Player = TODO()\n\n    Any — родитель всех остальных классов. Аналог Object в Java.\n"
  },
  {
    "category": "Kotlin",
    "question": "MutableList vs List",
    "answer": "List представляет последовательный список элементов. List представляет неизменяемую (immutable) коллекцию, которая в основном только обеспечивает получение элементов по позиции. Изменяемые списки представлены интерфейсом MutableList. Он расширяет интерфейс List и позволяют добавлять и удалять элементы."
  },
  {
    "category": "Kotlin",
    "question": "Функция inline",
    "answer": "Условно inline функция - это косок кода который подставляется  в написанный код во время компиляции, не вызывается доп функция. Плюс использования этого подхода - в экономии стека вызова.  Функция inline в Kotlin представляет возможность встраивания кода функции прямо в вызывающий код во время компиляции. Это позволяет избежать накладных расходов, связанных с вызовом функции, и повысить производительность программы.\n\nКогда функция объявляется с модификатором inline, компилятор Kotlin заменяет все вызовы этой функции на фактическое содержимое функции во время компиляции. Таким образом, код функции встраивается непосредственно в вызывающий код, как если бы он был написан вручную в каждом месте вызова. Это позволяет избежать создания отдельного объекта или вызова функции, что может быть полезно для уменьшения накладных расходов при вызове коротких функций или функций, которые вызываются много раз.\n\nПример использования inline функции:\nkotlin\n\ninline fun calculateSum(a: Int, b: Int): Int {\n    return a + b\n}\n\nfun main() {\n    val result = calculateSum(5, 10)\n    println(\"Sum: $result\")\n}\n\nВ приведенном примере функция calculateSum объявлена с модификатором inline. Когда функция вызывается в main(), ее код встраивается непосредственно в это место вызова. Это означает, что фактический код функции calculateSum будет присутствовать внутри main() после компиляции.\n\nИспользование inline функций может повысить производительность программы, но стоит помнить, что встраивание кода может увеличить размер скомпилированного файла. Поэтому inline следует использовать с осторожностью и только для коротких функций или функций, которые часто вызываются. Также, при использовании inline функций, необходимо учитывать возможные ограничения и ограничения на использование других функций или конструкций языка, таких как рекурсия или использование локальных классов."
  },
  {
    "category": "Kotlin",
    "question": "noinline,  crossinline ,reified ",
    "answer": "noinline, crossinline и reified - это модификаторы и ключевое слово в языке Kotlin, используемые для управления поведением функций и типов.\n\n    noinline: Модификатор noinline применяется к параметрам функции, которые являются лямбда-выражениями, чтобы указать, что эти лямбда-выражения не должны быть сохранены в качестве объектов или передаваться в другие функции в качестве параметров с сохранением ссылки. Вместо этого, такие лямбда-выражения должны быть выполнены немедленно в контексте вызова.\n\nkotlin\n\ninline fun someFunction(noinline lambda: () -> Unit) {\n    // ...\n}\n\nВ этом примере функция someFunction принимает параметр lambda с модификатором noinline. Это означает, что лямбда-выражение, переданное в lambda, должно быть выполнено немедленно и не может быть сохранено для дальнейшего использования.\n\n    crossinline: Ключевое слово crossinline также используется с параметрами функции, которые являются лямбда-выражениями. Оно указывает, что лямбда-выражение не может содержать операторы return, которые позволяют преждевременно выйти из лямбда-выражения и функции, которая его содержит. Использование crossinline гарантирует, что выполнение функции будет продолжено после выполнения лямбда-выражения.\n\nkotlin\n\ninline fun someFunction(crossinline lambda: () -> Unit) {\n    // ...\n}\n\nВ этом примере функция someFunction принимает параметр lambda с ключевым словом crossinline. Лямбда-выражение lambda не может содержать операторы return, чтобы избежать преждевременного выхода из функции.\n\n    reified: Ключевое слово reified используется вместе с типовыми параметрами функции для доступа к информации о типе во время выполнения (runtime). Обычно типовые параметры стираются во время компиляции и недоступны во время выполнения, но с использованием reified можно получить доступ к типу внутри функции.\n\nkotlin\n\ninline fun <reified T> someFunction() {\n    // ...\n}\n\nВ этом примере функция someFunction имеет типовой параметр T, помеченный ключевым словом reified. Это позволяет получить информацию о типе T во время выполнения функции.\n\nМодификаторы noinline, ключевое слово crossinline и ключевое слово reified предоставляют дополнительные возможности для управления поведением функций и типов в Kotlin, позволяя более точно настроить их работу в различных сценариях. "
  },
  {
    "category": "Kotlin",
    "question": "Недостатки использования inline",
    "answer": "Хотя использование модификатора inline в Kotlin может принести некоторые преимущества, такие как повышение производительности и уменьшение накладных расходов, есть и некоторые недостатки, которые следует учитывать при использовании inline функций:\n\n    Увеличение размера скомпилированного кода: Использование inline функций может привести к увеличению размера скомпилированного файла, поскольку каждый вызов функции заменяется фактическим содержимым функции. Это может быть проблематично для больших функций или функций, которые вызываются много раз в разных местах программы.\n\n    Потеря читаемости кода: Встраивание кода функции может усложнить чтение и понимание вызывающего кода, особенно если функция содержит сложную логику или большое количество операций. Код может стать менее структурированным и более сложным для отладки и поддержки.\n\n    Ограничения на использование: Использование inline функций может накладывать ограничения на некоторые конструкции языка Kotlin. Например, inline функции не могут содержать локальные классы или использовать рекурсию. В некоторых случаях это может ограничить возможности проектирования и реализации кода.\n\n    Увеличение времени компиляции: Использование inline функций может привести к увеличению времени компиляции, особенно если встраиваемая функция вызывается много раз или функция содержит сложный код. Компилятор должен произвести замену вызовов функции фактическим содержимым, что может занять дополнительное время.\n\n    Возможность увеличения потребления памяти: Большой объем встраиваемого кода может потребовать дополнительной памяти при выполнении программы, особенно если функция вызывается много раз или содержит большое количество переменных и объектов.\n\nВажно оценить преимущества и недостатки в конкретном контексте и принять решение об использовании inline функций на основе требований проекта и его особенностей. Не всегда целесообразно использовать inline для всех функций, и иногда более явное использование отдельных функций может быть предпочтительным с точки зрения читаемости и поддержки кода."
  },
  {
    "category": "Kotlin",
    "question": "infix - Инфиксная нотация",
    "answer": "В Kotlin ключевое слово infix используется для объявления функций-расширений или методов класса, которые можно вызывать с использованием инфиксной нотации. Инфиксная нотация позволяет вызывать функции с одним аргументом между объектом и вызываемым методом, без использования точечной нотации или скобок.\n\nДля объявления функции-расширения или метода класса как инфиксной, нужно использовать ключевое слово infix перед его объявлением.\n\nВот простой пример функции-расширения, объявленной как инфиксной:\nkotlin\n\ninfix fun Int.add(num: Int): Int {\n    return this + num\n}\n\nfun main() {\n    val result = 5 add 3 // Использование инфиксной нотации\n    println(result) // Выводит: 8\n}\n\nВ этом примере функция-расширение add объявлена с использованием ключевого слова infix. Она принимает один параметр типа Int и выполняет сложение с вызывающим объектом типа Int. В функции main() функция-расширение add вызывается с использованием инфиксной нотации 5 add 3, что эквивалентно выражению 5.add(3). Результат сложения выводится на консоль.\n\nВажно отметить, что инфиксная нотация ограничена вызовами методов или функций с одним параметром. Если функция-расширение или метод класса требует более одного параметра, она не может быть вызвана с использованием инфиксной нотации.\n\nИспользование инфиксной нотации может улучшить читаемость кода в определенных ситуациях, особенно когда вызовы функций напоминают естественный язык или математическую операцию. Однако, следует использовать инфиксную нотацию с умом, чтобы не ухудшать читаемость кода и не создавать путаницу. "
  },
  {
    "category": "Kotlin",
    "question": "Data class — в чём преимущество:",
    "answer": "Если у класса указать ключевое слово data, то автоматически будут созданы и переопределены методы toString(), equals(), hashCode(), copy().\n\nПри создании data-классов компилятор автоматически добавляет набор функций, с помощью которых можно обратиться к свойствам. Они известны как componentN-функции, где N - это номер свойства. Подсчёт номера идёт по порядку в объявлении класса.\n\ndata class Music(val title: String, val author: String)\n// Обращаемся к классу\nval music = Music(\\\"Kalinka\\\", \\\"Abba\\\")\nval title = music.component1()\nval author = music.component2()\n\nПри добавлении val списка в data класс - hashCode этого поля = ссылки на объект, а не реальный хэш код\n\nПри использовании var в дата классе - хэш код будет меняться при изменение поля, что может привести к негативным последствиям"
  },
  {
    "category": "Kotlin",
    "question": "Модификатор open в Kotlin — где используется и что даёт",
    "answer": "По умолчанию класс всегда наследуется от Any (аналог Object в Java) и является закрытым (final) (в Java по умолчанию открыты). В этом случае нельзя наследоваться от него. Но мы можем наследоваться от другого конкретного класса, который явно объявлен как open или abstract.Также добавьте модификатор open ко всем свойствам и методам, которые можно переопределять"
  },
  {
    "category": "Kotlin",
    "question": "Модификатор object в Kotlin — где используется и что даёт",
    "answer": "С его помощью можно реализовать шаблон “Одиночка». Ключевое слово object одновременно объявляет класс и создаёт его экземпляр. Также можно реализовать объект-компаньон, содержащий лишь фабричные методы, а также методы, связанные с классом, но не требующие обращения к его экземпляру. К членам такого объекта можно обращаться просто по имени класса. Ещё можно использовать для записи объекта-выражения в качестве замены анонимного внутреннего класса."
  },
  {
    "category": "Kotlin",
    "question": "companion object в Котлин для чего",
    "answer": "В Kotlin, ключевое слово \"companion object\" используется для создания статических членов класса. Класс Kotlin может иметь только один компаньон-объект, и он обеспечивает возможность создания методов и свойств, которые могут быть вызваны без необходимости создавать экземпляр класса.\n\nКомпаньон-объекты могут использоваться для следующих целей:\n\n    Создание статических методов: Вы можете объявить функции внутри компаньон-объекта, которые могут быть вызваны без создания экземпляра класса. Например:\n\nkotlin\n\nclass MyClass {\n    companion object {\n        fun staticMethod() {\n            // Код статического метода\n        }\n    }\n}\n\n// Вызов статического метода\nMyClass.staticMethod()\n\n    Создание статических свойств: Вы можете объявить свойства внутри компаньон-объекта, которые можно получить без создания экземпляра класса. Например:\n\nkotlin\n\nclass MyClass {\n    companion object {\n        val staticProperty: Int = 10\n    }\n}\n\n// Получение значения статического свойства\nval value = MyClass.staticProperty\n\n    Имитация статического конструктора: Вы можете использовать компаньон-объект для инициализации класса или выполнения некоторых действий при его первоначальной загрузке. Например:\n\nkotlin\n\nclass MyClass {\n    companion object {\n        init {\n            // Инициализация класса\n        }\n    }\n}\n\n    Реализация паттерна одиночка (Singleton): Компаньон-объект можно использовать для создания класса, который имеет только один экземпляр. Например:\n\nkotlin\n\nclass Singleton {\n    companion object {\n        private val instance = Singleton()\n\n        fun getInstance(): Singleton {\n            return instance\n        }\n    }\n}\n\n// Получение экземпляра Singleton\nval singleton = Singleton.getInstance()\n\nКомпаньон-объекты в Kotlin предоставляют удобный способ объединить статические методы и свойства внутри класса и использовать их без необходимости создания экземпляра класса."
  },
  {
    "category": "Kotlin",
    "question": "Var,val и const val",
    "answer": "var - изменяемая , val - не изменияемая. val -в рантайме, consta val - во время компиляции"
  },
  {
    "category": "Kotlin",
    "question": "Исключения в java vs kotlin ",
    "answer": "Kotlin  все исключения Runtime , можно их не проверять. В  Java проверяемые исключения - мы их должны обязательно обработать"
  },
  {
    "category": "Kotlin",
    "question": "Thread vs Coorutines",
    "answer": "Thread vs Coorutines - Thread тяжеловестные потоки, занимает ~ 1mb памяти, Coorutiunes -легковесные потоки, внутри языка, и не требуют от системы большой памяти. 1 корутина может пороботать в thread и после в thread может поработать другая, тем самым экономим память."
  },
  {
    "category": "Kotlin",
    "question": "Suspend kotlin ",
    "answer": "Корутины в Kotlin представлены ключевым словом suspend,- это такая функция, котороя не блокируя поток , может ожидать выполнения какой то опрации \nПредположим, что у нас есть две функции приостановки, определенные в другом месте, которые делают что-то полезное, например, какой-то удаленный вызов службы или вычисление. Мы просто притворяемся, что они полезны, но на самом деле каждый из них просто задерживает на секунду для целей этого примера:\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // притворимся, что мы делаем что-то полезное здесь\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // притворимся, что мы тоже делаем что-то полезное здесь\n    return 29\n}\n\nЧто мы делаем, если нам нужно, чтобы они вызывались последовательно — первый doSomethingUsefulOne, затем doSomethingUsefulTwo, и вычислить сумму их результатов? На практике мы делаем это, если используем результат первой функции, чтобы принять решение о том, нужно ли нам вызывать вторую, или решить, как ее вызывать.\n\nМы используем обычный последовательный вызов, потому что код в корутине, как и в обычном коде, по умолчанию последовательный. Следующий пример демонстрирует это, измеряя общее время, необходимое для выполнения обеих функций приостановки:\n\nimport kotlinx.coroutines.*\nimport kotlin.system.*\n\nfun main() = runBlocking<Unit> {\n    val time = measureTimeMillis {\n        val one = doSomethingUsefulOne()\n        val two = doSomethingUsefulTwo()\n        println(\"The answer is ${one + two}\")\n    }\n    println(\"Completed in $time ms\")\n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // притворимся, что мы делаем что-то полезное здесь\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // притворимся, что мы тоже делаем что-то полезное здесь\n    return 29\n}\n\n\nThe answer is 42\nCompleted in 2017 ms  suspend - это модификатор функции в Kotlin, который указывает, что функция может быть приостановлена (suspended) без блокировки потока исполнения. Он используется в контексте асинхронного программирования с использованием корутин (coroutines).\n\nКогда функция объявляется с модификатором suspend, она может содержать приостанавливающие операции, такие как задержка (delay), ожидание завершения других асинхронных операций или запросы ввода-вывода. Вместо блокировки потока исполнения, когда функция достигает приостановки, она освобождает поток для выполнения других задач, позволяя эффективно использовать ресурсы.\n\nПример использования suspend функции в контексте корутин:\nkotlin\n\nsuspend fun fetchDataFromNetwork() {\n    delay(1000) // Приостановка на 1 секунду без блокировки потока\n    val data = performNetworkRequest() // Асинхронный запрос к сети\n    processNetworkData(data) // Обработка полученных данных\n}\n\nВ этом примере функция fetchDataFromNetwork объявлена с модификатором suspend. Она может содержать операции задержки (delay) и выполнения асинхронных запросов (performNetworkRequest). Когда функция достигает приостановки, она освобождает поток исполнения, позволяя другим задачам выполняться.\n\nДля вызова suspend функции из другой suspend функции или блока корутина, можно использовать ключевое слово suspend перед именем функции:\nkotlin\n\nsuspend fun performAsyncTask() {\n    fetchDataFromNetwork() // Вызов другой suspend функции\n    // ...\n}\n\n// Использование suspend функции в блоке корутина\nGlobalScope.launch {\n    fetchDataFromNetwork()\n    // ...\n}\n\nМодификатор suspend позволяет создавать асинхронный код, который легко читать и писать, без необходимости явно создавать и управлять потоками исполнения. Корутины в Kotlin предоставляют более гибкую и эффективную альтернативу использованию низкоуровневых потоков (Thread) для асинхронного программирования."
  },
  {
    "category": "Kotlin",
    "question": "Что такое sealed class",
    "answer": "Изолированные классы используются для отражения ограниченных иерархий классов, когда значение может иметь тип только из ограниченного набора, и никакой другой. Они являются, по сути, расширением enum-классов: набор значений enum типа также ограничен, но каждая enum-константа существует только в единственном экземпляре, в то время как наследник изолированного класса может иметь множество экземпляров, которые могут нести в себе какое-то состояние"
  },
  {
    "category": "Kotlin",
    "question": "Atomic в Kotlin ",
    "answer": "В Kotlin класс Atomic представляет собой удобную обертку над примитивными типами данных, которая обеспечивает атомарные операции чтения и записи. Он является частью пакета kotlinx.atomicfu, предоставляющего атомарные типы данных для многопоточного программирования.\n\nКлассы Atomic предоставляют методы для обновления значения и выполнения операций в потокобезопасной манере. Они гарантируют, что операции чтения и записи будут выполняться атомарно (в одной непрерывной операции), что делает их безопасными в многопоточной среде.\n\nПримеры классов Atomic в Kotlin:\n\n    AtomicBoolean: Этот класс представляет атомарное значение типа Boolean. Он предоставляет операции чтения и записи значения Boolean в потокобезопасной манере.\n\n    AtomicInt: Этот класс представляет атомарное значение типа Int. Он предоставляет операции чтения и записи значения Int, а также операции инкремента, декремента и другие атомарные операции.\n\n    AtomicReference: Этот класс представляет атомарную ссылку на объект. Он позволяет безопасно обновлять ссылки на объекты в многопоточной среде.\n\nПример использования AtomicInt:\nkotlin\n\nimport kotlinx.atomicfu.AtomicInt\n\nval counter = AtomicInt(0)\n\nfun incrementCounter() {\n    counter.incrementAndGet()\n}\n\nfun main() {\n    for (i in 1..10) {\n        Thread {\n            incrementCounter()\n            println(\"Counter: ${counter.value}\")\n        }.start()\n    }\n}\n\nВ приведенном примере AtomicInt используется для безопасного инкремента счетчика counter из нескольких потоков. Метод incrementAndGet() увеличивает значение счетчика на единицу и возвращает новое значение.\n\nКлассы Atomic в Kotlin предоставляют мощные инструменты для разработки потокобезопасных приложений. Они являются надежным способом обработки общих данных в многопоточной среде, предотвращая состояние гонки и проблемы синхронизации."
  },
  {
    "category": "RxJava",
    "question": "«hot» vs «cold» observable",
    "answer": "В RxJava есть «горячие» и «холодные» Observables. Горячий Observable порождает данные постоянно, даже если на него никто не подписан. Холодный Observable, соответственно, порождает данные только если у него есть хотя бы один подписчик. \n\nСуществует два способа трансформировать cold observable в hot.\n\nПервый – это использование методов publish() и connect().\nМетод publish() создает из observable объект типа ConnectableObservable. ConnectableObservable не начинает рассылать элементы, когда на него подписываются. Рассылка запускается после вызова метода connect(). Когда вызван метод connect(), начинается эмитинг элементов независимо от того, есть ли подписчики.\n\nВторой способ – обернуть observable в subject, как показано на картинке. В этом случае эмитинг элементов оригинального observable стартует, когда на него подписывается subject. А subject, являясь hot observable, рассылает элементы независимо от наличия подписчиков.\n\nЭто можно сделать комбинацией методов replay() и autoConnect(0).\n\nМетод replay() создает объект ConnectableObservable, который кэширует все элементы, отправляемые оригинальным hot observable.\n\nКак было описано ранее, ConnectableObservable начинает эмитить элементы, когда на нем вызывается метод connect().\n\nЧтобы получить поведение обычного cold observable, на ConnectableObservable вызывается метод autoConnect(numberOfSubscribers: Int). Этот метод принимает параметром переменную типа Int, которая задает количество подписчиков, необходимых для вызова connect(). Если параметром передано неположительное число, то connect() вызывается сразу.\n\nВ результате последовательного вызова replay() и autoConnect(0) создается observable, который эмитит все закэшированные элементы при вызове на нем subscribe(), т.е. ведет себя как cold observabl"
  },
  {
    "category": "RxJava",
    "question": "Операторы: map, flatMap, concatMap, switchMap — для чего и в чем отличия",
    "answer": "Map к каждому излучаемому элементу применяет функцию и возвращает ее результат.\n\nFlatMap так же применяет функцию к каждому излучаемому элементу, но эта функция функция возвращает тип Observable. Т.е. 1 излучаемый элемент может через flatMap породить множество излучаемых элементов или не одного.\n\nSwitchMap Как flatMap, но он будет испускать только элементы из нового наблюдаемого, пока очередное новое событие не будет испущено из источника наблюдаемого.\n\nConcatMap также подписывается на внутренний Observable. Но в отличие от switchMap, который отписывается от текущего Observable, если появляется новый Observable, concatMap не будет подписываться на следующий Observable, пока не завершится текущий. \n\n\nflatMap() разделяет rx-стрим на несколько промежуточных стримов, назовем их [A, B, C], и затем соединяет результат в один стрим. Элементы промежуточных стримов передаются напрямую в конечный стрим без гарантии сохранения порядка, в котором созданы A, B и C. Конечный результат может быть таким: [C1, A1, A2, B1, C2, A3, B2, B3, C3].\n\nconcatMap() работает похожим на flatMap() образом, но сохраняет порядок промежуточных стримов. Результат будет: [A1, A2, A3, B1, B2, B3, C1, C2, C3].\n\nswitchMap() похож на flatMap() и также как concatMap() сохраняет порядок. Но при использовании switchMap() каждый предыдущий промежуточный стрим останавливается в тот момент, когда стартует следующий. Результат может выглядеть так: [A1, A2, B1 C1, C2, C3]."
  },
  {
    "category": "RxJava",
    "question": "Операторы: from, just — для чего и в чем отличия",
    "answer": "Вы можете превратить любые входные данные в Observable при помощи create. Для распространенных типов данных, существуют уже готовые методы(from), призванные облегчить этот процесс.\n\njust создает Observable, который выдаст определенное заранее множество объектов, после чего завершится."
  },
  {
    "category": "RxJava",
    "question": "Операторы: doOn…Next, …Error и так далее — для чего",
    "answer": "doOnNext()позволяет нам добавить некоторое дополнительное действие, происходящее всякий раз, как мы получаем новый элемент данных.\n\ndoOnError не обрабатывает ошибку, в том смысле, что она ее не потребляет. Он просто что-то делает с нею, например, записывает её. (То же самое верно для doOnNext — он также не потребляет элемент, и элемент все еще заканчивается в onNext Subscriber).\n\nОшибка(Или другой объект для других методов doOn) по-прежнему отправляется по цепочке и все равно заканчивается на onError(OnNext, OnCompleted) вашего Subscriber."
  },
  {
    "category": "RxJava",
    "question": "Observable vs Flowable",
    "answer": "В Rx 2.0 Observable — класс без обработки проблемы backpressure, а новый Flowable был наделен поддержкой обработки backpressure из коробки}"
  },
  {
    "category": "RxJava",
    "question": "Как работать с Backpressure в RxJava?",
    "answer": "Backpressure – это ситуация, когда Rx-продюсер производит больше элементов, чем может обработать консьюмер.\nНапример Observable создает 1000 элементов в секунду, а Observer обрабатывает 1 элемент в секунду. Observable имеет бесконечный буфер, в который будут добавляться элементы до тех пор, пока не случится OutOfMemoryError.\n\nВ случаях когда возможна ситуация backpressure, следует использовать Flowable в качестве Rx-стрима.\nFlowable можно создать из Observable методом toFlowable(), который принимает объект типа BackpressureStrategy как параметр.\nBackpressureStrategy – это enum, который задает стратегию обработки backpressure. Значения BackpressureStrategy:\n\n• MISSING. Продюсер не имеет стратегию работы с backpressure. В этом случае консьюмер должен решать проблему переполнения. Эта конфигурация полезна в случае, когда обработка backpressure задается операторами onBackpressure...().\nЕсли backpressure не обрабатывается, то будет брошено исключение MissingBackpressureException.\n\n• ERROR. В случае backpressure бросается исключение MissingBackpressureException.\n\n• BUFFER. Все элементы добавляются в буфер, пока не будут обработаны консьюмером.\n\n• DROP. Все новые элементы, которые консьюмер не успевает обработать, удаляются и не доставляются консьюмеру.\n\n• LATEST. Стратегия противоположная Drop. Консьюмер получает только самый последний элемент, созданный продюсером, когда освобождается."
  },
  {
    "category": "RxJava",
    "question": "Flowable: стратегии работы с backpressure",
    "answer": "BackpressureOverflowStrategy — это enum, который предлагает 3 статических поля с реализациями, представляющими типичные действия при:\n\nERROR — это дефолтное поведение при всех предыдущих перегрузках, выбрасывающее BufferOverflowException.\n\nDROP_OLDES — по сути, это означает обновление буфера, при его переполнении. Все старые значения выбрасываются и буфер наполняется новым стеком.\n\nDROP_LATEST — немного иное поведение, отличающееся тем, что, если произойдет переполнение, текущее значение будет просто проигнорировано, и только старые значения будут доставлены после запросов нисходящего потока"
  },
  {
    "category": "RxJava",
    "question": "Какие виды стримов существуют в RxJava?",
    "answer": "Observable – представляет собой стрим объектов. Подписчики на Observable имеют коллбэки onNext(value), onComplete(), onError(throwable).\nonNext() может не вызываться, или вызываться произвольное количество раз.\nПри завершении стрима вызывается onComplete() или onError().\n\nSingle – отправляет объект, который принимается в коллбэке onSuccess(value), или бросает исключение в коллбэк onError(throwable) в случае ошибки.\n\nCompletable – не возвращает никакого значения. На подписчиках вызывается onComplete() при удачном завершении или onError(throwable) в случае ошибки.\n\nMaybe – может отработать как Single или как Completable. На подписчиках вызывается один из трех коллбэков: onSuccess(value), onComplete() без какого-либо значения, или onError(throwable). Каждый из коллбэков может быть вызван один раз или не вызван вообще.\n\nFlowable – работает как Observable, но поддерживает backpressure по умолчанию."
  },
  {
    "category": "RxJava",
    "question": "Операторы: defer, groupBy, debounce, combineLatest, withLatestFrom, merge, concat, zip, switchOnNext — как работают",
    "answer": "defer не создает новый Observable, но позволяет определить каким образом Observable будет создан при появлении подписчиков. Подумайте, как бы вы создали Observable который будет выдавать текущее время? Так как значение только одно, похоже, что здесь нам может помочь just.\n\ngroupBy разделяет Observable на множество других Observable, из которых каждая испускает подмножество элементов из исходной Observable.\n\ndebounce позволяет Observable испустить следующий элемент только если прошло определённое количество времени после предыдущего элемента.\n\ncombineLatest — когда элемент испускается одним из двух Observables, объединяет последний элемент, испускаемый каждым Observable с помощью указанной функции, и создавать элементы на основе результатов этой функции. CombineLatest испускает элемент всякий раз, когда какой-либо из исходных Observables испускает элемент (при условии, что каждый из исходных Observables испускает хотя бы один элемент). Когда какой-либо из исходных Observables испускает элемент, CombineLatest объединяет самые последние испущенные элементы из каждого из других исходных Observable, используя предоставленную вами функцию, и выдает возвращаемое значение из этой функции.\n\nwithLatestFrom — Как только Observable1 генерирует элемент проверяется сгенерирован ли хоть один элемент в Observable2, если да, то берутся последние элементы из Observable1 и Observable2 и используются в качестве аргументов для переданной функции, результат которой генерируется в качестве элемента.\n\nmerge — Объединяет несколько Observable в одну, испуская элементы всех объединённых Observable.concat — Объединяет несколько Observable в одну, испуская элементы последующей Observable после завершения предыдущей.\n\nzip — Объединяет несколько Observable в одну, используя функцию, которая формирует испускаемый элемент на основании элементов, полученных по одному от каждой из объединённых Observable.\n\nswitchOnNext — Преобразует Observable, которая испускает другие Observable, в Observable, которая испускает элементы, испущенные самой последней из этих Observable."
  },
  {
    "category": "RxJava",
    "question": "Операторы: observeOn(), subscribeOn() — как работают",
    "answer": "Оператор subscribeOn() будет иметь тот же эффект независимо от того, где вы поместите его в цепочку observable; однако вы не можете использовать несколько операторов subscribeOn() в одной цепочке. Если вы включили в цепочку более одного subscribeOn(), ваша цепочка будет использовать только subscribeOn(), который ближе всего к observable источнику.\n\nВ отличие от subscribeOn(), имеет значение, куда в цепочку вы помещаете функцию observeOn(), так как этот оператор только изменяет поток, который используется observables, которые следуют ниже. Например, если вы вставляете в свою цепочку следующий код, то каждый observable, который появляется в цепочке с этого момента, будет использовать новый поток. Эта цепочка будет продолжать работать в новом потоке, пока не встретится другой оператор observOn(), после чего она переключится на поток, указанный этим оператором. Вы можете управлять потоком, куда конкретные observables отправляют свои уведомления, путём вставки в вашу цепочку нескольких операторов observeOn()"
  },
  {
    "category": "RxJava",
    "question": "Типы Subjects",
    "answer": "PublishSubject – самая простая реализация Subject. Когда данные передаются в PublishSubject, он выдает их всем подписчикам, которые подписаны на него в данный момент.\n\nReplaySubject имеет специальную возможность кэшировать все поступившие в него данные. Когда у него появляется новый подписчик, последовательность выдана ему начиная с начала. Все последующие поступившие данные будут выдаваться подписчикам как обычно.\nКэшировать всё подряд не всегда лучшая идея, так как последовательности могут быть длинными или даже бесконечными. Фабричный метод ReplaySubject.createWithSize ограничивает размер буфера, а ReplaySubject.createWithTime время, которое объекты будут оставаться в кеше.\n\nBehaviorSubject хранит только последнее значение. Это то же самое, что и ReplaySubject, но с буфером размером 1. Во время создания ему может быть присвоено начальное значение, таким образом гарантируя, что данные всегда будут доступны новым подписчикам.\n\nAsyncSubject также хранит последнее значение. Разница в том, что он не выдает данных до тех пока не завершится последовательность. Его используют, когда нужно выдать единое значение и тут же завершиться."
  },
  {
    "category": "RxJava",
    "question": "Типы Processors",
    "answer": "ReplayProcessor — Воспроизводит события для подписчиков.\n\nPublishProcessor — передает все последующие Observable элементы своим текущим подписчикам.\n\nBehaviorProcessor — испускает самый последний Observable элемент и все последующие Observable элементы для каждого подписанного подписчика."
  },
  {
    "category": "RxJava",
    "question": "Виды Schedulers",
    "answer": "Schedulers.io() — Этот планировщик основывается на неограниченном пуле потоков и используется для интенсивной работы с вводом-выводом, например, доступ к файловой системе, выполнение сетевых вызовов, доступ к базе данных и так далее. Количество потоков в этом планировщике неограниченно и может расти по мере необходимости.\n\nSchedulers.computation() — Этот планировщик используется для выполнения работы, высоко нагружающей ЦП, такой как обработка больших объемов данных, изображений и так далее. Планировщик основывается на ограниченном пуле потоков с размером в количество доступных процессоров. Так как этот планировщик подходит только для интенсивной работы с ЦП — количество его потоков ограничено. Сделано это для того, чтобы потоки не конкурировали за процессорное время и не простаивали.\n\nSchedulers.newThread() — Этот планировщик создает совершенно новый поток при каждом вызове. В данном случае использование пула потоков не принесет никакой выгоды. Потоки очень затратно создавать и уничтожать. Вы должны быть осторожны и не злоупотреблять чрезмерным созданием потоков, так как это может привести в замедлению работы системы и переполнению памяти. Новый поток будет создаваться для обработки каждого элемента, полученного из observable-источника. В идеале вы должны использовать этот планировщик довольно редко, в основном для выведения в отдельный поток долго работающих частей программы.\n\nSchedulers.single() — Этот планировщик основывается на единственном потоке, который используется для последовательного выполнения задач. Он может быть очень полезен, когда у вас есть набор фоновых заданий в разных местах вашего приложения, но нельзя допустить одновременного выполнения более чем одного из этих заданий.\n\nSchedulers.from(Executor executor) — Этот планировщик будет основываться на вашем собственном Executor. Может возникнуть ситуация, в которой необходимо будет выполнять определенные задачи в планировщике на основании собственной логики распределения потоков. Допустим, вы хотите ограничить число параллельных сетевых вызовов, которые делает ваше приложение. Можно создать собственный планировщик, который будет работать на базе ограниченного в размерах пула потоков (Scheduler.from(Executors.newFixedThreadPool(n))) и использовать его во всех местах, связанных с сетевыми вызовами.\n\nAndroidSchedulers.mainThread() — Это специальный планировщик, который недоступен в библиотеке RxJava. Необходимо использовать расширяющую библиотеку RxAndroid для доступа к этому планировщику. Этот планировщик полезен в Android приложениях для выполнения действий в потоке пользовательского интерфейса. По умолчанию этот планировщик ставит задания в очередь в Looper, связанный с основным потоком, но есть возможность переопределения: AndroidSchedulers.from(Looper looper)"
  },
  {
    "category": "RxJava",
    "question": "Как работает связка операторов publish и connect",
    "answer": "Когда применен оператор publish(), то Observable трансформируется в Connectable Observable. Connectable Observable похож на обычный Observable за исключением одного момента. Он начинает производить элементы не тогда, когда на него подписываются, а только тогда, когда на нем вызван оператор connect(). share() — это обертка над publish().refcount().\n\nrefcount() вызывает connect() автоматически, когда подписывается первый Observer, так что нет нужды делать это самостоятельно. publish().refcount()/share() следит за том, как много Observer’ов подписано на Observable и не отключает первых от последнего до тех пор, пока существует хотя бы один подписчик. Другими словами, когда счетчик подписчиков падает до нуля, Observable «умирает» и перестает производить какие-либо элементы."
  },
  {
    "category": "RxJava",
    "question": "ConnectableObservable в RxJava",
    "answer": "ConnectableObservable в RxJava представляет собой особый тип Observable, который не начинает испускать элементы до тех пор, пока не будет вызван метод connect().\n\nОбычный Observable начинает испускать элементы в момент подписки на него. Каждый новый подписчик будет получать элементы с начала последовательности. Однако ConnectableObservable позволяет управлять моментом начала испускания элементов и обеспечивает возможность подписки нескольких наблюдателей на один и тот же поток испускания элементов.\n\nВот пример использования ConnectableObservable в RxJava:\njava\n\nObservable<Integer> observable = Observable.range(1, 5)\n        .publish(); // Создание ConnectableObservable\n\nobservable.subscribe(i -> System.out.println(\"Observer 1: \" + i));\n\n// На этом этапе элементы еще не испускаются\n\nobservable.connect(); // Запуск испускания элементов\n\nobservable.subscribe(i -> System.out.println(\"Observer 2: \" + i));\n\n// Вывод:\n// Observer 1: 1\n// Observer 1: 2\n// Observer 1: 3\n// Observer 1: 4\n// Observer 1: 5\n// Observer 2: 1\n// Observer 2: 2\n// Observer 2: 3\n// Observer 2: 4\n// Observer 2: 5\n\nВ этом примере мы создаем ConnectableObservable из последовательности чисел от 1 до 5 с помощью метода publish(). Затем мы подписываемся на него первым наблюдателем (Observer 1), но элементы еще не испускаются. После этого мы вызываем метод connect(), чтобы начать испускание элементов. Затем мы подписываемся на тот же ConnectableObservable вторым наблюдателем (Observer 2), и оба наблюдателя получают все элементы последовательности.\n\nConnectableObservable также предоставляет методы для управления подпиской, такие как refCount(), который автоматически подключает и отключает поток испускания элементов в зависимости от наличия подписчиков.\n\nConnectableObservable полезен в ситуациях, когда требуется контролировать момент начала испускания элементов или иметь несколько независимых подписчиков на один поток данных."
  },
  {
    "category": "Android",
    "question": "SSLPinnig в Android",
    "answer": "SSLPinning (SSL-проверка) - это механизм безопасности, который позволяет приложению Android проверять подлинность сертификата сервера при установлении защищенного SSL/TLS соединения. Он помогает защитить приложение от атак, связанных с использованием недоверенных сертификатов или сертификатов, выданных злоумышленниками.\n\nПри установке SSL/TLS соединения с сервером, сервер предоставляет клиенту свой сертификат. Обычно клиент, например, веб-браузер, проверяет подлинность сертификата, сравнивая его с доверенными корневыми сертификатами, хранящимися на устройстве. Однако, SSLPinning позволяет приложению Android проверять сертификаты более строго, игнорируя доверенные корневые сертификаты и доверяя только конкретным сертификатам, которые были заранее встроены в приложение.\n\nВот пример использования SSLPinning в Android с использованием библиотеки OkHttp:\n\n    Добавьте зависимость OkHttp в файл build.gradle вашего проекта:\n\ngroovy\n\ndependencies {\n    implementation 'com.squareup.okhttp3:okhttp:номер версии'\n}\n\n    Создайте файл с сертификатами, содержащими публичные ключи сервера. Обычно это файлы с расширением .cer или .pem.\n\n    В коде приложения используйте OkHttp для настройки SSLPinning:\n\njava\n\n// Создание SSLContext с использованием сертификатов\nSSLContext sslContext = SSLContext.getInstance(\"TLS\");\nCertificateFactory certificateFactory = CertificateFactory.getInstance(\"X.509\");\n\n// Загрузка сертификатов из файлов\nInputStream certInputStream = context.getAssets().open(\"certificate.cer\");\nCertificate certificate = certificateFactory.generateCertificate(certInputStream);\n\n// Инициализация KeyStore и добавление сертификатов\nKeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\nkeyStore.load(null, null);\nkeyStore.setCertificateEntry(\"my_certificate\", certificate);\n\n// Инициализация TrustManagerFactory с использованием KeyStore\nTrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(\n        TrustManagerFactory.getDefaultAlgorithm());\ntrustManagerFactory.init(keyStore);\n\n// Инициализация SSLContext с использованием TrustManagerFactory\nsslContext.init(null, trustManagerFactory.getTrustManagers(), null);\n\n// Создание клиента OkHttp с настройками SSLPinning\nOkHttpClient client = new OkHttpClient.Builder()\n        .sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) trustManagerFactory.getTrustManagers()[0])\n        .build();\n\n// Использование клиента OkHttp для отправки запросов\nRequest request = new Request.Builder()\n        .url(\"https://example.com\")\n        .build();\n\nResponse response = client.newCall(request).execute();\n\nВ этом примере мы используем OkHttp для настройки SSLPinning. Мы загружаем сертификат из файла с помощью CertificateFactory и добавляем его в KeyStore. Затем мы инициализируем SSLContext с использованием TrustManagerFactory, который использует KeyStore. Наконец, мы создаем клиент OkHttp с настройками SSLPinning, указывая SSLContext и TrustManager.\n\nТаким образом, приложение будет проверять подлинность сертификата сервера, используя только заранее встроенные сертификаты, игнорируя доверенные корневые сертификаты устройства. Это повышает безопасность приложения и защищает его от атак, связанных с подменой сертификатов."
  },
  {
    "category": "Android",
    "question": "Applink в Android",
    "answer": "App Linking (Applink) - это механизм в Android, который позволяет приложению устанавливать ассоциацию с определенными URL-схемами или веб-ссылками. Это позволяет приложению быть вызванным и открытым, когда пользователь нажимает на соответствующую ссылку внутри другого приложения или веб-страницы.\n\nЧтобы настроить App Linking в Android, необходимо выполнить следующие шаги:\n\n    Добавьте фильтр намерений (intent filter) в манифест вашего приложения для обработки определенных URL-схем или веб-ссылок. Например, если ваше приложение должно быть вызвано по ссылке \"https://example.com/myapp\", добавьте следующий код внутри блока <activity> в вашем манифесте:\n\nxml\n\n<intent-filter>\n    <action android:name=\"android.intent.action.VIEW\" />\n    <category android:name=\"android.intent.category.DEFAULT\" />\n    <category android:name=\"android.intent.category.BROWSABLE\" />\n\n    <data android:scheme=\"https\" android:host=\"example.com\" android:pathPrefix=\"/myapp\" />\n</intent-filter>\n\nВ данном примере мы указываем, что приложение должно быть вызвано, когда пользователь переходит по ссылке, начинающейся с \"https://example.com/myapp\".\n\n    Добавьте обработчик намерения (intent handler) в активность вашего приложения, чтобы выполнить нужные действия при вызове приложения через App Linking. Например, вы можете открыть определенный экран или обработать данные, переданные через ссылку. Добавьте следующий код внутри блока <activity> в вашем манифесте:\n\nxml\n\n<intent-filter>\n    ...\n    <action android:name=\"android.intent.action.VIEW\" />\n    ...\n</intent-filter>\n\nВ этом примере мы добавляем обработчик намерения для действия android.intent.action.VIEW, чтобы перехватить вызовы приложения через App Linking.\n\n    Обработайте данные, переданные через ссылку, в коде вашей активности. Чтобы получить переданные параметры, вы можете использовать метод getIntent().getData() в вашей активности. Например:\n\njava\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n\n    Intent intent = getIntent();\n    Uri data = intent.getData();\n    if (data != null) {\n        // Обработка переданных данных\n        String path = data.getPath();\n        // ...\n    }\n}\n\nВ этом примере мы получаем ссылку через getIntent().getData() и можем извлечь нужные параметры, такие как путь или запросы.\n\nПосле выполнения этих шагов ваше приложение будет связано с указанными URL-схемами или веб-ссылками. Когда пользователь нажимает на соответствующую ссылку в другом приложении или веб-странице, Android будет открывать ваше приложение и передавать данные, если они были указаны в ссылке. Это позволяет реализовать глубокую интеграцию между приложениями и обеспечить более плавный пользовательский опыт."
  },
  {
    "category": "Android",
    "question": "IPC Межпроцессорное взаимодействие",
    "answer": "Межпроцессорное взаимодействие (IPC, Inter-Process Communication) - это механизм обмена данными и синхронизации между двумя или более процессами, работающими на одной или разных машинах. IPC позволяет процессам взаимодействовать, обмениваться информацией и координировать свою работу.\n\nСуществует несколько распространенных методов межпроцессорного взаимодействия:\n\n    Пайпы (Pipes): Пайпы представляют собой однонаправленные каналы, которые связывают вывод одного процесса с вводом другого. Один процесс записывает данные в пайп, а другой процесс считывает их оттуда. Пайпы часто используются для взаимодействия между родственными процессами.\n\n    Сокеты (Sockets): Сокеты представляют собой сетевые конечные точки, используемые для обмена данными между процессами, работающими на разных машинах. С использованием сокетов можно реализовать клиент-серверное взаимодействие и обмен сообщениями по протоколам TCP или UDP.\n\n    Разделяемая память (Shared Memory): Разделяемая память позволяет нескольким процессам обращаться к одному и тому же участку памяти. Это позволяет процессам обмениваться данными очень эффективно, так как данные не копируются, а сразу доступны для чтения и записи.\n\n    Очереди сообщений (Message Queues): Очереди сообщений предоставляют механизм для передачи сообщений между процессами. Один процесс может помещать сообщения в очередь, а другой процесс может их извлекать. Очереди сообщений обеспечивают асинхронное взаимодействие и могут быть использованы для обработки событий или реализации паттерна \"издатель-подписчик\".\n\n    Разделы памяти (Memory-mapped Files): Разделы памяти позволяют процессам отображать один и тот же файл в их адресное пространство памяти. Это позволяет процессам обмениваться данными, используя файл как общий буфер.\n\n    RPC (Remote Procedure Call): RPC представляет собой механизм вызова удаленных процедур. Он позволяет процессам вызывать функции или методы на удаленной машине, как если бы они были локальными. RPC абстрагирует сложности сетевого взаимодействия и обеспечивает прозрачную передачу данных и вызовы удаленных процедур.\n\nОдним из выборов метода IPC зависит от требований конкретной задачи, архитектуры приложения и особенностей операционной системы или среды выполнения. Каждый метод имеет свои преимущества и ограничения, и выбор наиболее подходящего метода важен для эффективного межпроцессорного взаимодействия."
  },
  {
    "category": "Android",
    "question": "Как сделать 2 иконки у одного приложения запускающие разные Activity",
    "answer": "В Android нельзя напрямую создать две иконки для запуска разных активностей в рамках одного приложения. Иконка приложения представляет его основную точку входа, и она связана с одной активностью, указанной в манифесте с фильтром намерений, содержащим действие android.intent.action.MAIN и категорию android.intent.category.LAUNCHER.\n\nОднако вы можете создать альтернативные ярлыки для запуска разных активностей внутри приложения. Вот как это можно сделать:\n\n    Создайте новый активити, которую вы хотите запустить с помощью второй иконки.\n    В манифесте вашего приложения добавьте новую активность и соответствующий фильтр намерений. Например:\n\nxml\n\n<activity\n    android:name=\".SecondActivity\">\n    <intent-filter>\n        <action android:name=\"android.intent.action.MAIN\" />\n        <category android:name=\"android.intent.category.DEFAULT\" />\n    </intent-filter>\n</activity>\n\n    Создайте новый элемент в файле ресурсов res/xml под названием shortcuts.xml (если его нет, создайте новый файл с этим именем). В этом файле определите два ярлыка для двух активностей с различными иконками. Например:\n\nxml\n\n<shortcuts xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <shortcut\n        android:shortcutId=\"shortcut1\"\n        android:enabled=\"true\"\n        android:icon=\"@drawable/icon1\"\n        android:shortcutShortLabel=\"@string/shortcut_label1\"\n        android:shortcutLongLabel=\"@string/shortcut_label1\"\n        android:shortcutDisabledMessage=\"@string/shortcut_disabled_message1\"\n        android:targetActivity=\".MainActivity\">\n        <intent\n            android:action=\"android.intent.action.VIEW\" />\n    </shortcut>\n    \n    <shortcut\n        android:shortcutId=\"shortcut2\"\n        android:enabled=\"true\"\n        android:icon=\"@drawable/icon2\"\n        android:shortcutShortLabel=\"@string/shortcut_label2\"\n        android:shortcutLongLabel=\"@string/shortcut_label2\"\n        android:shortcutDisabledMessage=\"@string/shortcut_disabled_message2\"\n        android:targetActivity=\".SecondActivity\">\n        <intent\n            android:action=\"android.intent.action.VIEW\" />\n    </shortcut>\n</shortcuts>\n\n    В манифесте вашего приложения добавьте следующую конфигурацию для вашей MainActivity, чтобы указать, что приложение поддерживает ярлыки:\n\nxml\n\n<meta-data\n    android:name=\"android.app.shortcuts\"\n    android:resource=\"@xml/shortcuts\" />\n\n    В вашей активности MainActivity вы можете обработать запуск приложения через ярлык, используя метод getIntent().getAction(). Например:\n\njava\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n\n    String action = getIntent().getAction();\n    if (action != null && action.equals(Intent.ACTION_VIEW)) {\n        // Обработка запуска приложения через ярлык\n        // ...\n    }\n}\n\nТеперь у вас будет основная иконка, которая будет запускать MainActivity, а также альтернативный ярлык, который будет запускать SecondActivity с отдельной иконкой."
  },
  {
    "category": "Android",
    "question": "Launch Modes for activity (standart, singleTop, singleTask, singleInstance)",
    "answer": "Атрибут launchMode указывает инструкцию по запуску операции в задаче. Существует четыре различных режима запуска, которые вы можете назначить атрибуту launchMode:\n\n1.“standard” — Режим по умолчанию. Система создает новый экземпляр операции в задаче, из которой она была запущена, и направляет ему намерение. Может быть создано несколько экземпляров операции, каждый экземпляр может принадлежать различным задачам, и одна задача может содержать несколько экземпляров.\n\n2. “singleTop” — Если экземпляр операции уже существует на вершине текущей задачи, система направляет намерение в этот экземпляр путем вызова его метода onNewIntent(), а не путем создания нового экземпляра операции. Может быть создано несколько экземпляров операции, каждый экземпляр может принадлежать различным задачам, и одна задача может содержать несколько экземпляров (но только если операция на вершине стека переходов назад не является существующим экземпляром операции).Предположим, что стек переходов назад задачи состоит из корневой операции A с операциями B, C и D на вершине (стек имеет вид A-B-C-D и D находится на вершине). Поступает намерение для операции типа D. Если D имеет режим запуска “standard” по умолчанию, запускается новый экземпляр класса и стек принимает вид A-B-C-D-D. Однако, если D имеет режим запуска “singleTop”, существующий экземпляр D получает намерение через onNewIntent(), так как этот экземпляр находится на вершине стека — стек сохраняет вид A-B-C-D. Однако, если поступает намерение для операции типа B, тогда в стек добавляется новый экземпляр B, даже если он имеет режим запуска “singleTop”.\n\n3. “singleTask” — Система создает новую задачу и создает экземпляр операции в корне новой задачи. Однако, если экземпляр операции уже существует в отдельной задаче, система направляет намерение в существующий экземпляр путем вызова его метода onNewIntent(), а не путем создания нового экземпляра. Одновременно может существовать только один экземпляр операции.\n\n4. “singleInstance” То же, что и “singleTask”, но при этом система не запускает никаких других операций в задаче, содержащей этот экземпляр. Операция всегда является единственным членом своей задачи; любые операции, запущенные этой операцией, открываются в отдельной задаче"
  },
  {
    "category": "Android",
    "question": "Intent flags для запуска activity (FLAG_ACTIVITY_NEW_TASK, FLAG_ACTIVITY_SINGLE_TOP, FLAG_ACTIVITY_CLEAR_TOP)",
    "answer": "При запуске операции вы можете изменить связывание операции с ее задачей по умолчанию путем включения флагов в намерение, которое доставляется в startActivity(). Для изменения поведения по умолчанию вы можете использовать следующие флаги:\n\nFLAG_ACTIVITY_NEW_TASK — Запуск операции в новой задаче. Если задача уже работает для операции, которую вы запускаете сейчас, эта задача переводится на передний план, ее последнее состояние восстанавливается, и операция получает новое намерение в onNewIntent().\n\nFLAG_ACTIVITY_SINGLE_TOP — Если запускаемая операция является текущей операцией (находится на вершине стека переходов назад), тогда вызов в onNewIntent() получает существующий экземпляр, без создания нового экземпляра операции.\n\nFLAG_ACTIVITY_CLEAR_TOP — Если запускаемая операция уже работает в текущей задаче, тогда вместо запуска нового экземпляра этой операции уничтожаются все другие операции, расположенные в стеке выше нее , и это намерение доставляется в возобновленный экземпляр этой операции (которая теперь находится на вершине стека) посредством onNewIntent())"
  },
  {
    "category": "Android",
    "question": "Из каких базовых компонент состоит приложение?",
    "answer": "Базовые компоненты андроид приложения: Activity, Service, BroadcastReceiver, ContentProvider. Каждый из базовых компонент объявляется в андроид манифесте и может являться точкой входа в приложение.\n\nActivity представляет UI и функциональность, видимые пользователю.\n\nService используется для исполнения долгих операций, которые не требуют взаимодействия с пользователем.\n\nBroadcastReceiver принимает и обрабатывает броадкаст ивенты, отправленные внутри приложения или из других приложений.\n\nContentProvider используется для обмена данными с другими приложениями.,"
  },
  {
    "category": "Android",
    "question": "Jetpack DataStore",
    "answer": "Jetpack DataStore - это компонент библиотеки Jetpack, предоставляющий удобное API для сохранения и чтения данных приложения на уровне хранилища данных, таких как SharedPreferences или файлы.\n\nJetpack DataStore предоставляет простой и декларативный способ работы с данными, основанный на использовании ключей и значений. Он позволяет сохранять и извлекать данные асинхронно, обеспечивая безопасность и консистентность данных. DataStore предоставляет два основных варианта хранения данных:\n\n    Preferences DataStore: Это замена классическим SharedPreferences. Preferences DataStore позволяет сохранять и читать данные в виде ключ-значение. Он предоставляет типобезопасное API для работы с данными и автоматическую обработку изменений.\n\n    Proto DataStore: Прото-хранилище позволяет сохранять и читать данные в формате Protocol Buffers. Прото-хранилище особенно полезно для работы с сложными структурами данных, такими как списки или объекты с вложенными полями.\n\nJetpack DataStore обеспечивает сохранение данных в асинхронном режиме, что делает его подходящим для работы с большими объемами данных или операциями, которые могут занять продолжительное время. Он также предлагает возможности наблюдения за изменениями данных, что позволяет вам реагировать на изменения в реальном времени.\n\nDataStore интегрируется хорошо с другими компонентами Jetpack, такими как ViewModel и LiveData, что облегчает управление и обновление данных в вашем приложении.\n\nJetpack DataStore является более гибкой и мощной альтернативой классическим SharedPreferences, предоставляя удобные средства для сохранения и чтения данных приложения. Он помогает создавать надежные и эффективные приложения, основанные на сохранении и управлении данными."
  },
  {
    "category": "Android",
    "question": "Почему нельзя обновить View не с IU потока ?",
    "answer": "Обновление View должно выполняться из основного пользовательского интерфейсного (UI) потока в Android. Это обусловлено следующими причинами:\n\n    Потокобезопасность: Android UI фреймворк не является потокобезопасным, то есть большинство операций, связанных с UI, должны выполняться только из основного UI потока. Если попытаться обновить View из другого потока, это может привести к состоянию гонки (race condition) или другим проблемам синхронизации, которые могут вызывать непредсказуемые ошибки и некорректное отображение пользовательского интерфейса.\n\n    Обновление UI: Основной UI поток в Android отвечает за обновление пользовательского интерфейса и отрисовку View. Если обновление UI происходит из другого потока, это может нарушить правильный порядок обновления и привести к неконсистентному состоянию пользовательского интерфейса.\n\n    Пользовательский опыт: Обновление UI из других потоков может замедлить отрисовку пользовательского интерфейса и привести к задержкам и нереагирующему пользовательскому опыту. Основной UI поток предназначен для быстрой отрисовки и отзывчивости пользовательского интерфейса, поэтому рекомендуется минимизировать операции, которые блокируют его выполнение.\n\nДля взаимодействия с UI из других потоков в Android предоставляются различные механизмы, такие как Handler, AsyncTask, RxJava, Kotlin Coroutines и т.д. Они позволяют выполнить операции в фоновом потоке и обновить UI из основного UI потока с помощью соответствующих механизмов синхронизации.\n\nИспользуя эти механизмы, можно безопасно выполнять длительные операции в фоновом потоке и обновлять соответствующие View из основного UI потока, чтобы обеспечить гладкую и отзывчивую работу пользовательского интерфейса."
  },
  {
    "category": "Android",
    "question": "Что такое и зачем нужен Service? Какие бывают виды сервисов?",
    "answer": "Service – это компонент приложения, который используется для выполнения долгих фоновых операций без взаимодействия с пользователем.\nЛюбой компонент приложения может запустить сервис, который продолжит работу, даже если пользователь перейдет в другое приложение.\nПримеры использования сервисов: проигрывание музыки, трекинг локации водителя в приложении такси, загрузка файла из сети.\n\nСервисы делятся на два вида по способу использования: Started и Bound, и на два вида по способу взаимодействия с пользователем: Background и Foreground.\nКогда спрашивают о видах сервисов обычно имеют в виду способ использования.\n\nStarted Service Запускается методом startService(Intent intent). Intent должен быть явным (explicit), это значит, что при создании объекта Intent было передано имя класса сервиса.\nПосле запуска сервиса вызывается метод onStartCommand().\nОстановить сервис можно вызовом метода stopSelf() из самого сервиса или методом stopService() из другого компонента.\n\nBound Service привязывается к компоненту вызовом метода bindService(Intent service, ServiceConnection serviceConnection, int flags).\nАргумент serviceConnection используется для взаимодействия с привязанным сервисом. Сервис стартует после вызова bindService(), если аргумент flags имеет значение BIND_AUTO_CREATE.\nПосле вызова bindService() у сервиса вызывается метод onBind().\nДля отвязывания компонента от сервиса используется метод unbindService(). У сервиса вызывается метод onUnbind().\nЕсли у сервиса больше нет привязанных компонентов, вызывается метод onDestroy().\n\nКомпонент может быть привязан к сервису, запущенному методом startService(). В этом случае сервис относится сразу и к Started и к Bound.\n\nBound и Started сервисы важно различать, потому что у них разные жизненные циклы."
  },
  {
    "category": "Android",
    "question": "В каком потоке работает сервис? В главном или фоновом?",
    "answer": "Service по умолчанию работает в главном потоке, в андроиде это UI thread.\nНа этот вопрос часто отвечают неправильно, потому что путают понятия фоновой задачи (background task) и фонового потока (background thread).\n\nАндроид приложение может работать в фоновом режиме. Это значит, что пользователь не видит UI компоненты приложения, а активити на верхушке бэкстека находится в stopped состоянии.\n\nДля выполнения асинхронной операции в сервисе можно использовать multithreading api андроида.\nДля выполнения всего кода сервиса асинхронно используется специальный вид сервиса, JobIntentService, который по умолчанию работает в фоновом потоке.\n"
  },
  {
    "category": "Android",
    "question": "Что такое Background и Foreground Service?",
    "answer": "Любой сервис, не зависимо от того Started или Bound, по умолчанию Background. Это значит, что сервис работает как фоновая задача (не путать с фоновым потоком), не требующая взаимодействия с пользователем.\n\nForeground Service – это сервис, о котором пользователь осведомлен. Это достигается с помощью отображения нотификации в статус-баре.\nПример foreground сервиса – отображение нотификации при проигрывании музыки в приложении-плеере.\n\nПроцесс в котором работает foreground сервис имеет больший приоритет, чем процесс с background сервисом. В примере с плеером foreground сервис выполняет сразу две функции:\n1. Говорит системе, что этот процесс убивать не надо, т.к. пользователь взаимодействует с ним;\n2. Обрабатывает нажатия на кнопки в нотификации.\n\nЗапущенный сервис переводится в состояние foreground методом startForeground(int id, Notification notification), принимающим параметрами id нотификации и саму нотификацию, которая будет показана пользователю. Важно знать, что startForeground() вызывается у сервиса, который уже запущен как background сервис, например методом startService().\n\nДля перевода foreground сервиса в состояние background используется метод stopForeground(boolean removeNotification). Этот метод не останавливает сервис (нужно вызвать stopService() или stopSelf()), но увеличивает шансы того, что система убьет процесс.\n"
  },
  {
    "category": "Android",
    "question": "Опишите методы жизненного цикла сервиса",
    "answer": "Жизненный цикл сервиса различается для started и bound сервисов.\n\nМетоды жизненного цикла started сервиса:\n\nonCreate() – вызывается, когда сервис создается системой. Для создания started сервиса используется метод startService().\n\nonStartCommand() – вызывается, когда сервис переходит в активное состояние. Код, который выполняет сервис, должен быть написан в этом методе.\n\nonDestroy() – вызывается, когда сервис уничтожается системой. Это происходит после вызова stopSelf() или stopService(). Также система может убить процесс с фоновым сервисом когда не хватает ресурсов или, начиная с Android 8.0, для ограничения фоновых работы.\n\nМетоды жизненного цикла bound сервиса:\n\nonCreate() – вызывается когда первый клиент присоединяется к сервису вызовом bindService() с флагом BIND_AUTO_CREATE.\n\nonBind() – вызывается системой, когда первый клиент присоединяется к сервису вызовом метода bindService(). После вызова этого метода bound сервис переходит в активное состояние.\n\nonUnbind() – вызывается системой, когда все клиенты отсоединились от сервиса вызовом метода unbindService().\n\nonDestroy() – вызывается после onUnbind(), перед тем как система уничтожит сервис.\n\nСервис может быть одновременно started и bound. В этом случае вызываются все методы жизненного цикла обоих типов сервисов.\nonDestroy() у такого сервиса вызывается когда все клиенты отсоединены и сервис остановлен вызовом метода stopSelf() или stopService().\nЕсли же все клиенты отсоединяются, но сервис не остановлен, то вызывается метод onUnbind() и сервис продолжает работать.\nonUnbind() возвращает boolean. Если вернуть true, то при присоединении первого клиента после onUnbind() вызывается метод onRebind(), иначе вызывается onBind()."
  },
  {
    "category": "Android",
    "question": "Типы сервисов (запущенный, привязанный, IntentService), их отличия и жизненные циклы",
    "answer": "Служба является «запущенной», когда компонент приложения (например, операция) запускает ее вызовом startService(). После запуска служба может работать в фоновом режиме в течение неограниченного времени, даже если уничтожен компонент, который ее запустил. Обычно запущенная служба выполняет одну операцию и не возвращает результатов вызывающему компоненту. Например, она может загружать или выгружать файл по сети. Когда операция выполнена, служба должна остановиться самостоятельно.Жизненный цикл: onCreate(), onStartCommand(), onDestroy().\n\nСлужба является «привязанной», когда компонент приложения привязывается к ней вызовом bindService(). Привязанная служба предлагает интерфейс клиент-сервер, который позволяет компонентам взаимодействовать со службой, отправлять запросы, получать результаты и даже делать это между разными процессами посредством межпроцессного взаимодействия (IPC). Привязанная служба работает только пока к ней привязан другой компонент приложения. К службе могут быть привязаны несколько компонентов одновременно, но когда все они отменяют привязку, служба уничтожается. Жизненный цикл: onCreate(), onBind(), onUnbind(), onDestroy().\n\nIntentService — Это подкласс класса Service, который использует рабочий поток для обработки всех запросов запуска поочередно. Это оптимальный вариант, если вам не требуется, чтобы ваша служба обрабатывала несколько запросов одновременно. Достаточно реализовать метод onHandleIntent(), который получает намерение для каждого запроса запуска, позволяя выполнять фоновую работу. Жизненный цикл: onCreate(), onHandleIntent(), onDestroy()."
  },
  {
    "category": "Android",
    "question": "Что такое и для чего используется BroadcastReceiver?",
    "answer": "BroadcastReceiver – один из четырех основных компонентов. Реализует шаблон publisher-subscriber и используется для получения сообщений системы, других компонентов приложения и сторонних приложений.\n\nСобытия обрабатываются в методе BroadcastReceiver.onReceive(), который вызывает система.\n\nBroadcastReceiver может быть точкой входа в приложение. Ресиверы, зарегистрированные в манифесте, принимают сообщения даже если приложение не запущено. В этом случае система стартует процесс с приложением и вызывает Application.onCreate() до вызова BroadcastReceiver.onReceive().\n\nПример использования: регистрация ресивера для прослушивания событий изменения языка в системе. Для этого используется ACTION_LOCALE_CHANGED. Полезно, если некоторые ресурсы (например сообщения об ошибках) локализуются на бэкенде. В этом случае можно отправить запрос с новой локалью на бэк.\n"
  },
  {
    "category": "Android",
    "question": "Что такое ContentProvider",
    "answer": "ContentProvider являются одним из основных строительных блоков приложений Android, предоставляя контент приложениям. Они инкапсулируют данные и предоставляют их приложениям через единый интерфейс ContentResolver. ContentProvider требуется только в том случае, если вам нужно обмениваться данными между несколькими приложениями. Например, данные контактов используются несколькими приложениями и должны храниться в поставщике контента"
  },
  {
    "category": "Android",
    "question": "Handler, Looper, MessageQueue — как это всё работает вместе",
    "answer": "Looper: который ещё иногда ещё называют «цикл обработки событий» используется для реализации бесконечного цикла который может получать задания используется. Класс Looper позволяет подготовить Thread для обработки повторяющихся действий. Главный поток Android на самом деле Looper Thread. MessageQueue — очередь Message: сообщение представляет собой контейнер для набора инструкций которые будут выполнены в другом потоке.\n\nHandler: данный класс обеспечивает взаимодействие с Looper Thread. Именно с помощью Handler можно будет отправить Message с реализованным Runnable в Looper, которая будет выполнена (сразу или в заданное время) потоком с которым связан Handler"
  },
  {
    "category": "Android",
    "question": "Планировщики задач",
    "answer": "AlarmManager, Handler, Service — решения для запуска бэкграунд-задач на основе сервисов.\n\nJobScheduler — Это механизм, с чьей помощью можно в фоне выполнять различную работу, начало выполнения которой оптимизировалось и упрощалось за счёт централизованной системы запуска этих задач и возможности задавать условия для этого самого запуска.\n\nGCM Network Manager — аналог JobScheduler — GCM Network Manager. Это библиотека, которая предоставляет схожий функционал, но работает уже с API 9. Правда, взамен требует наличие Google Play Services.\n\nFirebase Job Dispatcher — Firebase JobDispatcher также является библиотекой для планирования фоновых заданий. Он также используется для поддержки обратной совместимости (ниже API 21) и работает во всех последних версиях Android (API 9+). Эта библиотека также будет работать, если на устройстве нет установленных сервисов Google Play. В этом состоянии эта библиотека внутренне использует AlarmManager. Если на устройстве доступно приложение Google Play, он использует механизм планирования в службах Google Play.\n\nSync Adapter — Sync adapters разработаны специально для синхронизации данных между устройством и облаком. Он должен использоваться только для этого типа задач. Синхронизация может быть вызвана изменениями данных в облаке или на устройстве или по истекшему времени. Система будет пытаться синхронизировать только тогда, когда устройство подключено к сети."
  },
  {
    "category": "Android",
    "question": "Serializable vs Parcelable",
    "answer": "Serializable — это стандартный интерфейс Java. Вы можете просто реализовать интерфейс Serializable и переопределить методы. Проблема этого подхода заключается в том, что используется рефлексия, и это медленный процесс. Этот метод создает много временных объектов и вызывает довольно много мусора. Тем не менее, Serializable интерфейс проще в реализации. Процесс Parcelable намного быстрее, чем Serializable. Parcelable является частью Android SDK. Для Parcelable мы явно реализуем процесс сериализации."
  },
  {
    "category": "Android",
    "question": "Виды Intent",
    "answer": "Явные объекты Intent указывают компонент, который требуется запустить, по имени ( полное имя класса). Неявные объекты Intent не содержат имени конкретного компонента. Вместо этого они в целом объявляют действие, которое требуется выполнить, что дает возможность компоненту из другого приложения обработать этот запрос.\n\nПозвонить — Intent.ACTION_CALL\n\nОтправить смс — Intent.ACTION_VIEW setType(“vnd.android-dir/mms-sms”)\n\nПолучить контакт из телефонной книги — Intent.ACTION_PICK, android.provider.ContactsContract.Contacts.CONTENT_URI\n\nОткрыть ссылку в браузере — Intent.ACTION_VIEW, Uri.parse(“http://www.google.com\")\n\nРасшарить контент/написать письмо — Intent.ACTION_SEND setType(“text/plain”)\n\nОткрыть карту по определенным координатам либо запросу — Intent(android.content.Intent.ACTION_VIEW, Uri.parse(“geo:”+ latitude + “,” + longitude))\n\nСделать снимок с камеры — Intent(MediaStore.ACTION_IMAGE_CAPTURE)\n\nИспользовать Speech to Text для распознавания голоса — Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH) .putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, RecognizerIntent.LANGUAGE_MODEL_FREE_FORM) putExtra(RecognizerIntent.EXTRA_PROMPT, “Speak please”) startActivityForResult(speechIntent, RESULT_SPEECH_TO_TEXT)\n\nPendingIntent — Передав PendingIntent другому приложению, вы предоставляете ему право выполнять указанную вами операцию, как если бы другое приложение было вами (с теми же разрешениями и идентификацией). Таким образом, вы должны быть осторожны с тем, как вы строите PendingIntent: почти всегда, например, базовый Intent, который вы предоставляете, должен иметь имя компонента, явно заданное для одного из ваших собственных компонентов, чтобы гарантировать, что оно в конечном итоге отправляется туда и никуда больше."
  },
  {
    "category": "Android",
    "question": "addOnBackStackChangeListener — что это и для чего",
    "answer": "public static interface FragmentManager.OnBackStackChangedListener\n\nДобавлен в API level 11, Устарел в API level 28. Интерфейс для отслеживания изменений в backStack.\n\nПредположим, что название вашего приложения изменяется в зависимости от имени фрагмента. Теперь, если вы перейдете от Fragment1 к Fragment2, а затем нажмете кнопку «Назад», с помощью addOnBackStackChangeListener вы узнаете, какой у вас фрагмент."
  },
  {
    "category": "Android",
    "question": "Dialog vs DialogFragment — отличия",
    "answer": "Класс Dialog — это базовый класс для создания диалоговых окон, но реализовывать напрямую класс Dialog не рекомендуется. Вместо этого следует использовать один из следующих подклассов:\n\nAlertDialog — Диалоговое окно, в котором могут отображаться заголовок, кнопки вплоть до трех штук, список из выбираемых элементов либо пользовательский макет.\n\nDatePickerDialog или TimePickerDialogДиалоговое окно с предопределенным пользовательским интерфейсом, с помощью которого пользователь указывает значения даты или времени.Эти классы определяют стиль и структуру вашего диалогового окна, однако следует использовать DialogFragment в качестве контейнера вашего диалогового окна.\n\nКласс DialogFragment предоставляет все функции, необходимые для создания диалогового окна и управления его внешним видом, вместо вызова методов к объекту Dialog. Использование DialogFragment для управления диалоговым окном обеспечивает корректную обработку событий жизненного цикла , таких как нажатие пользователем кнопки Назад или поворот экрана. С помощью класса DialogFragment также происходит повторное использование пользовательского интерфейса диалогового окна в качестве встраиваемого компонента в пользовательский интерфейс более высокого уровня — подобно традиционному классу Fragment (например, когда необходимо различное отображение пользовательского интерфеса диалогового окна на больших и маленьких экранах"
  },
  {
    "category": "Android",
    "question": "Polling Server (периодический опрос сервера)",
    "answer": "Polling Server (периодический опрос сервера) - это один из подходов к получению обновлений с сервера в приложении Android. Этот подход основан на регулярном опросе (проверке) сервера на предмет наличия новых данных или обновлений.\n\nВ Android для реализации периодического опроса сервера можно использовать различные подходы:\n\n    Использование Handler и Runnable: В этом подходе вы можете использовать Handler и Runnable для выполнения опроса сервера через определенные промежутки времени. Handler позволяет отправлять сообщения и выполнить код через указанный промежуток времени.\n\n    Вот пример кода, демонстрирующего использование Handler и Runnable для периодического опроса сервера:\n    kotlin\n\nval handler = Handler()\nval delayMillis = 5000L // Задержка в миллисекундах (5 секунд)\n\nval runnable = object : Runnable {\n    override fun run() {\n        // Выполните опрос сервера здесь\n        // ...\n\n        // Повторите опрос через заданное время\n        handler.postDelayed(this, delayMillis)\n    }\n}\n\n// Запустите опрос сервера\nhandler.postDelayed(runnable, delayMillis)\n\nВ этом примере run() метод Runnable выполняет опрос сервера, а затем снова запускает себя через указанное время с использованием handler.postDelayed().\n\nИспользование Timer и TimerTask: Второй подход состоит в использовании Timer и TimerTask для выполнения задачи опроса сервера внутри заданного интервала времени.\n\nВот пример использования Timer и TimerTask для периодического опроса сервера:\nkotlin\n\n    val timer = Timer()\n    val delayMillis = 5000L // Задержка в миллисекундах (5 секунд)\n\n    val timerTask = object : TimerTask() {\n        override fun run() {\n            // Выполните опрос сервера здесь\n            // ...\n        }\n    }\n\n    // Запустите опрос сервера через указанное время с периодом delayMillis\n    timer.schedule(timerTask, delayMillis, delayMillis)\n\n    В этом примере run() метод TimerTask выполняет опрос сервера, и он будет запускаться через указанный период времени и повторяться с тем же интервалом.\n\nОба подхода имеют свои особенности и могут быть адаптированы к требованиям вашего приложения. Однако, стоит помнить, что периодический опрос сервера может потреблять ресурсы батареи и сети, поэтому важно выбирать оптимальные интервалы и учитывать ограничения устройства и требования вашего приложения."
  },
  {
    "category": "Android",
    "question": "Реализация сustom View и custom ViewGroup. Отличия в реализациях",
    "answer": "Расширьте существующий класс или подкласс View своим собственным классом. Переопределите некоторые методы из суперкласса. Методы суперкласса для переопределения начинаются с ‘on’, например, onDraw (), onMeasure () и onKeyDown (). Это похоже на события on … в Activity или ListActivity, которые вы переопределяете для жизненного цикла и других функций. Используйте свой новый класс расширения. После завершения ваш новый класс может использоваться вместо View, на котором он основан.\n\nViewGroup — это специальное View, которое может содержать другие View (называемые дочерними). Этот класс определяет класс ViewGroup.LayoutParams, который служит базовым классом для параметров макетов"
  },
  {
    "category": "Android",
    "question": "MVC, MVP, MVVM, MVI — рассказать общие принципы:",
    "answer": "Model View Controller — Model получает входные данные от контроллера и решает, какие данные необходимы для выполнения запроса, выданного контроллером. Модель также может выполнять транзакции с базами данных или другим постоянным хранилищем по мере необходимости. Как только он собирает необходимую информацию, он информирует представление (через контроллер) о новых данных, вызывая соответствующие события. View содержит элементы управления пользовательского интерфейса, необходимые конечному пользователю для взаимодействия с приложением. Его задача — отслеживать жесты конечного пользователя и передавать его контроллеру для дальнейшей обработки. View обрабатывает уведомление о событии, полученное от Модели, и может запрашивать любые новые данные, необходимые для его отображения на экране. Однако в некоторых вариантах контроллер может быть назначен для получения набора данных из модели, форматирования и отправки его в представление. Здесь задача View состоит в том, чтобы визуализировать данные без какой-либо другой обработки. Контроллер можно представить как расширение или личный помощник View, все события, происходящие из View, обрабатываются контроллером. Контроллер также проинформирует Model от имени View о том, что в представлении произошло какое-то событие и могут потребоваться некоторые новые данные.\n\nModel-View-Presenter — Каждое View должно реализовывать соответствующий интерфейс. Интерфейс IView определяет набор функций и событий, необходимых для взаимодействия с пользователем (например, IView.ShowErrorMessage(string msg)). Презентер должен иметь ссылку на реализацию соответствующего интерфейса, которую обычно передают в конструкторе. Логика представления должна иметь ссылку на экземпляр презентера. Все события представления передаются для обработки в презентер и практически никогда не обрабатываются логикой View (в т.ч. создания других View).\n\nModel-View-View Model — Данный подход позволяет связывать элементы View со свойствами и событиями View-модели. Можно утверждать, что каждый слой этого паттерна не знает о существовании другого слоя. View-модель — это абстракция View. Обычно означает, что свойства View совпадают со свойствами View-модели. View-модель не имеет ссылки на интерфейс представления (IView). Изменение состояния View-модели автоматически изменяет View и наоборот, поскольку используется механизм связывания данных (Bindings).\n\nModel-View-Intent — Это такой шаблон проектирования, в котором Модель (Model) является активным компонентом, принимающим на вход Намерения (Intents) и производящая Состояния (State). Представление (View) в свою очередь принимает Модели Представления (View Model) и производит те самые Намерения. Состояние преобразуется в Модель Представления при помощи функции-трансформера (View Model Mapper)"
  },
  {
    "category": "Android",
    "question": "Clean Architecture — рассказать общие принцип",
    "answer": "в Clean Architecture код разделен на несколько уровней, с правилом инверсии зависимостей: внутренний уровень не должен зависеть от каких-либо внешних уровней.\n\nСлои:\n\nEntities — бизнес сущности\n\nUseCases — сценарии использования приложения\n\nPresenters/Gateways/Controllers — слой представления\n\nUI/Web/DB/Devices — реализации\n\nКоманды и данные всегда передаются следующим путем: view вызывает метод презентера(или ViewModel); Презентер обращается к экземпляру интерактора, который в него (в презентер) заинджекчен. Интерактор — это класс, соеджащий бизнес логику и реализующий интерфейс UseCase.\n\nИнтерактор, в свою очередь вызывает методы экземпляра репозитория. Причем на бизнес слое описан только интерфейс IRepository, реализация которого находится на слое данных. Таким образом, выполняется правило инверсии зависимостей.\n\nНа слое данных репозиторий обрящается к базе данных через DataAccesObject, к сети через retrofit или получает данные иным образом.\n\nДанные затем передаются из репозитория через интерактор и презентер обратно во view."
  },
  {
    "category": "Android",
    "question": "MVP vs MVVM (отличия)",
    "answer": "Презентер должен иметь ссылку на реализацию соответствующего интерфейса IView, которую обычно передают в конструкторе. ViewModel не может общаться со View напрямую. Вместо этого она представляет легко связываемые свойства и методы в виде команд. View может привязываться(Data Binding) к этим свойствам, чтобы получать информацию из ViewModel и вызывать на ней команды (методы). Это не требует того, чтобы View знала о ViewModel."
  },
  {
    "category": "Android",
    "question": "DiffUtil",
    "answer": "DiffUtil – служебный класс, созданный для улучшения производительности RecyclerView при обновлении списка. Даже если он связан с компонентом UI пользовательского интерфейса, вы можете использовать его в любой части вашего приложения для сравнения двух списков одного типа. На примере нашего приложения вы наверняка захотите проверить различия между двумя списками типа Item.\n\n Чтобы алгоритм, используемый DiffUtil, работал, списки должны быть неизменяемыми. В противном случае при изменении содержимого результат может отличаться от ожидаемого. Следовательно, чтобы обновить элемент в списке, создайте и установите копию этого элемента. \n\n areItemsTheSame(T, T) вызывается, чтобы увидеть, являются ли два объекта одинаковыми. Если нет, может возникнуть необходимость добавить/удалить элемент.\n\n areContentsTheSame вызывается только тогда, когда areItemsTheSame(T, T)вернуть истину. В этом случае элемент был доступен ранее, но содержимое изменилось, поэтому должно отображаться соответствующее изменение.\n\n getChangePayload (T oldItem, T newItem) называется, когда areItemsTheSame(T, T)возвращает true для двух элементов и areContentsTheSame(T, T)возвращает false для получения полезной нагрузки об изменении.\n"
  },
  {
    "category": "Android",
    "question": "ViewPool и ViewStub в Android",
    "answer": "В Android существуют два различных понятия: ViewPool и ViewStub. Давайте рассмотрим их подробнее.\n\n    ViewPool:\n    ViewPool представляет собой коллекцию или пул повторно используемых представлений (views) в Android. Обычно он используется в ситуациях, когда у вас есть динамический список или RecyclerView с большим количеством элементов. Вместо создания нового представления для каждого элемента вы можете использовать ViewPool для переработки и повторного использования уже существующих представлений, что снижает потребление памяти и повышает производительность.\n\nViewPool управляется внутри RecyclerView и отвечает за переработку представлений. Когда представление прокручивается за пределы видимой области, оно отсоединяется от RecyclerView и добавляется в пул. Когда требуется отобразить новое представление, RecyclerView сначала проверяет пул, прежде чем создавать новое представление. Если доступно перерабатываемое представление, оно привязывается к новым данным и снова присоединяется к RecyclerView, что позволяет избежать создания нового экземпляра представления.\n\n    ViewStub:\n    ViewStub (заглушка представления) - это легковесное, невидимое и нулевого размера представление, которое может использоваться в качестве заполнителя для сложного или дорогостоящего в раздутии макета. Он полезен, когда у вас есть макет, который не требуется сразу или не видим, но может понадобиться позже в зависимости от определенного условия или взаимодействия пользователя.\n\nВместо раздутия всей иерархии макета заранее, вы можете определить ViewStub в файле макета XML. Он занимает минимальное количество памяти и ресурсов процессора. Когда вам нужно отобразить макет, вы можете программно раздуть ViewStub с помощью метода inflate(), который заменяет ViewStub его раздутым макетом и делает его видимым.\n\nВот пример использования ViewStub в XML и программном раздутии:\n\nФайл макета XML (main_layout.xml):\nxml\n\n<LinearLayout ...>\n    <!-- Основной макет -->\n    \n    <ViewStub\n        android:id=\"@+id/viewStub\"\n        android:layout=\"@layout/my_inflatable_layout\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\" />\n</LinearLayout>\n\nJava/Kotlin код:\nkotlin\n\nval viewStub = findViewById<ViewStub>(R.id.viewStub)\nviewStub.inflate() // Раздувает ViewStub и заменяет его макетом\n\nВ этом примере мы определили ViewStub в основном макете XML и привязали его к идентификатору viewStub. Затем мы программно раздули ViewStub с помощью метода inflate(), что заменяет его содержимое макетом, определенным в атрибуте layout ViewStub.\n\nОба этих концепта полезны в различных сценариях разработки Android приложений. ViewPool помогает улучшить производительность при работе с большими списками или RecyclerView, а ViewStub позволяет оптимизировать раздутие макетов, улучшая использование ресурсов."
  },
  {
    "category": "Android",
    "question": "Dagger 2 (модули, компоненты, сабкомпоненты, скоупы, binds vs provides, named)",
    "answer": "Dagger 2 представляет собой библиотеку, которая помогает разработчику реализовать паттерн “Внедрение зависимости” (Dependency Injection), который в свою очередь является “специфичной формой инверсии управления (Inversion of control)”.\n\nModule — классы, чьи методы “предоставляют зависимости”.\n\nComponent — мост между @Module и @Inject(базовая аннотация, с помощью которой “запрашивается зависимость”)\n\nSubcomponent — Необходимо прописывать в интерфейсе родителя метод получения Сабкомпонента (упрощенное название Subcomponent). Для Сабкомпонента доступны все объекты родителя. Родитель может быть только один.\n\nScope — Данный механизм берет на себя создание и хранение единственного экземпляра необходимого класса до тех пор, пока соответствующий scope существует.\n\nДля Binds в отличии от Provides класс Module стал абстрактным, как и метод provide. У provide убрали аннотацию @Provide, зато добавили @Binds. А в аргументы передаем не необходимые зависимости, а конкретную реализацию.\n\nЧасто бывает, что нам необходимо провайдить несколько объектов одного типа. В этом случае нам приходит на помощь “qualifier annotation”. Это кастомная аннотация, которая имеет в себе аннотацию @Qualifier. Dagger2 предоставляет нам уже одну готовую “qualifier annotation” : @Named"
  },
  {
    "category": "Android",
    "question": "Doze Mode — что это",
    "answer": "Когда устройство на Android api >= Marshmallow лежит без движения и без зарядки, спустя час оно переходит в Doze Mode. Режим сна, когда почти все приложения перестают потреблять энергию батареи. Это происходит не сразу, а по шагам:\n\nACTIVE — Устройство используется или на зарядке.\n\nINACTIVE — Устройство недавно вышло из активного режима (пользователь выключил экран, выдернул зарядку и т.п.) …30 минут.\n\nIDLE_PENDING — Устройство готовится перейти в режим ожидания ...30 минут.\n\nIDLE — Устройство в режиме бездействия.\n\nIDLE_MAINTENANCE — Открыто короткое окно, чтобы приложения выполнили свою работу."
  },
  {
    "category": "Android",
    "question": "LiveData (value vs postValue, active() vs onInactive(), MediatorLiveData)",
    "answer": "LiveData — хранилище данных, работающее по принципу паттерна Observer (наблюдатель). Это хранилище умеет делать две вещи:\n\nВ него можно поместить какой-либо объект;\n\nНа него можно подписаться и получать объекты, которые в него помещают.\n\nДля обновления значения мы должны передать его с помощью метода setValue(T), будьте внимательны поскольку этот метод нужно вызывать с main треда, в противном случае мы получим IllegalStateException, если же нам нужно передать значение из другого потока можно использовать postValue(T), этот метод в свою очередь обновит значение в main треде. Интересной особенностью postValue(T) является еще то, что он в случае множественного вызова, не будет создавать очередь вызовов на main тред, а при исполнении кода в main треде возьмет последнее полученное им значение. Также, в классе присутствует два колбека:\n\nonActive() — будет вызван когда количество подписчиков изменит свое значение с 0 на 1.\n\nonInactive() — будет вызван когда количество подписчиков изменит свое значение с 1 на 0.\n\nКласс MediatorLiveData — реализует поведенческий паттерн который определяет объект, инкапсулирующий способ взаимодействия множества объектов, избавляя их от необходимости явно ссылаться друг на друга."
  },
  {
    "category": "Android",
    "question": "ViewModel — рассказать общие принципы",
    "answer": "Класс ViewModel предназначен для хранения и управления данными, связанными с пользовательским интерфейсом, с учетом жизненного цикла. Класс ViewModel позволяет данным переживать изменения конфигурации, такие как поворот экрана. Объекты ViewModel автоматически сохраняются во время изменений конфигурации, поэтому данные, которые они хранят, сразу же становятся доступны для Activity или экземпляра фрагмента."
  },
  {
    "category": "Android",
    "question": "Room — рассказать общие принципы",
    "answer": "Room — это способ сохранить данные приложений в Android-приложении. Это часть Android Architecture, группы библиотек от Google, которые поддерживают уместную архитектуру приложений. Room предлагается в качестве альтернативы Realm, ORMLite, GreenDao и многим другим.\n\nЭто высокоуровневый интерфейс для низкоуровневых привязок SQLite, встроенных в Android, о которых вы можете узнать больше в документации. Он выполняет большую часть своей работы во время компиляции, создавая API-интерфейс поверх встроенного SQLite API, поэтому вам не нужно работать с Cursor или ContentResolver.\n\nRoom имеет три основных компонента: Entity, Dao и Database. Аннотацией Entity нам необходимо пометить объект, который мы хотим хранить в базе данных. В объекте Dao надо описать методы для работы с базой данных. нужны методы для получения списка объектов и для добавления/изменения/удаления объектов. Аннотацией Database помечаем основной класс по работе с базой данных. Этот класс должен быть абстрактным и наследовать RoomDatabase."
  },
  {
    "category": "Android",
    "question": "Moxy — рассказать общие принципы",
    "answer": "Библиотека Moxy отличается от всех прочих MVP-инструментов тем, что между View и Presenter появился ViewState. Он отвечает за то, чтобы каждая View всегда выглядела именно так, как того хочет Presenter. ViewState хранит в себе список команд, которые были переданы из Presenter во View. И когда „новая“ View присоединяется к Presenter, ViewState автоматически применяет к ней все команды, которые Presenter выдавал раньше. Таким образом получается, что не зависимо от того, что произойдёт со View по вине Android, View останется всё-равно в правильном состоянии. Для этого вам нужно будет только привыкнуть изменять View исключительно командами из Presenter"
  },
  {
    "category": "Android",
    "question": "Realm — рассказать общие принципы",
    "answer": "Это нативная no-sql база данных для Android. Так же есть backend, который позволяет синхронизировать данные из всех источников. Из ключевых особенностей стоит отметить zero copy, MVCC (MultiVersion Concurrency Control) и ACID( Atomicity, Consistency, Isolation, Durability). Встроенного механизма устаревания и очистки данных нет. Можно выделить три главные особенности:\n\nLive Objects — Все объекты, полученные из Realm, являются, по сути, прокси к базе данных. За счет этого достигается zero copy (объекты не копируются из базы).\n\nTransactions — Все изменения привязанных объектов данных нужно проводить внутри транзакции.\n\nOpen\\Close — Необходимость открытия\\закрытия instance базы данных"
  },
  {
    "category": "Android",
    "question": "Метод invalidate() in view — как работает",
    "answer": "Отрисовка выполняется путем обхода дерева и записи команд отрисовки любого view, который необходимо обновить. После этого на экран выводятся команды отрисовки всего дерева, обрезанные до вновь изменённой области. Дерево в основном записывается и рисуется по порядку, родители рисуются раньше (то есть позади) своих детей, а братья и сестры рисуются в том порядке, в котором они появляются на дереве. Если вы устанавливаете фон для рисования для View, то View будет рисовать его до вызова его метода onDraw(). Дочерний порядок рисования может быть переопределен с помощью ViewGroup.setChildrenDrawingOrderEnabled(boolean) в ViewGroup и с помощью setZ (float) пользовательских значений Z, установленных в Views. Чтобы заставить view отрисоваться, вызовите invalidate(). Основной цикл view выглядит следующим образом: Событие приходит и отправляется в соответствующий view. View обрабатывает событие и уведомляет всех слушателей. Если в ходе обработки события, возможно, потребуется изменить границы view, представление вызовет requestLayout(). Точно так же, если в ходе обработки события может потребоваться изменить внешний вид представления, представление вызовет invalidate(). Если были вызваны requestLayout () или invalidate(), framework позаботится об измерении, разметке и построении дерева соответствующим образом"
  },
  {
    "category": "Android",
    "question": "ValueAnimator, ObjectAnimator — рассказать общие принципы",
    "answer": "ObjectAnimator, подкласс ValueAnimator обеспечивает поддержку анимации свойств целевых объектов. Конструкторы этого класса принимают параметры, чтобы определить целевой объект, который будет анимирован, а также имя свойства, которое будет анимировано. Соответствующие функции set/get затем определяются внутри, и анимация будет вызывать эти функции по мере необходимости для анимации свойства"
  },
  {
    "category": "Android",
    "question": "Paging library — виды пагинации:",
    "answer": "Библиотека Paging libraryпомогает вам загружать и отображать небольшие порции данных. Библиотека Paging library поддерживает следующие архитектуры данных:\n\nОбслуживается только с внутреннего сервера.\n\nХранится только в базе данных на устройстве.\n\nСочетание других источников, использующих базу данных на устройстве в качестве кэша."
  },
  {
    "category": "Android",
    "question": "Zygote — что это и как работает",
    "answer": "Zygote — это процесс, порождающий все android-приложения. Когда вы нажимаете на иконку того же clash of clans, zygote создаёт копию своего процесса с помощью fork(), и в этой копии запускает нужное приложение"
  },
  {
    "category": "Android",
    "question": "Bundle что туда можно положить",
    "answer": "Примитивные типы, строки, массивы примитивных типов и массивы строк; Parcelable, Serializable и массивы Parcelable; Экземпляры классов Size и SizeF"
  },
  {
    "category": "Android",
    "question": "Spannable — для чего используется",
    "answer": "Это интерфейс для текста, к которому можно прикреплять и отсоединять объекты стилизации. Задание этих объектов заключается в присвоению части текста некоторого определенного стиля. Такими маркировочными объектами могут быть экземпляры классов, которые реализуют интерфейс ParcelableSpan."
  },
  {
    "category": "Android",
    "question": "Context activity vs application context",
    "answer": "application context это singleton-экземпляр (единственный на всё приложение), и к нему можно получить доступ через функцию getApplicationContext(). Этот контекст привязан к жизненному циклу приложения. Контекст приложения может использоваться там, где вам нужен контекст, жизненный цикл которого не связан с текущим контекстом или когда вам нужно передать контекст за пределы Activity.\n\nContext activity контекст доступен в Activity и привязан к её жизненному циклу. Контекст Activity следует использовать для операций, связанных. с графическим интерфейсом."
  },
  {
    "category": "Android",
    "question": "что прописываем в манифесте",
    "answer": "Cписок всех элементов, расположенных в алфавитном порядке, которые могут присутствовать в файле манифеста. Там могут находиться только эти элементы, а никакие другие элементы или атрибуты добавлять нельзя.\n\n<action>, <activity>, <activity-alias>, <application>, <category>, <data>, <grant-uri-permission>, <instrumentation>, <intent-filter>, <manifest>, <meta-data>, <permission>, <permission-group>, <permission-tree>, <provider><receiver>, <service>, <supports-screens>, <uses-configuration>, <uses-feature>, <uses-library>, <uses-permission>, <uses-sdk>"
  },
  {
    "category": "Android",
    "question": "setRetainInstance in fragment — что даёт",
    "answer": "Свойство retainInstance фрагмента, по дефолту, является false. Это означает, что при поворотах девайса Fragment не сохраняется, а уничтожается и создается по новому вместе с Activity-host. При вызове setRetainInstance(true) фрагмент не уничтожается вместе с его хостом и передается новому Activity в не измененном виде."
  },
  {
    "category": "Android",
    "question": "AsyncTask — для чего и какие имеет недостатки",
    "answer": "Класс AsyncTask предлагает простой и удобный механизм для перемещения трудоёмких операций в фоновый поток. Недостатки:\n\nЖизненный цикл — AsyncTask продолжает работать, пока его метод doInBackground() не завершится. AsyncTask запустит метод onCancelled(Result result), если мы отменяем задачу вызовом cancel(boolean), либо метод onPostExecute(Result result), если задача не была отменена. Предположим, наш AsyncTask не был отменен до того как Activity была уничтожена. Теперь, если AsyncTask попытается взаимодействовать с компонентами этой Activity программа упадет, т.к. Activity больше не существует.\n\nУтечки памяти — Так как AsyncTask имеет методы, которые работают в фоновом потоке (doInBackground()), а также методы, которые работают в потоке пользовательского интерфейса (например OnPostExecute()), он сохраняет ссылку на Activity, до тех пор пока работает. Но, если Activity уничтожена, он будет по-прежнему хранить эту ссылку в памяти.\n\nПотеря результатов — Еще одной проблемой является то, что мы потеряем результаты выполнения AsyncTask если наша Activity будет пересоздана. Например, это происходит при повороте экрана. Activity будет уничтожена и создана заново, но наш AsyncTask теперь будет иметь недействительную ссылку на эту Activity, поэтому onPostExecute() не будет иметь никакого эффекта.\n\nПоследовательно или параллельно? До API версии 1.6 (Donut): В первой версии AsyncTask задачи выполнялись последовательно. Это значит, что следующая задача не будет запущена пока предыдущая не завершит свою работу.С API версии 1.6 до API версии 2.3 (Gingerbread): Разработчики Android решили изменить поведение так, что бы несколько AsyncTask могли работать параллельно в отдельных потоках. С API версии 3.0 (Honeycomb) по настоящее время AsyncTaskʼи снова выполняются последовательно. Разработчики Android предоставили возможность выполнять задачи параллельно. Это делается методом executeOnExecutor(Executor)."
  },
  {
    "category": "Алгоритмы",
    "question": "Сложность алгоритма",
    "answer": "Сложность определяется как O(f(n)) («О большое от …») где f(n) — функция сложности. Это обозначение говорит о том, что при увеличении входных параметров (n) время работы алгоритма будет увеличиваться не быстрее чем f(n).\n\nТак как это лишь оценочное представление, то не важны возможные константы, не зависящие от входных параметров т.е. O(n) = O(2*n) = O(n+10) и т.д. При этом возможна ситуация, когда сложность равна O(1). Это значит, что алгоритм работает константное время вне зависимости от размера входных данных. Рассмотрим это все на примерах.\n\nДопустим, у нас массив из данных длиной N. Пусть наш алгоритм проходит по всем значением и прибавляет к ним единицу. Его сложность равна O(N), т.к. нам надо N раз пройтись по всем элементам.\n\nСнова рассмотрим массив длиной N. Теперь мы хотим его отсортировать самым простым способом — пузырьком. Этот алгоритм подразумевает, что последовательно, один за одним, самые большие числа «выталкиваются» наверх, как пузырьки в воде. Для этого необходимо N раз пройтись по всем элементам, попарно их сравнить со следующим и поменять местами если один больше другого. Примерное количество операций при этом N*N = N^2. Сложность такого алгоритма квадратичная и выражается как O(N^2).\n\nПри разработке алгоритмов следует стремиться, чтобы сложность была как можно меньше. Такие структуры данных, как, например, бинарные деревья позволяют получить логорифмическую сложность. Это значит, что время работы алгоритмы будет расти медленее, чем увеличиваются входные данные."
  },
  {
    "category": "Алгоритмы",
    "question": "Сложности вставки, поиска и удаления в ArrayList, LinkedList, HasMap",
    "answer":"Сложность операций над разными коллекциями зависит от того, какие структуры данных лежат в их основе. Разные действия, такие как добавление, поиск и удаление элемента могут занимать разное время для одного и того же типа коллекции.\nSkillbox\n\n    ArrayList основан на массиве.\nСложность получение элемента по индексу O(1).\nСложность вставки O(1) если не нужно пересоздавать массив (когда закончилось отведенное место для старого). В случае пересоздания сложность становится O(n).\n Сложность вставки по определенному индексу O(n), т.к. приводит к смещению всех элементов после нового элемента.\n Сложность удаления элемента O(n), т.к. сначала необходимо будет его найти и потом передвинуть остальные элементы.\nLinkedList основан на связанном списке. Это такой вид структуры, когда каждый элемент содержит ссылку на следующий.\n Сложность получение элемента по индексу O(n), т.к. у нас нет возможности перепрыгнуть на определенный элемент. Для того, чтобы добраться до искомой позиции придется пройтись по всем элементам до него.\n Сложность вставки в конец или начало O(1). Ничего не надо передвигать, достаточно лишь поменять указатели.\n Сложность вставки по определенному индексу в среднем O(n).\n Сложность удаления элемента O(1), т.к. единственное что потребуется — переписать ссылку на следующий элемент.\n Сложность удаления элемента по индексу O(n), т.к. сначала придется его найти.\n    HashMap, HashSet\n  Сложность всех операций над данными коллекциями будет O(1) в случае нормального распределения функции хэширования. Если же хэш от элемента будет одинаков для всех элементов, то коллекция выродится до случая связанного списка. "
  },
  {
    "category": "Алгоритмы",
    "question": "Алгоритмы сортировки коллекций",
    "answer":"Алгоритмы сортировки — отдельная большая тема. Описание и сложность сортировки пузырьком можно найти в секции сложность алгоритмов. Тут же я приведу ряд наиболее популярных других полезных реализаций:\n\n    Сортировка пузырьков. Сложность O(n^2).\n    Быстрая сортировка (Quick sort).  Его сложность зависит от типа входных данных. В среднем она равна O(n*Logn), в худшем падает до O(n^2).\n    Сортировка слиянием (Merge sort). Сложность O(n*log(n))."
  },
  {
    "category": "Алгоритмы",
    "question": "Сортировка пузырьков. Сложность O(n^2).",
    "answer":"Алгоритм состоит из повторяющихся проходов по сортируемому массиву. За каждый проход элементы последовательно сравниваются попарно и, если порядок в паре неверный, выполняется перестановка элементов. Проходы по массиву повторяются N − 1 N-1 раз или до тех пор, пока на очередном проходе не окажется, что обмены больше не нужны, что означает — массив отсортирован.\n При каждом проходе алгоритма по внутреннему циклу очередной наибольший элемент массива ставится на своё место в конце массива рядом с предыдущим «наибольшим элементом», а наименьший элемент перемещается на одну позицию к началу массива («всплывает» до нужной позиции, как пузырёк в воде — отсюда и название алгоритма). "
  },
  {
    "category": "Алгоритмы",
    "question": "Быстрая сортировка (Quick sort)",
    "answer":"Алгоритм состоит из трёх шагов:\n\n    Выбрать элемент из массива. Назовём его опорным.\n    Разбиение: перераспределение элементов в массиве таким образом, что элементы, меньшие опорного, помещаются перед ним, а большие или равные - после.\n    Рекурсивно применить первые два шага к двум подмассивам слева и справа от опорного элемента. Рекурсия не применяется к массиву, в котором только один элемент или отсутствуют элементы."
  },
  {
    "category": "Алгоритмы",
    "question": "Сортировка слиянием ",
    "answer":"Для решения задачи сортировки эти три этапа выглядят так:\n\n    Сортируемый массив разбивается на две части примерно одинакового размера;\n    Каждая из получившихся частей сортируется отдельно, например — тем же самым алгоритмом;\n    Два упорядоченных массива половинного размера соединяются в один.\n\n1.1. — 2.1. Рекурсивное разбиение задачи на меньшие происходит до тех пор, пока размер массива не достигнет единицы (любой массив длины 1 можно считать упорядоченным).\n\n3.1. Соединение двух упорядоченных массивов в один.\nОсновную идею слияния двух отсортированных массивов можно объяснить на следующем примере. Пусть мы имеем два уже отсортированных по возрастанию подмассива. Тогда:\n3.2. Слияние двух подмассивов в третий результирующий массив.\nНа каждом шаге мы берём меньший из двух первых элементов подмассивов и записываем его в результирующий массив. Счётчики номеров элементов результирующего массива и подмассива, из которого был взят элемент, увеличиваем на 1.\n3.3. «Прицепление» остатка.\nКогда один из подмассивов закончился, мы добавляем все оставшиеся элементы второго подмассива в результирующий массив. "
  },
  {
    "category": "Логические задачи по алгоритмам",
    "question": "Бактерии в стакане или лилии в пруду",
    "answer":"Существуют несколько сеттингов для данной задачи — пруд, в котором растут новые лилии или же стакан, в котором размножаются бактерии. Рассмотрим задачу в контексте стакана. В нем каждую секунду каждая бактерия делится пополам. Половина стакана заполняется за 30 секунд. Вопрос: за сколько бактерии заполнят весь стакан?\n\n\n Ответ\n\n31 секунда. Первое, что приходит в голову — 60 секунд. Тут важно заметить, что каждая бактерия делится пополам. Изначально там была 1, далее 2, а вот после этого уже не 3, а 4, потом 8 и т.д. На 29 секунду было заполнено четверть стакана, дале 1/4 увеличилась в 2 раза до 1/2 (половины). Следущий шаг 1/2*2 = 1 (целый стакан)."
  },
  {
    "category": "Логические задачи по алгоритмам",
    "question": "Высыхающий арбуз",
    "answer":"Aрбуз на 99% состоит из воды и весит 10кг. Светит солнце, жарко и арбуз теряет влагу. Теперь арбуз состоит из воды на 98%. Сколько теперь весит арбуз? \n\n\n Ответ\n\n5 кг. Невероятно, но факт. Испарится может только лишь влага, а не твердое вещество из которого арбуз тоже состоит. Вот это самое твердое вещество — единственная константа, к которой можно привязаться. Мы знаем, что оно весит 1% и никуда деться не может. Из начального условия 1% весит 0.1кг. После испарения вес твердого вещества не изменился и теперь 0.1кг. это 2% арбуза. Если 2% это 0.1кг., то 100% это в 50 раз больше. Выходит, что все 100% арбуза весит 0.1кг * 50 = 5кг."
  },
  {
    "category": "Логические задачи по алгоритмам",
    "question": "Поиск цикла в связанном списке",
    "answer":"Есть связанный список неизвестной длины. Необходимо определить зацикленный он или нет (когда очередная ссылка на следующий элемент ссылается на любой из предыдущих элементов). \n\n\nНеобходимо взять 2 указателя на начало списка и «запустить» их с разной скоростью. Т.е. в цикле перебирать элементы сдвигая один указатель по одному, а другой перепрыгивая через один. Эту задачу можно сравнить со стадионом. Чтобы понять, что вы бегаете по кругу достаточно лишь увидеть одного и того же спортсмена обгоняющего вас второй раз. "
  },
  {
    "category": "ООП",
    "question": "Что такое ООП?",
    "answer": "ООП - методология программирования, основанная на представлении программного продукта в виде совокупности объектов, каждый из которых является экземпляром конкретного класса. ООП использует в качестве базовых элементов взаимодействие объектов."
  },
  {
    "category": "ООП",
    "question": "Что такое объект?",
    "answer": "Объект - именнованная модель реальной сущности, обладающая конкретными значениями свойств и проявляющая свое поведение, обладающий именем набор данных (полей и свойств объекта), физически находящихся в памяти компьютера, и методов, имеющих доступ к ним. Объект -конкретный экземпляр класса."
  },
  {
    "category": "ООП",
    "question": "Назовите основные принципы ООП.",
    "answer": "Принято считать, что объектно-ориентированное программирование строится на 4 основных принципах (раньше их было всего 3). Эти принципы: \n\n(Абстракция)\n\nИнкапсуляция\n\nНаследование\n\nПолиморфизм"
  },
  {
    "category": "ООП",
    "question": "Что такое наследование?",
    "answer": "Наследование это процесс благодаря которому один объект может приобрести свойства другого объекта (наследование всех свойств одного объекта другим) и добавлять черты характерны только для него самого !\n\n  Суперкласс -> Подкласс Родительский -> Дочерний"
  },
  {
    "category": "ООП",
    "question": "Что такое полиморфизм? Какие проявления полиморфизма в Java Вы знаете?",
    "answer": "Полиморфизм (polymorphism) (от греческого polymorphos) - это свойство, которое позволяет одно и то же имя использовать для решения двух или более схожих, но технически разных задач. Целью полиморфизма, применительно к объектно-ориентированному программированию, является использование одного имени для задания общих для класса действий. Выполнение каждого конкретного действия будет определяться типом данных. В более общем смысле, концепцией полиморфизма является идея \"один интерфейс, множество методов\". Это означает, что можно создать общий интерфейс для группы близких по смыслу действий."
  },
  {
    "category": "ООП",
    "question": "Что такое инкапсуляция?",
    "answer": "Инкапсуляция (encapsulation) - это сокрытие реализации класса и отделение его внутреннего представления от внешнего (интерфейса), это свойство которое позволяет закрыть доступ к полям и методам класса другим классам, а предоставлять им доступ только через интерфейс(метод). При использовании объектно-ориентированного подхода не принято применять прямой доступ к свойствам какого-либо класса из методов других классов. Для доступа к свойствам класса принято задействовать специальные методы этого класса для получения и изменения его свойств."
  },
  {
    "category": "ООП",
    "question": "Что такое aбстракция?",
    "answer": "Абстракция - это выделение общих характеристик объекта,исключая набор незначительных. С помощью принципа абстракции данных, данные преобразуются в объекты. Данные обрабатываются в виде цепочки сообщений между отдельными объектами. Все объекты проявляют свои уникальные признаки поведения. Огромный плюс абстракции в том, что она отделяет реализацию объектов от их деталей, что в свою очередь позволяет управлять функциями высокого уровня через функции низкого уровня."
  },
  {
    "category": "ООП",
    "question": "В чем преимущества объектно-ориентированных языков программирования?",
    "answer": "Они представляют реальные объекты в  жизни, например, Машина, Джип, Счет в  банке и тд… Инкапсуляция, наследование и полиморфизм делает его еще мощнее."
  },
  {
    "category": "ООП",
    "question": "Как использование объектно – ориентерованного подхода улучшает разработку программного обеспечения?",
    "answer": "повторное использование кода(наследование)   \n\n   реальное отображение предметной  области. \n\n Объекты соответствуют реальному миру(см. предыдущий пункт)."
  },
  {
    "category": "ООП",
    "question": "Имеется выражение «является» и «имеет». Что они подразумевают в плане принципов ООП? В чем разница между композицией и агрегацией?",
    "answer": "является\" - наследование \"имеет\" - композиция\n\n В качестве примера предположим что у нас есть классы Строение, Дом и Ванная комната. Так вот Дом является строением, что нельзя сказать про Ванну, которая не является домом. А вот Дом имеет\\включает в себя Ванну. Если  вы хотите использовать повторно код, то не обязательно использовать наследование. Если нет отношения \"является\", то лучше тогда использовать композицию для повторного использования кода. \n\nНе  используйте наследование для получение полиморфизма, если нет ключевой зависимости \"является\". Используйте интерфейсы для полиморфизма. Из  спецификации можно узнать, что       Ассоциация  обозначает связь между объектами.      Агрегация и композиция это частные случаи ассоциации.  Агрегация предполагает, что объекты связаны  взаимоотношением \"part-of\" (часть).  Композиция  более строгий вариант агрегации. \n\nДополнительно к требованию part-of накладывается условие, что \"часть\" не может одновременно принадлежать разным \"хозяевам\", и заканчивает своё существование вместе с владельцем. Например:  \n\n     мотоцикл -> cумка с багажём - ассоциация. Отношение \"имеет\".     мотоцикл -> колесо - композиция.      группа  по интересам -> человек - агрегация. человек часть группы, но может принадлежать нескольким разным группам."
  },
  {
    "category": "ООП",
    "question": "Что вы подразумеваете под полиморфизмом, инкапсуляцией и динамическим связыванием?",
    "answer": "Полиморфизм означает способность  переменно данного типа, которая  ссылается на объекты разных  типов, при этом вызывается  метод, характерный для конкретного  типа ссылки на объект. В чем преимущество полиморфизма? Он позволяет добавлять новые классы производных объектов, не нарушая  при этом код вызова. Также использование полиморфизма называют динамическим связыванием объектов.  \n\n  Рассмотрим  пример полиморфизма: Имеется классы: Фигура, круг и треугольник. Круг  и треугольник наследуется от фигуры соответственно. Каждый  класс имеет метод \"рисовать\". В круге и треугольнике этот метод  переопределен. Так вот, создаем объект с типом \"Фигура\" и присваиваем ей ссылку на объект типа \"Круг\" и вызываем на этом объекте  метод \"рисовать\". В итоге вызывается метод класса \"Круг\", а не класса \"Фигура\" как ожидалось.  Фигура  ф = new Круг()  Ф.рисовать()   Также вместо класса родителя \"Фигура\" к  примеру можно использовать интерфейс \"Фигура\", определив там метод рисовать. Этот интерфейс мы имплементируем в классах \"Круг\" \"Треугольник\". Далее на интерфейсе создаем объект и присваиваем ему ссылку на объект какого-то из реализующих этот интерфейс классов. Это удобно например если у нас есть некий метод:  public void drawShape(Фигура ф){ ф.рисовать()  }  \n\n  Обратите  внимание что в метод мы передаем параметр с типом интерфейса, т.е. мы не знаем какой именно тип объекта будем, но реализация будет таже. Далее мы можем просто создать еще класс, к примеру \"Трапеция\", имплементировать и имплементировать интерфейс \"Фигура\" и просто передать экземпляр класса в метод, ничего не меняя в реализации и вызове. Наследование  это включение поведения(методы) и состояния(поля) базового класса в производный от него. В результате этого мы избегаем дублирования кода и процесс исправления ошибок в коде также упрощается.   \n\nВ джава есть два вида наследования:      наследование классов. Каждый  наследник может иметь толко одного родителя.     наследование  интерфейсов. Интерфейс может  иметь сколько угодно родителей.  Некоторые тонкие ньюансы по поводу наследования интрефейсов и классов. Мы  имеем два интерфейса с одинаковыми  по имени полями. Имплементируем эти  интерфейсы на каком-то классе. Как нам вызвать поля этих интерфейсов? У нас неоднозначность. Необходимо  объект класса привести к нужному  интерфейсу. Класс к = new Класс()  ((Интефейс1) к).поле     \n\n  Хорошо, что будет если мы имеем метод с одинаковой сигнатурой в интерфейсах и реализуем эти интерфейсы на классе. Как нам в классе реализовать два метода с одинаковой сигнатурой??? Ответ: никак, мы просто реализовываем один общий метод в классе. Это является недостатком, так как нам  может потребоваться разная реализация.  И третий случай: У нас есть класс  и интерфейс с одинаковым по сигнатуре  методом. Мы наследуемся от этого  класса и имплементируем этот интерфейс. Что нам нужно делать? ведь необходимо реализовать метод интерфейса по всем правилам. И вот тут интересно, компилятор не выдает ошибок, так как метод уже  у нас реализован в классе родителе."
  },
  {
    "category": "Java core.",
    "question": "Чем отличается JRE, JVM и JDK?",
    "answer": "JRE кратко - для работы. Java Runtime Environment (сокр. JRE) - минимальная реализация виртуальной машины, необходимая для исполнения Java-приложений, без компилятора и других средств разработки. Состоит из виртуальной машины - Java Virtual Machine и библиотеки Java-классов. JDK кратко - для программирования. Java Development Kit (сокращенно JDK) - бесплатно распространяемый компанией Oracle Corporation (ранее Sun Microsystems) комплект разработчика приложений на языке Java, включающий в себя компилятор Java (javac), стандартные библиотеки классов Java, примеры, документацию, различные утилиты и исполнительную систему Java (JRE). Java Virtual Machine (сокращенно Java VM, JVM) - виртуальная машина Java - основная часть исполняющей системы Java, так называемой Java Runtime Environment (JRE). Виртуальная машина Java интерпретирует Байт-код Java, предварительно созданный из исходного текста Java-программы компилятором Java (javac). JVM может также использоваться для выполнения программ, написанных на других языках программирования."
  },
  {
    "category": "Java core.",
    "question": "Опишите модификаторы доступа в Java.",
    "answer": "В Java существуют следующие модификаторы доступа:    \n\nprivate: (используется конструкторах, внутренних классах, методах и полях класса) - Доступ разрешен только в текущем классе.      \n\ndefault (package-private): (используется в классах, конструкторах, интерфейсах, внутренних классах, методах и полях класса) - Доступ на уровне пакета. Если класс будет так объявлен он будет доступен только внутри пакета.      \n\nprotected: (используется конструкторах, внутренних классах, методах и полях класса) Модификатор доступа на уровне пакета и в иерархии наследования.      \n\npublic: (используется в классах, конструкторах, интерфейсах, внутренних классах, методах и полях класса) - Модификатор доступа общественный, доступен всем.   Последовательность модификаторов по убыванию уровня закрытости: private, default ,protected, public)."
  },
  {
    "category": "Java core.",
    "question": "Что такое package level access.",
    "answer": "Доступ из классов одного package-а в классы другого package-a."
  },
  {
    "category": "Java core.",
    "question": "Чем абстрактный клас отличается от интерфейса? В каких случаях Вы бы использовали абстрактный класс, а в каких интерфейс?",
    "answer": "Абстрактный класс это класс, который помечен как \"abstract\", он может содержать абстрактные методы, а может их и не содержать.   Экземпляр абстрактного класса нельзя создать. Класс, который наследуется от абстрактного класса может реализовывать абстрактные методы, а может и не реализовывать, тогда класс наследник должен быть тоже абстрактным. Также если класс наследник переопределяет реализованный в абстрактном классе родители метод, его можно переопределить с модификатором абстракт! Т.е отказаться от реализации. Соответственно данный класс должен быть также абстрактным также.  \n\nЧто касается интерфейса, то в нем находятся только абстрактные методы и константы, так было до выхода Java 8. Начиная с Java 8 кроме абстрактных методов мы также можем использовать в интерфейсах стандартные методы (default methods) и статические методы (static methods). \n\nDefault метод в интерфейсе - это метод в интерфейсе с по умолчанию реализованной логикой, который не требуется обязательно определять в реализации этого интерфейса.  \n\nStatic методы в интерфейсе - это по существу то же самое, что static-методы в абстрактном классе.  При реализации интерфейса, класс обязан реализовать все методы интерфейса. Иначе класс должен быть помечен как абстрактный. Интерфейс также может содержать внутренние классы. И не абстрактные методы в них. Что же использовать Интерфейс или Абстрактный класс? Абстрактный класс используется когда нам нужна какая-то реализация по умолчанию. Интерфейс используется когда классу нужно указать конкретное поведение. Часто интерфейс и абстрактный класс комбинируют, т.е. имплементируют интерфейс в абстрактном классе, чтоб указать поведение и реализацию по умолчанию. Это хорошо видно на примере свига: Мы создаем свою модель таблицы с определенным поведением и уже с реализацией по умолчанию.  ВАЖНО! При реализации интерфейса, необходимо реализовать все его методы, иначе будет Fatal error, так же это можно избежать, присвоив слово abstract."
  },
  {
    "category": "Java core.",
    "question": "Может ли объект получить доступ к private-переменной класса? Если, да, то каким образом?",
    "answer": "Вообще доступ у приватной переменной класса можно получить только внутри класса, в котором она объявлена. Также доступ к приватным переменным можно осуществить через механизм Java Reflection API."
  },
  {
    "category": "Java core.",
    "question": "Для чего в джаве статические блоки?",
    "answer": "Статические блоки в джава выполняются до выполнения конструктора, с помощью них инициализируют статические поля к примеру. Еще один ньюанс, блок статической инициализации может создаваться сам при компиляции программы:"
  },
  {
    "category": "Java core.",
    "question": "Можно ли перегрузить static метод?",
    "answer": "Статические методы могут перегружаться нестатическими и наоборот - без ограничений. А вот в переопределении статического метода смысла нет."
  },
  {
    "category": "Java core.",
    "question": "Расскажите про внутренние классы. Когда вы их будете использовать?",
    "answer": "Внутренний  класс - это класс, который  находится внутри класса или интерфейса. При этом он получает доступ ко всем полям и методам своего внешнего класса.  Для чего он может применятся? Например чтоб обеспечить какую-то дополнительную логику класса. Хотя использование внутренних классов усложняет программу, рекомендуется избегать их использование."
  },
  {
    "category": "Java core.",
    "question": "В чем разница между переменной экземпляра и статической переменной? Приведите пример.",
    "answer": "Статические переменные инициализируются при загрузке класса класслодером, и не зависят от объекта. Переменная экземпляра инициализируется при создании класса. Пример: Например нам нужна глобальная переменная для всех объектов класс, например число посещений пользователей определенной статьи в интернете. При каждом новом посещении статьи создается новый объект и инкрементируется переменная посещений."
  },
  {
    "category": "Java core.",
    "question": "Приведите пример когда можно использовать статический метод?",
    "answer": "Статические методы могут быть использованы для  инициализации статических переменных. Часто статические методы используются в классах утилитах, таких как  Collections, Math, Arrrays"
  },
  {
    "category": "Java core.",
    "question": "Расскажите про классы- загрузчики и про динамическую зарузку классов.",
    "answer": "Любой класс, используемый в джава программу так или иначе был загружен в контекст программы каким-то загрузчиком. Все виртуальные машины джава включают хотябы один загрузчик классов, так называем базовый загрузчик. Он загружает все основные классы, это классы из rt.jar. Интересно то, что этот загрузчик никак не связан с программой, тоесть мы не можем получить например у java.lang.Object имя зарузчика, метод getClassLoader() вернет нам null.   \n\n Следующий загрузчик - это  загрузчик расширений, он загружает  классы из $JAVA_HOME/lib/ext.   \n\n Далее по иерархии идет системный  загрузчик, он загружает классы, путь к которым указан в переменно класпас.   \n\n Для примера предположим что у нас есть некий пользовательский класс MyClass и мы его используем. Как идет его загрузка… : \n\nСначала системный загрузчик пытается найти  его в своем кэше загрузок его, если найден - класс успешно загружается, иначе управление загрузкой передается загрузчику расширений, он также проверяет  свой кэш загрузок и в случае неудачи  передает задачу базовому загрузчику. Тот проверяет кэш и в случае неудачи пытается его загрузить, если загрузка прошла успешно -  загрузка закончена. Если нет - передает управление загрузчику расширений. Загрузчик  расширений пытается загрузить класс  и в случае неудачи передает это  дело системному загрузчику. Системный  загрузчик пытается загрузить класс  и в случае неудачи возбуждается исключение java.lang.ClassNotFoundException.   \n\n Вот так работает загрузка классов в  джава. Так называемое делегирование загрузки.   Если  в системе присутствуют пользовательские загрузики, то они должны быть унаследованы от класса java.lang.ClassLoader .\n\n Что же такое статическая и что  такое динамическая загрузка класса?   Статическая загрузка класса происходит при использовании  оператора \"new\".   \n\nДинамическая  загрузка происходит \"на лету\" в  ходе выполнения программы с помощью  статического метода класса Class.forName(имя класса). Для чего нужна динамическая загрузка? Например мы не знаем какой класс нам понадобится и принимаем решение в ходе выполнения программы передавая имя класса в статический метод forName()."
  },
  {
    "category": "Java core.",
    "question": "Что такое статическая и что такое динамическая загрузка класса?",
    "answer": ""
  },
  {
    "category": "Java core.",
    "question": "Для чего нужен оператор \"assert\" в джава?",
    "answer": "Это так называемый оператор  утверждений. Он проверяет некое  условие, если оно ложно, то  генерируется AssertationError assert status: \"message error\"  Тут проверяется булевская переменная \"status\"."
  },
  {
    "category": "Java core.",
    "question": "Почему в некоторых интерфейсах вообще не определяют методов?",
    "answer": "Это так называемые интерфейсы - маркеры. Они просто указывают что класс относится к определенной группе классов. Например интерфейс Clonable указывает на то, что класс поддерживает механизм клонирования. Степень абстракции в данном случае доведен до абсолюта. В интерфейсе вообще нет никаких объявлений. Интерфейси-маркери в Java:      Searilizable interface     Cloneable interface     Remote interface     ThreadSafe interface"
  },
  {
    "category": "Java core.",
    "question": "Какая основная разница между String, StringBuffer, StringBuilder?",
    "answer": "String - неизменяемый класс, тоесть для для добавление данных в уже существующую строку, создается новый объект строки. StringBuffer и StringBuilder могут изменятся и добавление строки не такое дорогостоющее с точки зрения памяти. Первы - синхронизированный, второй - нет. Это их единственное различие. Правда  если нам нужно сделать подстроку  строки, то лучше использовать String, так как ее массив символов не меняется и не создается заново для новой строки. А вот в StringBuffer и StringBuilder для создания подстроки создается новый массив символов."
  },
  {
    "category": "Java core.",
    "question": "Расскажите про потоки ввода-вывода Java.",
    "answer": "Потоки  ввода-вывода бывают двух видов:      байтовый поток(InputStream и OutputStream)      символный поток(Reader и Writer)   Это все абстрактные классы - декораторы, которым можно добавлять дополнительный функционал, например: InputStream in = new FileInputStream(new File(\"file.txt\"))"
  },
  {
    "category": "Java core.",
    "question": "Что такое Heap и Stack память в Java?",
    "answer": "Java Heap (куча)  - динамически распредляемая область памяти, создаваемая при старте JVM. Используется Java Runtime для выделения памяти под объекты и JRE классы. Создание нового объекта также происходит в куче. Здесь работает сборщик мусора: освобождает память путем удаления объектов, на которые нет каких-либо ссылок. Любой объект, созданный в куче, имеет глобальный доступ и на него могут ссылаться с любой части приложения. Cтрогими тезами:      Все обьекты обитают в куче и попадают туда при создании.     обьект состоит из полей класса и методов.     в куче выделяется место под сам обьект, количество выделенной памяти зависит от полей, если у тебя полем класса, к примеру, служит интовая переменная, то не важно, инициализируешь ты ее как \"0\" или как \"1000000\" - обьект займет в куче свои биты, + столько байт сколько вмещает тип int(+32 бита), и так с каждым полем.  Стековая память в Java работает по схеме LIFO (Последний-зашел-Первый-вышел). Всякий раз, когда вызывается метод, в памяти стека создается новый блок, который содержит примитивы и ссылки на другие объекты в методе расположение в RAM и достижение процессору через указатель стека. Как только метод заканчивает работу, блок также перестает использоваться, тем самым предоставляя доступ для следующего метода. Размер стековой памяти намного меньше объема памяти в куче. Cтрогими тезами:      Все методы обитают в стеке и попадают туда при вызове.     Переменные в методах так же имеют стековую память, по скольку они локальные.     Если в методе создается обьект, то он помещается в кучу, но его ссылка все еще будет находится в стеке и после того как метод покинет стек - обьект станет жертвой сборщика мусора, так как ссылка на него утеряна, и из главного стека программы невозможно будет добраться до такого обьекта."
  },
  {
    "category": "Java core.",
    "question": "Какая разница между Stack и Heap памятью в Java?",
    "answer": "Приведем следующие различия между Heap и Stack памятью в Java.      Куча используется всеми частями приложения в то время как стек используется только одним потоком исполнения программы.     Всякий раз, когда создается объект, он всегда хранится в куче, а в памяти стека содержится ссылка на него. Память стека содержит только локальные переменные примитивных типов и ссылки на объекты в куче.     Объекты в куче доступны с любой точки программы, в то время как стековая память не может быть доступна для других потоков.     Управление памятью в стеке осуществляется по схеме LIFO.     Стековая память существует лишь какое-то время работы программы, а память в куче живет с самого начала до конца работы программы.     Мы можем использовать -Xms и -Xmx опции JVM, чтобы определить начальный и максимальный размер памяти в куче. Для стека определить размер памяти можно с помощью опции -Xss .     Если память стека полностью занята, то Java Runtime бросает java.lang.StackOverflowError, а если память кучи заполнена, то бросается исключение java.lang.OutOfMemoryError: Java Heap Space.     Размер памяти стека намного меньше памяти в куче. Из-за простоты распределения памяти (LIFO), стековая память работает намного быстрее кучи."
  },
  {
    "category": "Java core.",
    "question": "Расскажите про модель памяти в джава?",
    "answer": "В Джаве память устроена следующим  образом, есть два вида:      куча     стек  Куча  состоит из статического контекста  и самой кучи Перейдем  к куче. Куча состоит из двух частей:      Новая куча     Старая куча  Новая куча в свою очередь состоит из двух частей:      Eden(назовем ее первая) куча     Survival(выжившая) куча  Краткое описание:      Eden Space (heap) - в этой области выделятся память под все создаваемые из программы объекты. Большая часть объектов живет недолго (итераторы, временные объекты, используемые внутри методов и т.п.), и удаляются при выполнении сборок мусора это области памяти, не перемещаются в другие области памяти. Когда данная область заполняется (т.е. количество выделенной памяти в этой области превышает некоторый заданный процент), GC выполняет быструю (minor collection) сборку мусора. По сравнению с полной сборкой мусора она занимает мало времени, и затрагивает только эту область памяти - очищает от устаревших объектов Eden Space и перемещает выжившие объекты в следующую область.      Survivor Space (heap) – сюда перемещаются объекты из предыдущей, после того, как они пережили хотя бы одну сборку мусора. Время от времени долгоживущие объекты из этой области перемещаются в Tenured Space.     Tenured (Old) Generation (heap) - Здесь скапливаются долгоживущие объекты (крупные высокоуровневые объекты, синглтоны, менеджеры ресурсов и проч.). Когда заполняется эта область, выполняется полная сборка мусора (full, major collection), которая обрабатывает все созданные JVM объекты.     Permanent Generation (non-heap) - Здесь хранится метаинформация, используемая JVM (используемые классы, методы и т.п.)."
  },
  {
    "category": "Java core.",
    "question": "Как работает сборщик мусора (garbage collector)?",
    "answer": "Во-первых что стоит сказать, что у сборщика мусора есть несколько алгоритмов работы, он не один. Когда происходит очистка памяти? Если память в Первой куче полностью заполнена, то туда идет сборщик мусора и делает свою работу) Какую именно, зависит  от обстоятельств… Например если в  первой кучи много мусора(т.е. объектов с нулевой ссылкой), то сборщик мусора помечает эти объекты, далее те что остались объекты со ссылками он их переносит в Выжившую кучу, а в первой куче он просто все удаляет.  Ситуация  другая, в первой кучи мало мусора, но очень много рабочих объектов. Как поступает в этом случае сборщик  мусора? Он  помечает мусор, удаляет его и  оставшиеся объекты компонует. Также следует заметить что при нехватке места в Выжившей куче, объекты  переносятся в старую кучу, там  хранятся как правило долго живущие объекты. Также следует заметить что сборщик мусора вызывается сам периодически, а не только когда памяти не хватает."
  },
  {
    "category": "Java core.",
    "question": "Расскажите про приведение типов. Что такое понижение и повышение типа? Когда вы получаете ClassCastException?",
    "answer": "Приведение  типов это установка типа переменной или объекта отличного от текущего. В ждава есть два вида приведения:      автоматическое     не автоматическое  Автоматическое  происходит например: byte-> short->int->long->float->double тоесть если мы расширяем тип, то явное преобразование не требуется, приведение происходит автоматически. Если же мы сужаем, то необходимо явно указывать приведение типа. В случае же с объектами, то мы можем  сделать автоматическое приведение от наследника к родителю, но никак  не наоборот, тогда вылетит ClassCastException."
  },
  {
    "category": "Java core.",
    "question": "Что такое статический класс, какие особенности его использования?",
    "answer": "Статическим классом может быть только внутренний клас(определение класса размещается внутри другого класса). В объекте обычного внутреннего класса хранится ссылка на объект внешнего класса. Внутри статического внутреннего класса такой ссылки нет. То есть: Для создания объекта статического внутреннего класса не нужен объект внешнего класса. Из объекта статического вложенного класса нельзя обращаться к нестатическим членам внешнего класса напрямую. И еще обычные внутренние классы не могут содержать статические методы и члены. Зачем вообще нужны внутренние классы? – Каждый внутренний класс способен независимо  наследовать определенную реализацию. Таким образом внутренний класс не ограничен при наследовании в ситуациях, когда внешний класс уже наследует реализацию. То есть это как бы вариант решения проблемы множественного наследования."
  },
  {
    "category": "Java core.",
    "question": "Каким образом из вложенного класса получить доступ к полю внешнего класса.",
    "answer": "Если класс внутренний то: Внешнийкласс.this.Поле внешнего класса Если класс статический внутренний(вложенный),то в методе нужно создать объект внешнего класса, и получить доступ к его полю.Или второй вариант  объявить это поле внешнего класса как  static"
  },
  {
    "category": "Java core.",
    "question": "Какие существуют типы вложенных классов? Для чего они используются?",
    "answer": "Вложенные классы существуют внутри других классов.  Нормальный класс - полноценный член пакета. Вложенные классы, которые стали доступны начиная с Java 1.1, могут быть четырех типов:      статические члены класса     члены класса     локальные классы     анонимные классы  Статические члены классов (static nested classes) - как и любой другой статический метод, имеет доступ к любым статическим методам своего внешнего класса, в том числе и к приватным. К нестатическим полям и методам обрамляющего класса он не может обращатся напрямую. Он может использовать их только через ссылку на экземпляр класса родителя. Члены класса - локальные классы, объявленные внутри блока кода. Эти классы видны только внутри блока. Анонимные классы -  Эти типы классов не имеют имени и видны только внутри блока."
  },
  {
    "category": "Java core.",
    "question": "Возможно ли при переопределении (override) метода изменить: (Модификатор доступа Возвращаемый тип Тип аргумента или количество Имя аргументов Изменять порядок, количество или вовсе убрать секцию throws?)",
    "answer": "Да, если расширять (package -> protected -> public)     Да, если выполняется Downcasting(понижающее преобразование, преобразование вниз по иерархии) то есть возвращаемый тип в переопределенном методе класса наследника должен быть НЕ шире чем в классе родителе (Object -> Number -> Integer)     Нет, в таком случае происходит Overload(перегрузка)     Да     Возможно изменять порядок. Возможно вовсе убрать секцию throws в методе, так как она уже определена. Так же возможно добавлять новые исключения, которые наследуются от объявленных или исключения времени выполнения.  Переопределение методов действует при наследовании классов, т.е. в классе наследнике объявлен метод с такой же сигнатурой что и в классе родителе. Значит этот метод переопределил метод своего суперкласса. Несколько нюансов по этому поводу:      Модификатор доступа в методе класса наследника должен быть НЕ уже чем в классе родителе, иначе будет ошибка компиляции.     Описание исключения в переопределенном методе класса наследника должен быть НЕ шире чем в классе родителе, иначе ошибка компиляции.     Метод обьявленный как \"private\" в классе родителе нельзя переопределить!"
  },
  {
    "category": "Java core.",
    "question": "Что такое autoboxing?",
    "answer": "Autoboxing/Unboxing - автоматическое преобразование между скалярными типами Java и соответствующими типами-врапперами (например, между int - Integer). Наличие такой возможности сокращает код, поскольку исключает необходимость выполнения явных преобразований типов в очевидных случаях."
  },
  {
    "category": "Java core.",
    "question": "Что такое Generics?",
    "answer": "Java Generics\" - это технический термин, обозначающий набор свойств языка позволяющих определять и использовать обобщенные типы и методы. Обобщенные типы или методы отличаются от обычных тем, что имеют типизированные параметры.  Примером дженериков или обобщенных типов может служить библитека с коллекциями в Java. Например, класс LinkedList<E> - типичный обобщенный тип. Он содержит параметр E, который представляет тип элементов, которые будут храниться в коллекции. Вместо того, чтобы просто использовать LinkedList, ничего не говоря о типе элемента в списке, мы можем использовать LinkedList<String> или LinkedList<Integer>.  Создание объектов обобщенных типов происходит посредством замены параметризированных типов реальными типами данных. Класс типа LinkedList<E> -  обобщенный тип, который содержит параметр E. Создание объектов, типа LinkedList<String> или LinkedList<Integer> называются параметризированными типами, а String и Integer - реальные типы аргументов."
  },
  {
    "category": "Java core.",
    "question": "Какова истинная цель использования обобщенных типов в Java?",
    "answer": "Обобщенные типы в Java были изобретены, в первую очередь, для реализации обобщенных коллекций."
  },
  {
    "category": "Java core.",
    "question": "Каким образом передаются переменные в методы, по значению или по ссылке?",
    "answer": "В java параметры в методы передаются по значению, тоесть создаются копии параметров и с ними ведется работа в методе. В случае с примитивными типами, то при передачи параметра сама переменная не будет меняться так как в метод просто копируется ее значение. А вот при передачи объекта копируется ссылка на объект, тоесть если в методе мы поменяем состояние объекта, то и за методом состояние объекта тоже поменяется. Но если мы этой копии ссылки попытаемся присвоить новую ссылку на обьект, то старая ссылка у нас не изменится.  В случае передачи по значению параметр копируется. Изменение параметра не будет заметно на вызывающей стороне.  В Java объекты всегда передаются по ссылке, а примитивы - по значениюю."
  },
  {
    "category": "Java core.",
    "question": "Какие методы есть у класса Object?",
    "answer": "Object это базовый класс для всех остальных объектов в Java. Каждый класс наследуется от Object. Соответственно все классы наследуют методы класса Object. Методы класса Object:      public final native Class getClass()     public native int hashCode()     public boolean equals(Object obj)     protected native Object clone() throws CloneNotSupportedException     public String toString()     public final native void notify()     public final native void notifyAll()     public final native void wait(long timeout) throws InterruptedException     public final void wait(long timeout, int nanos) throws InterruptedException     public final void wait() throws InterruptedException     protected void finalize() throws Throwable"
  },
  {
    "category": "Java core.",
    "question": "Правила переопределения метода Object.equals().",
    "answer": "Используйте оператор == что бы проверить ссылку на объект, переданную в метод equals. Если ссылки совпадают - вернуть true. Это не обязательно, нужно скорее для оптимизации, но может сэкономить время в случае \"тяжёлых\" сравнений.     Используйте оператор instanceof для проверки типа аргумента. Если типы не совпадают, вернуть false.      Преобразуйте аргумент к корректному типу. Так как на предыдущем шаге мы выполнили проверку, преобразование корректно.      Пройтись по всем значимым полям объектов и сравнить их друг с другом. Если все поля равны - вернуть true. Для сравнения простых типов использовать ==. Для полей со ссылкой на объекты использовать equals. float преобразовывать в int  с помощью Float.floatToIntBits и сравнить с помощью ==. double преобразовывать в long  с помощью Double.doubleToLongBits и сравнить с помощью ==. Для коллекций вышеперечисленные правила применяются к каждому элементу коллекции. Нужно учитывать возможность null полей/объектов. Очерёдность сравнения полей может существенно влиять на производительность.     Закончив реализацию equals задайте себе вопрос, является ли метод симметричным, транзитивным и непротиворечивым.  И ещё несколько дополнительных правил.      Переопределив equals, всегда переопределять hashCode.     Не использовать сложную семантику в equals (типа определения синонимов). equals должен сравнивать поля объектов, не более."
  },
  {
    "category": "Java core.",
    "question": "Если вы хотите переопределить equals(), какие условия должны удовлетворяться для переопределенного метода?",
    "answer": "Метод equals() обозначает отношение эквивалентности объектов. Эквивалентным называется отношение, которое является симметричным, транзитивным и рефлексивным.      Рефлексивность: для любого ненулевого x, x.equals(x) вернет true      Транзитивность: для любого ненулевого x, y и z, если x.equals(y) и y.eqals(z) вернет true, тогда и x.equals(z) вернет true      Симметричность: для любого ненулевого x и y, x.equals(y) должно вернуть true, тогда и только тогда, когда y.equals(x) вернет true.  Также для любого ненулевого x, x.equals(null) должно вернуть false."
  },
  {
    "category": "Java core.",
    "question": "Какая связь между hashCode и equals?",
    "answer": "Объекты равны, когда a.equals(b)=true и a.hashCode==b.hashcode ->true Но необязательно, чтобы два различных объекта возвращали различные хэш коды(такая ситуация называется коллизией)."
  },
  {
    "category": "Java core.",
    "question": "Каким образом реализованы методы hashCode и equals в классе Object?",
    "answer": "Реализация метода equals в классе Object сводится к проверке на равенство двух ссылок: Реализация же метода hashCode класса Object сделана нативной, т.е. определенной не с помощью Java-кода: Он обычно возвращает адрес объекта в памяти"
  },
  {
    "category": "Java core.",
    "question": "Что будет, если переопределить equals не переопределяя hashCode? Какие могут возникнуть проблемы?",
    "answer": "Они будут неправильно хранится в контейнерах, использующих хэш коды, таких как HashMap, HashSet. Например HashSet хранит элементы в случайном (на первый взгляд) порядке. Дело в том, что для быстрого поиска HashSet расчитывает для каждлого элемента hashCode и именно по этому ключу ищет и упорядочивает элементы внутри себя"
  },
  {
    "category": "Java core.",
    "question": "Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode?",
    "answer": "Есть. Необходимо использовать уникальные, лучше примитивные поля, такие как id, uuid, например. Причем, если эти поля задействованы при вычислении hashCode, то нужно их задействовать при выполнении equals. Общий совет: выбирать поля, которые с большой долью вероятности будут различаться."
  },
  {
    "category": "Java core.",
    "question": "Для чего нужен метод hashCode()?",
    "answer": "Существуют коллекции(HashMap, HashSet), которые используют хэш код, как основу при работе с объектами. А если хэш для равных объектов будет разным, то в HashMap будут два равных значения, что является ошибкой. Поэтому необходимо соответствующим образом переопределить метод hashCode(). Х   Хеширование - преобразование входного массива данных произвольной длины в выходную битовую строку фиксированной длины. Такие преобразования также называются хеш-функциями или функциями свёртки, а их результаты называют хешем или хеш-кодом. Хе Хеш-таблице - это структура данных, реализующая интерфейс ассоциативного массива, а именно, она позволяет хранить пары (ключ, значение) и выполнять три операции: операцию добавления новой пары, операцию поиска и операцию удаления пары по ключу. Выполнение операции в хеш-таблице начинается с вычисления хеш-функции от ключа. Получающееся хеш-значение i = hash(key) играет роль индекса в массиве H. Затем выполняемая операция (добавление, удаление или поиск) перенаправляется объекту, который хранится в соответствующей ячейке массива H[i]. Одним из методов построения хеш-функции есть метод деления с остатком (division method) состоит в том, что ключу k ставится в соответствие остаток от деления k на m, где m - число возможных хеш-значений."
  },
  {
    "category": "Java core.",
    "question": "Правила переопределения метода Object.hashCode().",
    "answer": "При реализации hashCode используется несколько простых правил. Прежде всего, при вычислении хеш-кода следует использовать те же поля, которые сравниваются в equals. Это, во-первых, даст равенство хеш-кодов для равных обектов, во-вторых, распределено полученное значение будет точно так же, как и исходные данные. Теоретически, можно сделать так, чтобы хеш-код всегда был равен 0, и это будет абсолютно легальная реализация. Другое дело, что ее ценность будет равна тому же самому нулю. Далее. Несмотря на то, что хеш-коды равных объектов должны быть равны, обратное неверно! Два неравных объекта могут иметь равные хеш-коды. Решающее значение имеет не уникальность, а скорость вычисления, потому как это приходится делать очень часто. Потому, в некоторых случаях имеет смысл посчитать хеш-код заранее и просто выдавать его по запросу. Прежде всего это стоит делать тогда, когда вычисление трудоемко, а объект неизменен."
  },
  {
    "category": "Java core.",
    "question": "Расскажите про клонирование объектов. В чем отличие между поверхностным и глубоким клонированием?",
    "answer": "Чтобы объект можно было клонировать, он должен реализовать интерфейс Cloneable(маркер). Использование этого интерфейса влияет на поведение метода \"clone\" класс Object. Таким образом  myObj.clone() создаст нам клон нашего объекта, но этот клон будет поверхностный. Что значит поверхностным? Это значит что клонируется только примитивные поля класса, ссылочные поля не клонируются! Для того, чтоб произвести глубокое клонирование, необходимо в клонируемом классе переопределить метод clone() и в нем произвести клонирование изменяемых полей объекта."
  },
  {
    "category": "Java core.",
    "question": "Правила переопределения метода Object.clone().",
    "answer": "Метод clone() в Java используется для клонирования объектов. Т.к. Java работает с объектами с помощью ссылок, то простым присваиванием тут не обойдешься, ибо в таком случае копируется лишь адрес, и мы получим две ссылки на один и тот же объект, а это не то, что нам нужно. Механизм копирования обеспечивает метод clone() класса Object.  clone() действует как конструктор копирования. Обычно он вызывает метод clone() суперкласса и т.д. пока не дойдет до Object.  Метод clone() класса Object создает и возвращает копию объекта с такими же значениями полей. Object.clone() кидает исключение CloneNotSupportedException если вы пытаетесь клонировать объект не реализующий интерфейс Cloneable. Реализация по умолчанию метода Object.clone() выполняет неполное/поверхностное (shallow) копирование. Если вам нужно полное/глубокое (deep) копирование класса то в методе clone() этого класса, после получения клона суперкласса, необходимо скопировать нужные поля.  Синтаксис вызова clone() следующий:"
  },
  {
    "category": "Java core.",
    "question": "Где и как вы можете использовать закрытый конструктор?",
    "answer": "Например в качестве паттерна Синглетон. В том же классе создается статический метод. Где и создается экземпляр класса, конечно если он уже не создан, тогда он просто возвращается методом."
  },
  {
    "category": "Java core.",
    "question": "Что такое конструктор по умолчанию?",
    "answer": "В Java если нет явным образом опредёленных конструкторов в классе, то компилятор использует конструктор по умолчанию, опредёленный неявным способом, который аналогичен \"чистому\", конструктору по умолчанию. Конструктор по умолчанию - это довольно простая конструкция, которая сводится к созданию для типа конструктора без параметров. Так, например, если при объявлении нестатического класса не объявить пользовательский конструктор (не важно, с параметрами или без них), то компилятор самостоятельно сгенерирует конструктор без параметров. Некоторые программисты явным образом задают конструктор по умолчанию по привычке, чтобы не забыть в дальнейшем, но это не обязательно В Java если производный класс не вызывает явным образом конструктор базового класса (в Java используя super() в первой строчке), то конструктор по умолчанию вызывается неявно. Если базовый класс не имеет конструктора по умолчанию, то это считается ошибкой."
  },
  {
    "category": "Java core.",
    "question": "Опишите метод Object.finalize().",
    "answer": "Метод finalize(). Java обеспечивает механизм, который является аналогичным использованию деструкторов в С ++, который может использоваться для того, чтобы произвести процесс очистки перед возвращением управления операционной системе.  Применяя метод finalize(), можно определять специальные действия, которые будут выполняться тогда, когда объект будет использоваться сборщиком мусора. Данный метод вызывается при уничтожении объекта автоматическим сборщиком мусора (garbage collector). В классе Object он ничего не делает, однако в классе-наследнике позволяет описать все действия, необходимые для корректного удаления объекта, такие как закрытие соединений с БД, сетевых соединений, снятие блокировок на файлы и т.д. В обычном режиме напрямую этот метод вызывать не нужно, он отработает автоматически. Если необходимо, можно обратиться к нему явным образом. Его синтаксис:  protected void finalize( ) throws Throwable  Ссылки не являются собранным мусором  только объекты - собранный мусор."
  },
  {
    "category": "Java core.",
    "question": "Чем отличаются слова final, finally и finalize?",
    "answer": "final - Нельзя наследоваться от файнал класса. Нельзя переопределить файнал метод. Нельзя изменить сначение файнал поля. finally - используется при обработке ошибок, вызывается всегда, даже если произошла ошибка(кроме System.exit(0)). Удобно использовать для освобождения ресурсов. finalize() - вызывается перед тем как сборщик мусора будет проводить освобождение памяти. Не рекомендуется использовать для освобождения системных ресурсов, так как не известно когда сборщик мусора будет производить свою очистку. Вообще данный метод мало кто использует. Единственно что можно использовать этот метод для закрытия ресурса что должен работать на протяжении всей работы программы и закрываться по ее окончанию. Еще можно использовать метод для защиты от так называемых «дураков», проверять, освобождены ли ресурсы, если нет, то закрыть их."
  },
  {
    "category": "Java core.",
    "question": "Опишите иерархию исключений.",
    "answer": "Все классы-исключения расширяют класс Throwable - непосредственное расширение класса object.  У класса Throwable и у всех его расширений по традиции два конструктора:        Throwable о - конструктор по умолчанию       Throwable (String message) - создаваемый объект будет содержать произвольное сообщение message.   Записанное в конструкторе сообщение можно получить затем методом getMessage (). Если объект создавался конструктором по умолчанию, то данный метод возвратит null.  Метод toString возвращает краткое описание события, именно он работал в предыдущих листингах.  Три метода выводят сообщения обо всех методах, встретившихся по пути \"полета\" исключения:       printstackTrace() - выводит сообщения в стандартный вывод, как правило, это консоль       printStackTrace(PrintStream stream) - выводит сообщения в байтовый поток stream       printStackTrace(PrintWriter stream) - выводит сообщения в символьный поток stream.   У класса Throwable два непосредственных наследника - классы Error и Exception. Они не добавляют новых методов, а служат для разделения классов-исключений на два больших семейства - семейство классов-ошибок (error) и семейство собственно классов-исключений (exception).  Классы-ошибки, расширяющие класс Error, свидетельствуют о возникновении сложных ситуаций в виртуальной машине Java. Их обработка требует глубокого понимания всех тонкостей работы JVM. Ее не рекомендуется выполнять в обычной программе. Не советуют даже выбрасывать ошибки оператором throw. He следует делать свои классы-исключения расширениями класса Error или какого-то его подкласса.   Имена классов-ошибок, по соглашению, заканчиваются словом Error.  Классы-исключения, расширяющие класс Exception, отмечают возникновение обычной нештатной ситуации, которую можно и даже нужно обработать. Такие исключения следует выбросить оператором throw. Классов-исключений очень много, более двухсот. Они разбросаны буквально по всем пакетам J2SDK. В большинстве случаев вы способны подобрать готовый класс-исключение для обработки исключительных ситуаций в своей программе. При желании можно создать и свой класс-исключение, расширив класс Exception или любой его подкласс.   Среди классов-исключений выделяется класс RuntimeException - прямое расширение класса Exception. В нем и его подклассах отмечаются исключения, возникшие при работе JVM, но не столь серьезные, как ошибки. Их можно обрабатывать и выбрасывать, расширять своими классами, но лучше доверить это JVM, поскольку чаще всего это просто ошибка в программе, которую надо исправить. Особенность исключений данного класса в том, что их не надо отмечать в заголовке метода пометкой throws.   Имена классов-исключений, по соглашению, заканчиваются словом Exception."
  },
  {
    "category": "Java core.",
    "question": "Какие виды исключений в Java вы знаете, чем они отличаются?",
    "answer": "Все исключительные ситуации можно разделить на две категории: проверяемые(checked) и непроверяемые(unchecked). Все исключения, порождаемые от Throwable, можно разбить на три группы. Они определяются тремя базовыми типами: наследниками Throwable - классами Errorи Exception, а также наследником Exception - RuntimeException. Ошибки, порожденные от Exception (и не являющиеся наследниками RuntimeException ), являются проверяемыми. Т.е. во время компиляции проверяется, предусмотрена ли обработка возможных исключительных ситуаций. Как правило, это ошибки, связанные с окружением программы (сетевым, файловым вводом-выводом и др.), которые могут возникнуть вне зависимости от того, корректно написан код или нет. Например, открытие сетевого соединения или файла может привести к возникновению ошибки и компилятор требует от программиста предусмотреть некие действия для обработки возможных проблем. Таким образом повышается надежность программы, ее устойчивость при возможных сбоях. Исключения, порожденные от RuntimeException, являются непроверяемыми и компилятор не требует обязательной их обработки. Как правило, это ошибки программы, которые при правильном кодировании возникать не должны (например, IndexOutOfBoundsException- выход за границы массива, java.lang.ArithmeticException- деление на ноль). Поэтому, чтобы не загромождать программу, компилятор оставляет на усмотрение программиста обработку таких исключений с помощью блоков try-catch. Исключения, порожденные от Error, также не являются проверяемыми. Они предназначены для того, чтобы уведомить приложение о возникновении фатальной ситуации, которую программным способом устранить практически невозможно (хотя формально обработчик допускается). Они могут свидетельствовать об ошибках программы, но, как правило, это неустранимые проблемы на уровне JVM. В качестве примера можно привести StackOverflowError (переполнение стека), OutOfMemoryError (нехватка памяти). Методы, код которых может порождать проверяемые исключения, должны либо сами их обрабатывать, либо в заголовке метода должно быть указано ключевое слово throws с перечислением необрабатываемых проверяемых исключений. На непроверяемые ошибки это правило не распространяется. Переопределенный (overridden) метод не может расширять список возможных исключений исходного метода."
  },
  {
    "category": "Java core.",
    "question": "Что такое checked и unchecked Exception?",
    "answer": "Checked исключения, это те, которые должны обрабатываться блоком catch или описываться в сигнатуре метода. Unchecked могут не обрабатываться и не быть описанными.  Unchecked исключения в Java - наследованные от RuntimeException, Checked - от Exception.  Пример unchecked исключения - NullPointerException, checked исключения - IOException."
  },
  {
    "category": "Java core.",
    "question": "Как создать свой unchecked Exception?",
    "answer": "Унаследоваться от RuntimeException."
  },
  {
    "category": "Java core.",
    "question": "Какие есть Unchecke exeption?",
    "answer": ""
  },
  {
    "category": "Java core.",
    "question": "Что такое Error?",
    "answer": "Исключения, порожденные от Error, не являются проверяемыми. Они предназначены для того, чтобы уведомить приложение о возникновении фатальной ситуации, которую программным способом устранить практически невозможно (хотя формально обработчик допускается). Они могут свидетельствовать об ошибках программы, но, как правило, это неустранимые проблемы на уровне JVM. В качестве примера можно привести StackOverflowError (переполнение стека), OutOfMemoryError (нехватка памяти). Методы, код которых может порождать проверяемые исключения, должны либо сами их обрабатывать, либо в заголовке метода должно быть указано ключевое слово throws с перечислением необрабатываемых проверяемых исключений. На непроверяемые ошибки это правило не распространяется."
  },
  {
    "category": "Java core.",
    "question": "Опишите работу блока try-catch-finally.",
    "answer": "Если срабатывает один из блоков catch, то остальные блоки в данной конструкции try-catch выполняться не будут. Cвойством транзакционности исключения не обладают - действия, произведенные в блоке try до возникновения исключения, не отменяются поcле его возникновения."
  },
  {
    "category": "Java core.",
    "question": "Возможно ли использование блока try-finally (без catch)?",
    "answer": "try может быть в паре с finally, без catch. Работает это точно так же - после выхода из блока try выполняется блок finally. Это может быть полезно, например, в следующей ситуации. При выходе из метода вам надо произвести какое-либо действие. А return в этом методе стоит в нескольких местах. Писать одинаковый код перед каждым return нецелесообразно. Гораздо проще и эффективнее поместить основной код в try, а код, выполняемый при выходе - в finally."
  },
  {
    "category": "Java core.",
    "question": "Всегда ли исполняется блок finally?",
    "answer": "Не всегда например в следующих ситуациях:      Существуют потоки-демоны - потоки предоставляющие некие сервисы, работая в фоновом режиме во время выполнения программы, но при этом не являются ее неотъемлеммой частью.Таким образом когда все потоки не демоны завершаются, программа завершает свою работу. В потоках демонах блок finally не выполняеться, они прерываются внезапно.     System.exit(0)     если в блоке finally произошло исключение и нет обработчика, то оставшийся код в блоке finally может не выполнятся."
  },
  {
    "category": "Java core.",
    "question": "Какие есть оссобенности класса String? что делает метод intern().",
    "answer": "Внутреннее состояние класса String нельзя изменить после его создания, т.е. этот класс неизменяемый (immutable) поэтому когда вы пишете String str = \"One\" + \"Two\"  создается три! объекта класса String.      От него нельзя унаследоваться, потому что класс String объявлен как final: public final class String     Метод hashCode класса String переписан и возвращает: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]      У класса String есть метод public String intern(), который возвращает строку в каноническом ее представлении из внутреннего пула строк, поддерживаемого JVM, он нужен чтобы вместо String.equals() использовать ==.  Понятно, что оператор сравнения ссылок выполняется гораздо быстрее, чем посимвольное сравнение строк. Используют в основном, где приходится сравнивать много строк, например в каких нибудь XML парсерах. А вообще по увеличению производительности ещё вопрос. Ибо метод intern() тогда должен выполняться быстрее чем equals(), каждый раз когда вы вызываете метод intern() просматривается пул строк на наличие такой строки и если такая уже есть в пуле, то возвращается ссылка на нее.Сравниваются они через equal()."
  },
  {
    "category": "Java core.",
    "question": "Можно ли наследовать строковый тип, почему?",
    "answer": "Классы объявлены final, поэтому наследоваться не получится."
  },
  {
    "category": "Java core.",
    "question": "Почему строка является популярным ключом в HashMap в Java?",
    "answer": "Поскольку строки неизменны, их хэшкод кэшируется в момент создания, и не требует повторного пересчета. Это делает строки отличным кандидатом для ключа в Map и они обрабатываются быстрее, чем другие объекты-ключи HashMap. Вот почему строки преимущественно используются в качестве ключей HashMap."
  },
  {
    "category": "Java core.",
    "question": "Дайте определение понятию конкатенация строк.",
    "answer": "Конкатенация - операция объединения строк. Результатом является объединения второй строки с окончанием первой. Операция конкатенации могут быть выполнены так:"
  },
  {
    "category": "Java core.",
    "question": "Как перевернуть строку?",
    "answer": "StringBuilder(stroka).reverse"
  },
  {
    "category": "Java core.",
    "question": "Как сравнить значение двух строк?",
    "answer": "Строка в Java - это отдельный объект, который может не совпадать с другим объектом, хотя на экране результат выводимой строки может выглядеть одинаково. Оператор == (а также !=) работает с ссылками объекта String. Если две переменные String указывают на один и тот же объект в памяти, сравнение вернет результат true. В противном случае результат будет false, несмотря на то что текст может содержать в точности такие же символы. Для сравнения посимвольно на эквивалентность необходимо использовать метод equals()."
  },
  {
    "category": "Java core.",
    "question": "Как обрезать пробелы в начале и конце строки?",
    "answer": "trim"
  },
  {
    "category": "Java core.",
    "question": "Дайте определение понятию \"пул строк\".",
    "answer": "Пул строк - это набор строк, который хранится в памяти Java heap. Мы знаем, что String это специальный класс в Java, и мы можем создавать объекты этого класса, используя оператор new точно так же, как и создавать объекты, предоставляя значение строки в двойных кавычках. Диаграмма ниже объясняет, как пул строк размещается в памяти Java heap и что происходит, когда мы используем различные способы создания строк. Пул строк возможен исключительно благодаря неизменяемости строк в Java и реализации идеи интернирования строк. Пул строк помогает экономить большой объем памяти, но с другой стороны создание строки занимает больше времени. Когда мы используем двойные кавычки для создания строки, сначала ищется строка в пуле с таким же значением, если находится, то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка. Тем не менее, когда мы используем оператор new, мы принуждаем класс String создать новый объект строки, а затем мы можем использовать метод intern() для того, чтобы поместить строку в пул, или получить из пула ссылку на другой объект String с таким же значением."
  },
  {
    "category": "Java core.",
    "question": "Можно ли синхронизировать доступ к строке?",
    "answer": "String сам по себе потокобезопасный класс. Если мы мы работаем с изменяемыми строками, то нужно использовать StringBuffer."
  },
  {
    "category": "Java core.",
    "question": "Как правильно сравнить значения строк двух различных объектов типа String и StringBuffer?",
    "answer": "Привести их к одному типу и сравнить."
  },
  {
    "category": "Java core.",
    "question": "Почему строка неизменная и финализированная в Java?",
    "answer": "Есть несколько преимуществ в неизменности строк:      Строковый пул возможен только потому, что строка неизменна в Java, таким образом виртуальная машина сохраняет много места в памяти(heap space), поскольку разные строковые переменные указывают на одну переменную в пуле. Если бы строка не была неизмененяемой, тогда бы интернирование строк не было бы возможным, потому что если какая-либо переменная изменит значение, это отразится также и на остальных переменных, ссылающихся на эту строку.     Если строка будет изменяемой, тогда это станет серьезной угрозой безопасности приложения. Например, имя пользователя базы данных и пароль передаются строкой для получения соединения с базой данных и в программировании сокетов реквизиты хоста и порта передаются строкой. Так как строка неизменяемая, её значение не может быть изменено, в противном случае любой хакер может изменить значение ссылки и вызвать проблемы в безопасности приложения.     Строки используются в Java classloader и неизменность обеспечивает правильность загрузки класса при помощи Classloader. К примеру, задумайтесь об экземпляре класса, когда вы пытаетесь загрузить java.sql.Connection класс, но значение ссылки изменено на myhacked.Connection класс, который может осуществить нежелательные вещи с вашей базой данных.     Поскольку строка неизменная, её hashcode кэшируется в момент создания и нет необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в Map и его обработка будет быстрее, чем других ключей HashMap. Это причина, почему строка наиболее часто используемый объект, используемый в качестве ключа HashMap."
  },
  {
    "category": "Java core.",
    "question": "Напишите метод удаления данного символа из строки.",
    "answer": "Мы можем использовать метод replaceAll для замены всех вхождений в строку другой строкой. Обратите внимание на то, что метод получает в качестве аргумента строку, поэтому мы используем класс Character для создания строки из символа, и используем её для замены всех символов на пустую строку."
  },
  {
    "category": "Java core.",
    "question": "Что такое рефлексия?",
    "answer": "Рефлексия используется для получения или модификации информации о типах во время выполнения программы. Этот механизм позволяет получить сведения о классах, интерфейсах, полях, методах, конструкторах во время исполнения программы. При этом не нужно знать имена классов, методов или интерфейсов. Также этот механизм позволяет создавать новые объекты, выполнять методы и получать и устанавливать значения полей"
  },
  {
    "category": "Java core.",
    "question": "Что произойдет со сборщиком мусора (GC), если во время выполнения метода finalize() некоторого объекта произойдет исключение?",
    "answer": "Во время старта JVM запускается поток finalizer, который работает в фоне. Этот поток имеет метод runFinalizer, который игнорирует все исключения методов finalize объектов перед сборкой мусора. То есть если во время выполнения метода finalize возникнет исключительная ситуация, его выполнение будет остановлено и это никак не скажется на работоспособности самого сборщика мусора (garbage collector)."
  },
  {
    "category": "Java core.",
    "question": "Что такое интернационализация, локализация?",
    "answer": "Интернационализация (internationalization, а для краткости - i18n) - такой способ создания приложений, при котором их можно легко адаптировать для разных аудиторий, говорящих на разных языках. Локализацияlocalization а для краткости - l10n) -  адаптация интерфейса приложения под несколько языков. Добавление нового языка может внести определенные сложности в локализацию интерфейса."
  },
  {
    "category": "Java core.",
    "question": "Что такое Аннотации в Java?",
    "answer": "Аннотации - это своего рода метатеги, которые добавляются к коду и применяются к объявлению пакетов, классов, конструкторов, методов, полей, параметров и локальных переменных. Аннотации всегда обладают некоторой информацией и связывают эти \"дополнительные данные\" и все перечисленные конструкции языка. Фактически аннотации представляют собой их дополнительные модификаторы, применение которых не влечет за собой изменений ранее созданного кода."
  },
  {
    "category": "Java core.",
    "question": "Какие функции выполняет Аннотации?",
    "answer": "Аннотация выполняет следующие функции:    дает необходимую информацию для компилятора     дает информацию различным инструментам для генерации другого кода, конфигураций и т. д.     может использоваться во время работы кода Самая часто встречаемая аннотация, которую встречал любой программист, даже начинающий это @Override."
  },
  {
    "category": "Java core.",
    "question": "Какие встроенные аннотации в Java вы знаете?",
    "answer": "В языке Java SE определено несколько встроенных аннотаций, большинство из их являются специализированными. Четыре типа @Retention, @Documented, @Target и @Inherited - из пакета java.lang.annotation. Из оставшиеся выделяются - @Override, @Deprecated, @SafeVarargs и @SuppressWarnings - из пакета java.lang. Широкое использование аннотаций в различных технологиях и фреймворках обуславливается возможностью сокращения кода и снижения его связанности."
  },
  {
    "category": "Java core.",
    "question": "Что делают аннотации @Retention, @Documented, @Target и @Inherited?",
    "answer": "Эти аннотации, имеют следующее значение:      @Retention - эта аннотация предназначена для применения только в качестве аннотации к другим аннотациям, позволяет указать жизненный цикл аннотации: будет она присутствовать только в исходном коде, в скомпилированном файле, или она будет также видна и в процессе выполнения. Выбор нужного типа зависит от того, как вы хотите использовать аннотацию.      @Documented - это маркер-интерфейс, который сообщает инструменту, что аннотация должна быть документирована.     @Target - эта аннотация задает тип объявления, к которым может быть применима аннотация. Принимает один аргумент, который должен быть константой из перечисления ElementType, это может быть поле, метод, тип и т.д. Например, чтобы указать, что аннотация применима только к полям и локальным переменным: @Targer({ ElementType.FIELD, ElementTyle.LOCAL_VARIABLE } )     @Inherited - это аннотация-маркер, которая может применяться в другом объявление аннотации, она касается только тех аннотаций, что будут использованы в объявлениях классов. Эта аннотация позволяет аннотации супер класса быть унаследованной в подклассе."
  },
  {
    "category": "Java core.",
    "question": "Что делают аннотации @Override, @Deprecated, @SafeVarargs и @SuppressWarnings?",
    "answer": "Эти аннотации предназначены для:      @Override - аннотация-маркер, которая может применяться только к методам. Метод, аннотированный как @Override, должен переопределять метод супер класса.     @Deprecated - указывает, что объявление устарело и должно быть заменено более новой формой.     @SafeVarargs - аннотация-маркер, применяется к методам и конструкторам. Она указывает, что никакие небезопасные действия, связанные с параметром переменного количества аргументов, недопустимы. Применяется только к методам и конструкторам с переменным количеством аргументов, которые объявлены как static или final.     @SuppressWarnings - эта аннотация указывает, что одно или более предупреждений, которые могут быть выданы компилятором следует подавить."
  },
  {
    "category": "Java core.",
    "question": "Какой жизненный цикл аннотации можно указать с помощью @Retention?",
    "answer": "Существует 3 возможные варианты чтобы указать где аннотация будет жить. Они инкапсулированы в перечисление java.lang.annotation.RetentionPolicy. Это SOURSE, CLASS, RUNTIME.      SOURCE - содержаться только в исходном файле и отбрасываются при компиляции.     CLASS - сохраняются в файле, однако они недоступны JVM во время выполнения.     RUNTIME - сохраняются в файле во время компиляции и остаются доступными JVM во время выполнения."
  },
  {
    "category": "Java core.",
    "question": "К каким элементам можно применять аннотацию, как это указать?",
    "answer": "Для того чтобы ограничить использование аннотации её нужно проаннотировать. Для этого существует аннотация @Target.      @Target(ElementType.PACKAGE) - только для пакетов      @Target(ElementType.TYPE) - только для классов      @Target(ElementType.CONSTRUCTOR) - только для конструкторов      @Target(ElementType.METHOD) - только для методов      @Target(ElementType.FIELD) - только для атрибутов(переменных) класса      @Target(ElementType.PARAMATER) - только для параметров метода      @Target(ElementType.LOCAL_VARIABLE) - только для локальных переменных.  В случае если вы хотите, что бы ваша аннотация использовалась больше чем для одного типа параметров, то можно указать @Target следующим образом: тут мы говорим, аннотацию можно использовать только для параметров метода и для локальных переменных."
  },
  {
    "category": "Java core.",
    "question": "Как создать свою Аннотацию?",
    "answer": "Написать свою аннотацию не так сложно, как могло бы казаться. В следующем коде приведено объявление аннотации. как вы видите на месте где обычно пишут class или interface у нас написано @interface. Структура практически та же, что и у интерфейсов, только пишется @interface.      @interface - указывает на то, что это аннотация     default - говорит про то, что метод по умолчанию будет возвращать определённое значение.  Аннотация готова теперь ею можно пользоваться, также аннотацию можно сконфигурировать."
  },
  {
    "category": "Java core.",
    "question": "Атрибуты каких типов допустимы в аннотациях?",
    "answer": "Атрибуты могут иметь только следующие типы: примитивы      String     Class или «any parameterized invocation of Class»     enum     annotation     массив элементов любого из вышеперечисленных типов   Последний пункт надо понимать как то, что допустимы только одномерные массивы."
  },
  {
    "category": "Java core.",
    "question": "Что такое JMX?",
    "answer": "Управленческие расширения Java (Java Management Extensions, JMX) -  API при помощи которого можно контролировать работу приложений и управлять различными параметрами удаленно в реальном времени. Причем управлять можно фактически чем угодно - лишь бы это было написано на Java. Это может быть микро-устройство типа считывателя отпечатка или система, включающая тысячи машин, каждая из которых предоставляет определенные сервисы. Данные ресурсы представляются MBean-объектами (управляемый Java Bean). JMX вошла в поставку Java начиная с версии 5."
  },
  {
    "category": "Java core.",
    "question": "Какие выгоды предлагает JMX?",
    "answer": "Вот как эти выгоды описывает Sun      Простота реализации. Архитектура JMX основана на понятии \"сервера управляемых объектов\" который выступает как управляющий агент и может быть запущен на многих устройствах/компьютерах, которые поддерживают JAVA.     Масштабируемость. Службы агентов JXM являются независимыми и могут быть встроены наподобие plug-in’ов в агента JMX. Компонентно-основанаая система позволяет создавать масштабируемые решения от крохотных устройств до очень крупных систем.     Возможность расширять концепцию в будущем. JMX позволяет создавать гибкие решения. Например, JMX позволяет создавать удобные решения, которые могут находить различные сервисы.     Концентрация на управлении. JMX предоставляет сервися, разработанные для работы в распределенных средах и его API спроектировано для решений, которые управляют приложениями, сетями, сервисами и т.д."
  },
  {
    "category": "Java core.",
    "question": "Что еще умеет JMX кроме дистанционного управления?",
    "answer": "JMX делает гораздо больше, чем просто предоставляет рабочую оболочку для дистанционного управления. Она обеспечивает дополнительные услуги (services), способные занять ключевое место в процессе разработки. Приведу лишь краткое описание:      Event notification: Интерфейсы оповещают исполнителей и слушателей о событиях типа изменения атрибута, что позволяет MBean-компонентам общаться с другими MBean-компонентами или удалённым \"командным пунктом\" и докладывать об изменениях своего состояния     Monitor service: Monitor MBeans может посылать уведомления о событиях зарегистрированным слушателям. Слушателем может выступать другой MBean или управляющее приложение. В качестве основных атрибутов, для которых используется данное свойство, являются counter, gauge или string.     Timer service: Timer MBean будет посылать уведомления зарегистрированным слушателям, с учётом определённого числа или временного промежутка.     M-let service: М-let service может создавать и регистрировать экземпляры MBean-серверов. Список MBean-компонентов и имён из классов определяются в m-let-файле с помощью MLET -меток. URL указывает на месторасположения m-let-файла."
  },
  {
    "category": "Java core.",
    "question": "Что такое MBean?",
    "answer": "MBeans - это Java-объекты, которые реализуют определенный интерфейс. Интерфейс включает:      некие величины, которые могут быть доступны      операции, которые могут быть вызваны      извещения, которые могут быть посланы      конструкторы."
  },
  {
    "category": "Java core.",
    "question": "Какие типы MBeans существуют?",
    "answer": "Существует 4 типа MBeans:      Standard MBeans. Самые простые бины. Их управляющий интерфейс определяется набором методов     Dynamic MBeans. Они реализуют специализированный интерфейс, который делают доступным во время исполнения.     Open MBeans. Это Dynamic MBeans, которые используют только основные типы данных для универсального управления.     Model MBeans. Это Dynamic MBeans, которые полностью конфигурируемы и могут показать свое описание во время исполнения (нечто вроде Reflection)"
  },
  {
    "category": "Java core.",
    "question": "Что такое MBean Server?",
    "answer": "MBean Server - это реестр объектов, которые используются для управления. Любой объект зарегистрированный на сервере становится доступным для приложений. Надо отметить, что сервер публикует только интерфейсы и не дает прямых ссылок на объекты. Любые ресурсы, которыми вы хотите управлять должны быть зарегистрированы на сервере как MBean. Сервер предоставляет стандартный интерфейс для доступа к MBean. Интересно, что регистрировать MBean может любой другой MBean, сам агент или удаленное приложение через распределенные сервисы. Когда вы регистрируете MBean вы должны дать ему уникальное имя, которое будет использовано для обращения к даному объекту."
  },
  {
    "category": "Java core.",
    "question": "Какие механизмы обеспечивают безопасность в технологии Java?",
    "answer": "В технологии Java безопасность обеспечивают следующие три механизма:      структурные функциональные возможности языка (например, проверка границ массивов, запрет на преобразования непроверенных типов, отсутствие указателей и т.д.).     средства контроля доступа, определяющие действия, которые разрешается или запрещается выполнять в коде (например, может ли код получать доступ к файлам, передавать данные по сети и т.д.).     механизм цифровой подписи, предоставляющий авторам возможность применять стандартные алгоритмы для аутентификации своих программ, а пользователям - точно определять, кто создал код и изменился ли он с момента его подписания."
  },
  {
    "category": "Java core.",
    "question": "Назовите несколько видов проверок которые выполняет верификатор байт-кода Java?",
    "answer": "Ниже приведены некоторые виды проверок, выполняемых верификатором.      инициализация переменных перед их использованием.     согласование типов ссылок при вызове метода.     соблюдение правил доступа к закрытым данным и методам.     доступ к локальным переменным в стеке во время выполнения.     отсутствие переполнения стека.  При невыполнении какой-нибудь из этих проверок класс считается поврежденным и загружаться не будет."
  },
  {
    "category": "Java core.",
    "question": "Что вы знаете о \"диспетчере защиты\" в Java?",
    "answer": "В качестве диспетчера защиты служит класс, определяющий, разрешено ли коду выполнять ту или иную операцию. Ниже перечислены операции, подпадающие под контроль диспетчера защиты. Существует немало других проверок, выполняемых диспетчером защиты в библиотеке Java.      создание нового загрузчика классов.     выход из виртуальной машины.     получение доступа к члену другого класса с помощью рефлексии.     получение доступа к файлу.     установление соединения через сокет.     запуск задания на печать.     получение доступа к системному буферу обмена.     получение доступа к очереди событий в AWT.     обращение к окну верхнего уровня."
  },
  {
    "category": "Java core.",
    "question": "Что такое JAAS?",
    "answer": "JAAS (Java Authentication and Authorization Service - служба аутентификации и авторизации Java ) - служба JAAS, по существу, представляет собой встраиваемый прикладной интерфейс API, отделяющий прикладные программы на Java от конкретной технологии, применяемой для реализации средств аутентификации. Помимо прочего, эта служба поддерживает механизмы регистрации в UNIX и NT, механизм аутентификации Kerberos и механизмы аутентификации по сертификатам. После аутентификации за пользователем может быть закреплен определенный набор полномочий. Входит в состав платформы Java начиная с версии Java SE 1.4."
  },
  {
    "category": "Java core.",
    "question": "Что такое Рефакторинг?",
    "answer": "Рефакторинг - процесс изменения внутренней структуры программы, не затрагивающий её внешнего поведения и имеющий целью облегчить понимание её работы. В основе рефакторинга лежит последовательность небольших эквивалентных (то есть сохраняющих поведение) преобразований.."
  },
  {
    "category": "Collections",
    "question": "Что такое Коллекция?",
    "answer": "Коллекции - это хранилища или контейнеры, поддерживающие различные способы накопления и упорядочения объектов с целью обеспечения возможностей эффективного доступа к ним. Они представляют собой реализацию абстрактных структур данных, поддерживающих три основные операции: добавление нового элемента в коллекцию       удаление элемента из коллекции      изменение элемента в коллекции."
  },
  {
    "category": "Collections",
    "question": "Назовите основные интерфейсы коллекций и их имплементации.",
    "answer": "Сollection расширяет три интерфейса: List, Set, Queue. List - хранит упорядоченные елементы(могут быть одинаковые)  Имеет такие реализации как LinkedList, ArrayList и Vector.      Vector синхронизирован, и по этому в одном потоке, он работает медленней остальных реализаций.     ArrayList - его преимущество в навигации по коллекции.     LinkedList - Его преимущество в во вставке и удалении элементов в коллекции.   Set - коллекции, которые не содержат повторяющихся элементов. Основные реализации: HashSet, TreeSet, LinkedHashSet      TreeSet - упорядочивает элементы по их значениям      HashSet - упорядочивает элементы по их хэш ключах, хотя на первый взляд может показаться что элементы хранятся в случайном порядке.     LinkedHashSet - хранит элементы в порядке их добавления   Queue - интерфейс для реализации очереди в джава. Основные реализации: LinkedList, PriorityQueue. Очереди работают по принципу FIFO – first in first out.  Map - интерфейс для реализации так называемой карты, где элементы хранятся с их ключами. Основные реализации: HashTable, HashMap, TreeMap, LinkedHashMap      HashTable - синхронизированна, объявлена уставревшей.     HashMap - порядок елементов рассчитывается по хэш ключу      TreeMap - элементы хранятся в отсортированном порядке     LinkedHashMap - элементы хранятся в порядке вставки  Ключи в Мар не могут быть одинаковыми! Синхронизировать не синхронизированные коллекции и карты можно посредством класса Collections.synchronizedMap(MyMap)\\ synchronizedList(MyList)."
  },
  {
    "category": "Collections",
    "question": "Чем отличается ArrayList от LinkedList? В каких случаях лучше использовать первый, а в каких второй?",
    "answer": "Оба реализуют интерфейс List, для добавления/удаление элемента. Отличие заключается в способе хранения данных. ArrayList хранит в виде массива, а LinkedList - в виде списка (двунаправленного). В ArrayList быстрее происходит сортировка, т.к. для ее выполнения данные списка копируются в массив (а копировать из массива ArrayList в массив для сортировки быстрее). При большом числе операций добавления и удаления LinkedList должен быть более удачным выбором, т.к. при этих операциях не приходится перемещать части массива. Если при добавлении в ArrayList превышается его объем, размер массива увеличивается, новая емкость рассчитывается по формуле (oldCapacity * 3) / 2 + 1, поэтому лучше указывать размер при создании или, если он не известен, использовать LinkedList (но это может быть существенно при слишком уж больших объемах данных)."
  },
  {
    "category": "Collections",
    "question": "Чем отличается HashMap от Hashtable?",
    "answer": "Класс HashMap по функционалу очень похож на Hashtable. Главное отличие в том, что методы класса Hashtable синхронизированы, а HashMap - нет. Кроме этого класс HashMap в отличии от Hashtable разрешает использование null в качестве ключей и значений.  Наличие синхронизации в Hashtable уменьшает производительность кода, использующего данный класс. Поэтому классы JCF (Java Collections Framework, появившийся в Java 2), в том числе и HashMap, несинхронизированы. Если синхронизация все же нужна, можно использовать методы класса Collections: Collections.synchronizedMap(map), Collections.synchronizedList(list) или Collections.synchronizedSet(set).  Данные методы возвращают синхронизированный декоратор переданной коллекции. При этом все равно в случае итерирования по коллекции требуется ручная синхронизация.  Начиная с Java 6 JCF был расширен специальными коллекциями, поддерживающими многопоточный доступ, такими как CopyOnWriteArrayList и ConcurrentHashMap."
  },
  {
    "category": "Collections",
    "question": "Чем отличается ArrayList от Vector?",
    "answer": "Методы класса Vector синхронизированы, в то время как ArrayList - нет."
  },
  {
    "category": "Collections",
    "question": "Как сравниваются елементы коллекций?",
    "answer": "Для сравнения элементов коллекций  используется метод equals() и hashcode() Эти методы унаследованы от класса Object.      Если наш пользовательский класс  переопределяет equals(), то он должен и переопределить hashcode()     Если  два объекта эквивалентны, то и  хэш коды этих объектов тоже должны быть равны     Если  поле не используется в equals(), то оно и не должно использоваться в hashcode()."
  },
  {
    "category": "Collections",
    "question": "Расположите в виде иерархии следующие интерфейсы: List, Set, Map, SortedSet, SortedMap, Collection,Iterable, Iterator, NavigableSet, NavigableMap.",
    "answer": ""
  },
  {
    "category": "Collections",
    "question": "Почему Map - это не Collection, в то время как List и Set являются Collection?",
    "answer": "Коллекция (List и Set) представляет собой совокупность некоторых элементов (обычно экземпляров одного класса).Map -это совокупность пар \"ключ\"-\"значение\". Соответственно некоторые методы интерфейса Collection нельзя использовать в Map. Например, метод remove(Object o) в интерфейсе Collection предназначен для удаления элемента, тогда как такой же метод remove(Object key) в интерфейсе Map - удаляет элемент по заданному ключу."
  },
  {
    "category": "Collections",
    "question": "Дайте определение понятию \"iterator\".",
    "answer": "Итератор - объект, позволяющий перебирать элементы коллекции. Например foreach реализован с использованием итератора. Одним из ключевых методов интерфейса Collection является метод Iterator<E> iterator(). Он возвращает итератор - то есть объект, реализующий интерфейс Iterator. Интерфейс Iterator имеет следующее определение:"
  },
  {
    "category": "Collections",
    "question": "Что вы знаете об интерфейсе Iterable?",
    "answer": "Все коллекции из java.util реализуют интерфейс Collection, который, в свою очередь, расширяет интерфейс Iterable. В интерфейсе Iterable описан только один метод: Iterator iterator()  Он возвращает Iterator, т.е. объект, который поочерёдно возвращает все элементы коллекции."
  },
  {
    "category": "Collections",
    "question": "Как одной строчкой преобразовать HashSet в ArrayList?",
    "answer": "List<> = new ArrayList<>(set)"
  },
  {
    "category": "Collections",
    "question": "Как одной строчкой преобразовать ArrayList в HashSet?",
    "answer": "Set<>=HashSet<>(list)"
  },
  {
    "category": "Collections",
    "question": "Как перебрать все ключи Map учитывая, что Map - это не Iterable?",
    "answer": "Использовать метод keySet(), который возвращает множество (Set<K>) ключей."
  },
  {
    "category": "Collections",
    "question": "Как перебрать все значения Map учитывая, что Map - это не Iterable?",
    "answer": "Использовать метод values(), который возвращает коллекцию (Collection<V>) значений."
  },
  {
    "category": "Collections",
    "question": "Как перебрать все пары ключ-значение в Map учитывая, что Map - это не Iterable?",
    "answer": "Использовать метод entrySet(), который возвращает множество (Set<Map.Entry<K, V>) пар \"ключ\"-\"значение\"."
  },
  {
    "category": "Collections",
    "question": "В чем проявляется \"сортированность\" SortedMap, кроме того, что toString() выводит все по порядку?",
    "answer": "Естественное упорядочивание (natural ordering) отражается при итерации по коллекции ключей или значений хэш-таблицы (возвращаемых методами keySet(), values() и entrySet())."
  },
  {
    "category": "Collections",
    "question": "Как одним вызовом копировать элементы из любой Collection в массив?",
    "answer": "list.toArray()"
  },
  {
    "category": "Collections",
    "question": "Реализуйте симметрическую разность двух коллекций используя методы Collection (addAll(), removeAll(), retainAll()).",
    "answer": "Симметрическая разность двух коллекций - это множество элементов, одновременно не принадлежащих обоим исходным коллекциям."
  },
  {
    "category": "Collections",
    "question": "Сравните Enumeration и Iterator.",
    "answer": "Оба интерфейса предназначены для обхода коллекций. Интерфейс Iterator был введен несколько позднее в Java Collections Framework и его использование предпочтительнее. Основные различия Iterator по сравнению с Enumeration:      наличие метода remove() для удаления элемента из коллекции при обходе      исправлены имена методов для повышения читаемости кода."
  },
  {
    "category": "Collections",
    "question": "Как между собой связаны Iterable и Iterator?",
    "answer": "Интерфейс Iterable имеет только один метод - iterator(), который возвращает итератор коллекции для её обхода."
  },
  {
    "category": "Collections",
    "question": "Как между собой связаны Iterable, Iterator и \"for-each \" введенный в Java 5?",
    "answer": "Экземпляры классов, реализующих интерфейс Iterable, могут использоваться в конструкции foreach."
  },
  {
    "category": "Collections",
    "question": "Сравните Iterator и ListIterator.",
    "answer": "ListIterator расширяет интерфейс Iterator, позволяя клиенту осуществлять обход коллекции в обоих направлениях, изменять коллекцию и получать текущую позицию итератора. При этом важно помнить, что ListIterator не указывает на конкретный элемент, а его текущая позиция располагается между элементами, которые возвращают методы previous() и next(). Таким образом, модификация коллекции осуществляется для последнего элемента, который был возвращен методами previous() и next()."
  },
  {
    "category": "Collections",
    "question": "Что произойдет, если я вызову Iterator.next() не \"спросив\" Iterator.hasNext()?",
    "answer": "Если итератор указывает на последний элемент коллекции, то возникнет исключение NoSuchElementException, иначе будет возвращен следующий элемент."
  },
  {
    "category": "Collections",
    "question": "Что произойдет, если я вызову Iterator.next() перед этим 10 раз вызвав Iterator.hasNext()? Я пропущу 9 элементов?",
    "answer": "Нет, hasNext() осуществляет только проверку наличия следующего элемента."
  },
  {
    "category": "Collections",
    "question": "Если у меня есть коллекция и порожденный итератор, изменится ли коллекция, если я вызову iterator.remove()?",
    "answer": "Вызов метода iterator.remove() возможен только после вызова метода iterator.next() хотя бы раз, иначе появится исключение IllegalStateException(). Если iterator.next() был вызван прежде, то iterator.remove() удалит элемент, на который указывает итератор."
  },
  {
    "category": "Collections",
    "question": "Если у меня есть коллекция и порожденный итератор, изменится ли итератор, если я вызову collection.remove(..)?",
    "answer": "Итератор не изменится, но при следующем вызове его методов возникнет исключение ConcurrentModificationException."
  },
  {
    "category": "Collections",
    "question": "Зачем добавили ArrayList, если уже был Vector?",
    "answer": "Обе структуры данных предназначены для хранения коллекции элементов, в том числе дупликатов и null. Они основаны на использовании массивов, динамически расширяющихся при необходимости. Класс Vector был введен в JDK 1.0 и не является частью Java Collection Framework. Методы класса Vector синхронизированы, что обеспечивает потокобезопасность, но это приводит к снижению производительности, поэтому и был введен класс ArrayList, методы которого не синхронизированы."
  },
  {
    "category": "Collections",
    "question": "В реализации класса ArrayList есть следующие поля: Object[] elementData, int size. Объясните, зачем хранить отдельно size, если всегда можно взять elementData.length?",
    "answer": "Размер массива elementData представляет собой вместимость (capacity) ArrayList, которая всегда больше переменной size - реального количества хранимых элементов. С добавлением новых элементов вместимость автоматически возрастает при необходимости."
  },
  {
    "category": "Collections",
    "question": "LinkedList - это односвязный, двусвязный или четырехсвязный список?",
    "answer": "Двухсвязный список: каждый элемент LinkedList хранит ссылку на предыдущий и следующий элементы."
  },
  {
    "category": "Collections",
    "question": "Какое худшее время работы метода contain() для элемента, который есть в LinkedList (O(1), O(log(N)), O(N), O(N*log(N)), O(N*N))?",
    "answer": "O(N). Время поиска элемента линейно пропорционально количеству элементов с списке."
  },
  {
    "category": "Collections",
    "question": "Какое худшее время работы метода contain() для элемента, который есть в ArrayList (O(1), O(log(N)), O(N), O(N*log(N)), O(N*N))?",
    "answer": "O(N). Время поиска элемента линейно пропорционально количеству элементов с списке."
  },
  {
    "category": "Collections",
    "question": "Какое худшее время работы метода add() для LinkedList (O(1), O(log(N)), O(N), O(N*log(N)), O(N*N))?",
    "answer": "O(N). Здесь стоит заметить, что добавление элемента в конец списка с помощью методом add(value), addLast(value) и добавление в начало списка с помощью addFirst(value) выполняется за время O(1). O(N) - будет при добавление элемента в отсортированный список, а также при добавлении элемента с помощью метода add(index, value)."
  },
  {
    "category": "Collections",
    "question": "Какое худшее время работы метода add() для ArrayList (O(1), O(log(N)), O(N), O(N*log(N)), O(N*N))?",
    "answer": "O(N). Вставка элемента в конец списка осуществляется за время O(1), но если вместимость массива недостаточна, то происходит создание нового массива с увеличенным размером и копирование всех элементов из старого массива в новый."
  },
  {
    "category": "Collections",
    "question": "Сколько выделяется элементов в памяти при вызове ArrayList.add()?",
    "answer": "Если в массиве достаточно места для размещения нового элемента, то дополнительное место в памяти не выделяется. Иначе происходит создание нового массива с размером: Другими словами, создается новый массив, размер которого вычисляется как умножение старого размера на 1.5 (это верно для JDK 1.7, в более ранних версиях вычисления отличаются)."
  },
  {
    "category": "Collections",
    "question": "Сколько выделяется элементов в памяти при вызове LinkedList.add()?",
    "answer": "Создается один новый экземпляр вложенного класса Node."
  },
  {
    "category": "Collections",
    "question": "Оцените количество памяти на хранение одного примитива типа byte в LinkedList?",
    "answer": "Каждый элемент LinkedList хранит ссылку на предыдущий элемент, следующий элемент и ссылку на данные. Для x32 систем каждая ссылка занимает 32 бита (4 байта). Сам объект типа Node занимает приблизительно 8 байт. Размер каждого объекта в Java кратен 8, соответственно получаем 24 байта. Примитив типа byte занимает 1 байт памяти, но в списке примитивы упаковываются, соответственно получаем еще 8 байт. Таким образом, в x32 JVM около 32 байтоввыделяется для хранения одного значения типа byte в LinkedList. Для 64-битной JVM каждая ссылка занимает 64 бита (8 байт). Вычисления аналогичны."
  },
  {
    "category": "Collections",
    "question": "Оцените количество памяти на хранение одного примитива типа byte в ArrayList?",
    "answer": "ArrayList основан на массиве. Каждый элемент массива хранит примитивный тип данных - byte, размер которого 1 байт."
  },
  {
    "category": "Collections",
    "question": "Я добавляю элемент в середину List-а: list.add(list.size()/2, newElem). Для кого эта операция медленнее - для ArrayList или для LinkedList?",
    "answer": "Для ArrayList:      проверка массива на вместимость. Если вместимости недостаточно, то увеличение размера массива и копирование всех элементов в новый массив ( O(N) )      копирование всех элементов, расположенных правее от позиции вставки, на одну позицию вправо ( O(N/2))      вставка элемента ( O(1) ).  Для LinkedList:      поиск позиции вставки ( O(N/2) )      вставка элемента ( O(1) ).  В худшем случае вставка в середину списка эффективнее для LinkedList. В остальных - скорее всего, для ArrayList, поскольку копирование элементов осуществляется за счет системного метода System.arraycopy()."
  },
  {
    "category": "Collections",
    "question": "Как перебрать элементы LinkedList в обратном порядке, не используя медленный get(index)?",
    "answer": "Использовать обратный итератор. Для этого в LinkedList есть метод descendingIterator()."
  },
  {
    "category": "Collections",
    "question": "Как одним вызовом из List получить List со всеми элементами, кроме первых и последних 3-х?",
    "answer": "list.sublist(3,oldlist.size()-3)"
  },
  {
    "category": "Collections",
    "question": "Могут ли у разных объектов в памяти (ref0 != ref1) быть ref0.hashCode() == ref1.hashCode()?",
    "answer": "Да, могут. Метод hashCode() не гарантирует уникальность возвращаемого значения."
  },
  {
    "category": "Collections",
    "question": "Могут ли у разных объектов в памяти (ref0 != ref1) быть ref0.equals(ref1) == true?",
    "answer": "Да, могут. Для этого в классе этих объектов должен быть переопределен метод equals(). Если используется метод Object.equals(), то для двух ссылок x и y метод вернет true тогда и только тогда, когда обе ссылки указывают на один и тот же объект (т.е. x == y возвращает true)."
  },
  {
    "category": "Collections",
    "question": "Могут ли у разных ссылок на один объект в памяти (ref0 == ref1) быть ref0.equals(ref1) == false?",
    "answer": "Нет, не может. Метод equals() должен гарантировать свойство рефлексивности: для любых ненулевых ссылок xметод x.equals(x) должен возвращать true."
  },
  {
    "category": "Collections",
    "question": "Есть класс Point{int x, y }. Почему хэш-код в виде 31 * x + y предпочтительнее чем x + y?",
    "answer": "Множитель создает зависимость значения хэш-кода от очередности обработки полей, а это дает гораздо лучшую хэш-функцию."
  },
  {
    "category": "Collections",
    "question": "Если у класса Point{int x, y } \"правильно \" реализовать метод equals (return ref0.x == ref1.x && ref0.y == ref1.y), но сделать хэш-код в виде int hashCode() {return x }, то будут ли корректно такие точки помещаться и извлекаться из HashSet?",
    "answer": "HashSet использует HashMap для хранения элементов (в качестве ключа используется сам объект). При добавлении элемента в HashMap вычисляется хэшкод и позиция в массиве, куда будет вставлен новый элемент. У всех экземпляров класса Point одинаковый хэшкод, что приводит в вырождению хэш-таблицы в список. При возникновении коллизии осуществляется проверка на наличие уже такого элемента в текущем списке: Если элемент найден, то его значение перезаписывается. В нашем случае для разных объектов метод equals() будет возвращать false. Соответственно новый элемент будет добавлен в HashSet. Извлечение элемента также будет осуществляться успешно. Но производительность такого кода будет низкой и преимущества хэш-таблиц использоваться не будут."
  },
  {
    "category": "Collections",
    "question": "equals() порождает отношение эквивалентности. Какими из свойств обладает такое отношение: коммутативность, симметричность, рефлексивность, дистрибутивность, ассоциативность, транзитивность?",
    "answer": "Метод equals() должен обеспечивать:      симметричность (для любых ненулевых ссылок x и y метод x.equals(y) должен возвращать true тогда и только тогда, когда y.equals(x) возвращает true)      рефлексивность (для любых ненулевых ссылок x метод x.equals(x) должен возвращать true.)      транзитивность (для любых ненулевых ссылок x, y и z, если x.equals(y) возвращает true и y.equals(z)возвращает true, тогда и x.equals(z) должен возвращать true).  Также есть ещё два свойства: постоянство и неравенство null."
  },
  {
    "category": "Collections",
    "question": "Можно ли так реализовать equals(Object that) {return this.hashCode() == that.hashCode()}?",
    "answer": "Строго говоря нельзя, поскольку метод hashCode() не гарантирует уникальность значения для каждого объекта. Однако для сравнения экземпляров класса Object такой код допустим, т.к. метод  hashCode() в классе Object возвращает уникальные значения для разных объектов (вычисления основаны на использовании адреса объекта в памяти)."
  },
  {
    "category": "Collections",
    "question": "В equals требуется проверять, что аргумент (equals(Object that)) такого же типа как и сам объект. В чем разница между this.getClass() == that.getClass() и that instanceof MyClass?",
    "answer": "Оператор instanceof сравнивает объект и указанный тип. Его можно использовать для проверки является ли данный объект экземпляром некоторого класса, либо экземпляром его дочернего класса, либо экземпляром класса, который реализует указанный интерфейс. getClass() = ... проверяет два типа на идентичность. Для корректной реализации контракта метода equals() необходимо использовать точное сравнение с помощью getClass()."
  },
  {
    "category": "Collections",
    "question": "Можно ли реализовать метод equals класса MyClass вот так: class MyClass {public boolean equals(MyClass that) {return this == that }}?",
    "answer": "Реализовать можно, но данный метод не переопределяет метод equals() класса Object, а перегружает его."
  },
  {
    "category": "Collections",
    "question": "Будет ли работать HashMap, если все ключи будут возвращать int hashCode() {return 42 }?",
    "answer": "Да, будет. Но тогда хэш-таблица вырождается в связный список и теряет свои преимущества."
  },
  {
    "category": "Collections",
    "question": "Зачем добавили HashMap, если уже был Hashtable?",
    "answer": "Класс Hashtable был введен в JDK 1.0 и не является частью Java Collection Framework. Методы класса Hashtable синхронизированы, что обеспечивает потокобезопасность, но это приводит к снижению производительности, поэтому и был введен класс HashMap, методы которого не синхронизированы. Помимо этого класс HashMap обладает некоторыми другими отличиями: например, позволяет хранить один null ключ и множество null значений."
  },
  {
    "category": "Collections",
    "question": "Согласно Кнуту и Кормену существует две основных реализации хэш-таблицы: на основе открытой адресацией и на основе метода цепочек. Как реализована HashMap? Почему так сделали (по вашему мнению)? В чем минусы и плюсы каждого подхода?",
    "answer": "Класс HashMap реализован с использованием метода цепочек, т.е. каждой ячейке массива соответствует свой связный список и при возникновении коллизии осуществляется добавление нового элемента в этот список. Для метода цепочек коэффициент заполнения может быть больше 1, с увеличением числа элементов производительность убывает линейно. Такие таблицы удобно использовать, если заранее неизвестно количество хранимых элементов, либо их может быть достаточно много, что приводит к большим значениям коэффициента заполнения. Среди методов открытой реализации различают:      линейное пробирование      квадратичное пробирование      двойное хеширование.  Основные недостатки структур с методом открытой адресации:      Количество элементов в таблице не может превышать размера массива. По мере увеличения числа элементов в таблице и повышения коэффициента заполнения (load factor) производительность структуры резко падает, поэтому необходимо проводить перехеширование.     Сложно организовать удаление элемента.     Также первые два метода открытой адресации приводят к проблеме первичной и вторичной группировок.  Основное преимущество хэш-таблицы с открытой адресацией - это отсутствие затрат на создание и хранение объектов списка. Также проще организовать сериализацию/десериализацию объекта."
  },
  {
    "category": "Collections",
    "question": "Сколько переходов по ссылкам происходит, когда вы делаете HashMap.get(key) по ключу, который есть в таблице?",
    "answer": "Возможно, я неправильно понял этот вопрос. За переходы по ссылке в данном ответе я считаю вызовы методов. Рассмотрим первый случай, когда ключ равен null: выполняем метод getForNullKey(). В цикле foreach проходимся по списку значений для ключа и возвращаем нужное значение. Таким образом, получаем 1 переход. Второй случай: ключ не равен null. Выполняем метод getEntry(key). Вычисляется хэш-код ключа (метод hash(key)), затем определяется индекс ячейки массива, в которой будем искать значение (метод indexFor(hash, table.length)). После того, как нашли нужную пару \"ключ-значение\" возвращаем значение (метод entry.getValue()). Таким образом, получаем 4 перехода."
  },
  {
    "category": "Collections",
    "question": "Сколько создается новых объектов, когда вы добавляете новый элемент в HashMap?",
    "answer": "Один новый объект статического вложенного класса Entry<K,V>."
  },
  {
    "category": "Collections",
    "question": "Как работает HashMap при попытке сохранить в нее два элемента по ключам с одинаковым hashCode, но для которых equals == false?",
    "answer": "По значению hashCode вычисляется индекс ячейки массива, в список которой будет происходить добавление элемента. Перед добавлением осуществляется проверка на наличие уже элементов в этой ячейке. Если элементов нет, то происходит добавление. Если возникает коллизия, то итеративно осуществляется обход списка в поисках элемента с таким же ключом и хэш-кодом. Если такой элемент найден, то его значение перезаписывается, а старое - возвращается. Поскольку в условии сказано, что добавляемые ключи - разные, то второй элемент будет добавлен в начало списка."
  },
  {
    "category": "Collections",
    "question": "HashMap может выродиться в список даже для ключей с разным hashCode. Как это возможно?",
    "answer": "Это возможно в случае, если метод, определяющий номер ячейки массива по hashCode будет возвращать одинаковое значение."
  },
  {
    "category": "Collections",
    "question": "Какое худшее время работы метода get(key) для ключа, которого нет в таблице (O(1), O(log(N)), O(N), O(N*log(N)), O(N*N))?",
    "answer": "O(N). Худший случай - это поиск ключа в таблице, вырожденной в список, перебор ключей которой занимает линейно пропорциональное время количеству хранимых элементов."
  },
  {
    "category": "Collections",
    "question": "Какое худшее время работы метода get(key) для ключа, который есть в таблице (O(1), O(log(N)), O(N), O(N*log(N)), O(N*N))?",
    "answer": "O(N). Аналогичные рассуждения, что и для предыдущего вопроса."
  },
  {
    "category": "Collections",
    "question": "Объясните смысл параметров в конструкторе HashMap(int initialCapacity, float loadFactor).",
    "answer": "int initialCapacity - исходный размер HashMap (количество корзин в хэш-таблице в момент её создания), по умолчанию имеет значение 16.  float loadFactor - коэффициент заполнения HashMap. Равен отношению числа хранимых элементов в таблице к её размеру. loadFactor - является мерой заполнения таблицы элементами, при превышении количества хранимых таблицей значений , происходит автоматическое перехеширование. Значение по умолчанию 0.75 является хорошим компромиссом между временем доступа и объемом хранимых данных."
  },
  {
    "category": "Collections",
    "question": "В чем разница между HashMap и IdentityHashMap? Для чего нужна IdentityHashMap? Как может быть полезна для реализации сериализации или клонирования?",
    "answer": "IdentityHashMap - это структура данных, реализующая интерфейс Map, но использующая сравнение ссылок вместо метода equals() при сравнении ключей (значений). Другими словами, в IdentityHashMap два ключа k1 и k2 будут рассматриваться равными, если выполняется условие k1 == k2. IdentityHashMap не использует метод hashCode(), вместо которого применяется метод System.identityHashCode(Object). Другое отличие (как следствие) заключается в более высокой производительности IdentityHashMap по сравнению с HashMap, если последний хранит объекты с дорогостоящими методами equals() и hashCode(). Одним из основных требований к использованию HashMap является неизменяемость ключа, однако это требование не распространяется на IdentityHashMap, который не использует методы equals() и hashCode(). Согласно документации, такая структура данных может применяться для реализации сериализации/клонирования. Для выполнения подобных алгоритмов программе необходимо обслуживать таблицу со всеми ссылками на объекты, которые уже были обработаны. Такая таблица не должна рассматривать уникальные объекты как равные, даже если метод equals() возвращает true."
  },
  {
    "category": "Collections",
    "question": "В чем разница между HashMap и WeakHashMap? Для чего нужна WeakHashMap?",
    "answer": "Перед рассмотрением WeakHashMap кратко напомню, что такое WeakReference. В Java существует 4 типа ссылок: сильные (strong reference), мягкие (SoftReference), слабые (WeakReference) и фантомные (PhantomReference). Особенности каждого типа ссылок связаны с работой Garbage Collector. Если объект можно достичь только с помощью цепочки WeakReference (то есть на него не ссылаются сильные и мягкие ссылки), то данный объект будет отмечен для удаления. WeakHashMap - это структура данных, реализующая интерфейс Map и основанная на использовании WeakReference для хранения ключей. Таким образом, пара \"ключ-значение\" будет удалена из WeakHashMap, если на объект-ключ более не имеется сильных ссылок. В качестве примера использования такой структуры данных можно привести следующую ситуацию: допустим имеются объекты, которые необходимо расширить дополнительной информацией, при этом изменение класса этих объектов нежелательно либо невозможно. В этом случае добавляем каждый объект в WeakHashMap в качестве ключа, а в качестве значения - нужную информацию. Таким образом, пока на объект имеется сильная ссылка (либо мягкая), можно проверять хэш-таблицу и извлекать информацию. Как только объект будет удален, то WeakReference для этого ключа будет помещен в ReferenceQueue и затем соответствующая запись для этой слабой ссылки будет удалена из WeakHashMap."
  },
  {
    "category": "Collections",
    "question": "В WeakHashMap используются WeakReferences. А почему бы не создать SoftHashMap на SoftReferences?",
    "answer": "SoftHashMap представлена в стронних библиотеках, например, в Apache Commons."
  },
  {
    "category": "Collections",
    "question": "В WeakHashMap используются WeakReferences. А почему бы не создать PhantomHashMap на PhantomReferences?",
    "answer": "PhantomReference при вызове метода get() возвращает всегда null, поэтому, я думаю, создание PhantomHashMap просто невозможно. Плюс назначение такой структуры данных тяжело представить."
  },
  {
    "category": "Collections",
    "question": "Сделайте HashSet из HashMap (используйте только множество ключей, но не множество значений).",
    "answer": "new HashSet<>(map.keySet)"
  },
  {
    "category": "Collections",
    "question": "Сделайте HashMap из HashSet (HashSet<Map.Entry<K, V>>).",
    "answer": "Map<K,V>map=new HashSet<>(set.size)  for (Map.Entry<K,V> entry : set){map.put(entry.getKey,entry.getValue))}"
  },
  {
    "category": "Collections",
    "question": "Сравните интерфейсы java.util.Queue и java.util.Deque.",
    "answer": "Согласно документации Deque (\"дек\", Double Ended Queue) - это линейная коллекция, поддерживающая вставку/извлечение элементов с обоих концов. Помимо этого реализации интерфейса Deque могут строится по принципу FIFO, либо LIFO. Queue - это очередь, обычно (но необязательно) строится по принципу FIFO (First-In-First-Out) - соответственно извлечение элемента осуществляется с начала очереди, вставка элемента - в конец очереди. Этот принцип нарушает, к примеру, приоритетная очередь (PriorityQueue), использующая переданный comparator при вставке нового элемента, либо расстановка элементов осуществляется согласно естественному упорядочиванию (natural ordering). Deque расширяет Queue. Реализации и Deque, и Queue обычно не переопределяют методы equals() и hashCode(), основанные на сравнении хранящихся элементов. Вместо этого используются унаследованные методы класса Object, основанные на сравнении ссылок."
  },
  {
    "category": "Collections",
    "question": "Кто кого расширяет: Queue расширяет Deque, или Deque расширяет Queue?",
    "answer": "Deque расширяет Queue."
  },
  {
    "category": "Collections",
    "question": "Почему LinkedList реализует и List, и Deque?",
    "answer": "LinkedList позволяет добавлять элементы в начало и конец списка за константное время, что хорошо подходит для реализации интерфейса Deque (в отличие, например, от ArrayList)."
  },
  {
    "category": "Collections",
    "question": "В чем разница между классами java.util.Arrays и java.lang.reflect.Array?",
    "answer": "java.util.Arrays - класс, содержащий статические методы для работы с массивами, таких как, например, поиск по массиву и его сортировка. java.lang.reflect.Array - класс для работы с массивами при использовании рефлексии. Рефлексия - это механизм, позволяющий исследовать данные о программе во время её выполнения."
  },
  {
    "category": "Collections",
    "question": "В чем разница между классами java.util.Collection и java.util.Collections?",
    "answer": "Класс java.util.Collections содержит исключительно статические методы для работы с коллекциями. В них входят методы, реализующие полиморфные алгоритмы (такие алгоритмы, использование которых возможно с разными видами структур данных), \"оболочки\", возвращающие новую коллекцию с инкапсулированной указанной структурой данных и некоторые другие методы. java.util.Collection - это корневой интерфейс Java Collections Framework. Этот интерфейс в основном применяется там, где требуется высокий уровень абстракции, например, в классе java.util.Collections."
  },
  {
    "category": "Collections",
    "question": "Напишите НЕмногопоточную программу, которая заставляет коллекцию выбросить ConcurrentModificationException.",
    "answer": ""
  },
  {
    "category": "Collections",
    "question": "Что такое \"fail-fast поведение\"?",
    "answer": "Fail-fast поведение означает, что при возникновении ошибки или состояния, которое может привести к ошибке, система немедленно прекращает дальнейшую работу и уведомляет об этом.  В Java Collections API итераторы могут использовать либо fail-fast, либо fail-safe поведение, либо быть weakly consistent. Итератор с fail-fast поведением выбросит исключение ConcurrentModificationException, если после его создания была произведена модификация коллекции, т.е. добавлен или удален элемент (без использования метода remove() итератора). Реализация такого поведения осуществляется за счет подсчета количества модификаций коллекции (modification count):       при изменении коллекции (удаление/добавление элемента) счетчик увеличивается       при создании итератора ему передается текущее значение счетчика       при каждом обращении к итератору сохраненное значение счетчика сравнивается с текущим, и, если они не совпадают, возникает исключение.   Использование fail-fast подхода позволяет избежать недетерминированного поведения программы в течение времени. Также стоит отметить, что fail-fast поведение не может быть абсолютно гарантировано."
  },
  {
    "category": "Collections",
    "question": "Для множеств еnum-ов есть специальный класс java.util.EnumSet? Зачем? Чем авторов не устраивал HashSet или TreeSet?",
    "answer": "EnumSet - это одна из разновидностей реализации интерфейса Set для использования с перечислениями (Enum). EnumSet использует массив битов для хранения значений (bit vector), что позволяет получить высокую компактность и эффективность. В структуре данных хранятся объекты только одного типа Enum, который указывается при создании экземпляра EnumSet. Все основные операции выполняются за константное время (O(1)) и в основном несколько быстрее (хотя и негарантированно), чем их аналоги в реализации HashSet. Пакетные операции (bulk operations, например, containsAll() и retainAll()) выполняются очень быстро, если их аргументом является экземпляр типаEnum.  Помимо этого класс EnumSet предоставляет множество статических методов инициализации для упрощенного и удобного создания экземпляров.  Итерация по EnumSet осуществляется согласно порядку объявления элементов перечисления."
  },
  {
    "category": "Collections",
    "question": "java.util.Stack - считается \"устаревшим\". Чем его рекомендуют заменять? Почему?",
    "answer": "Рекомендуется использовать интерфейс Deque (\"дек\", Double Ended Queue) и его реализации. Например:  Стек - это структура данных, построенная на принципе LIFO (Last-In-First-Out, либо по-другому FILO). Каждое новое значение добавляется на \"вершину\" стека, а извлекается последний добавленный элемент (с \"вершины\" стека). При извлечении элемента он удаляется из структуры данных. Класс Stack появился в JDK 1.0 и расширяет класс Vector, наследуя его функционал, что несколько нарушает понятие стека (например, класс Vector предоставляет возможность обращаться к любому элементу по индексу). Также использование Deque позволяет следовать принципу программирования на уровне интерфейсов, а не конкретных реализаций, что облегчает дальнейшую поддержку разрабатываемого класса и повышает его гибкость, позволяя при необходимости менять реализацию дека на нужную."
  },
  {
    "category": "Collections",
    "question": "Какая коллекция реализует дисциплину обслуживания FIFO?",
    "answer": "FIFO - First-In-First-Out (первый пришел, первым ушел). По этому принципу обычно построена такая структура данных как очередь (java.util.Queue)."
  },
  {
    "category": "Collections",
    "question": "Какая коллекция реализует дисциплину обслуживания FILO?",
    "answer": "FILO - First-In-Last-Out (первый пришел, последним ушел). По этому принципу построена такая структура данных как стек (java.util.Stack)."
  },
  {
    "category": "Collections",
    "question": "Приведите пример, когда какая-либо коллекция выбрасывает UnsupportedOperationException.",
    "answer": ""
  },
  {
    "category": "Collections",
    "question": "Почему нельзя написать \"ArrayList<List> numbers = new ArrayList<ArrayList>() \" но можно \"List<ArrayList> numbers = new ArrayList<ArrayList>() \"?",
    "answer": "Это связано с ограничениями использования generic types (обобщенных типов). ArrayList<ArrayList> не является подтипом ArrayList<List>, соответственно использование такой записи запрещено."
  },
  {
    "category": "Collections",
    "question": "LinkedHashMap - что это еще за \"зверь\"? Что в нем от LinkedList, а что от HashMap?",
    "answer": "Реализация LinkedHashMap отличается от HashMap поддержкой двухсвязанного списка, определяющего порядок итерации по элементам структуры данных. По умолчанию элементы списка упорядочены согласно их порядку добавления в LinkedHashMap (insertion-order). Однако порядок итерации можно изменить, установив параметр конструктора accessOrder в значение true. В этом случае доступ осуществляется по порядку последнего обращения к элементу (access-order). Это означает, что при вызове методов get() или put() элемент, к которому обращаемся, перемещается в конец списка. При добавлении элемента, который уже присутствует в LinkedHashMap (т.е. с одинаковым ключом), порядок итерации по элементам не изменяется."
  },
  {
    "category": "Collections",
    "question": "LinkedHashSet - что это еще за \"зверь\"? Что в нем от LinkedList, а что от HashSet?",
    "answer": "Реализация LinkedHashSet отличается от HashSet поддержкой двухсвязанного списка, определяющего порядок итерации по элементам структуры данных. Элементы списка упорядочены согласно их порядку добавления в LinkedHashSet (insertion-order). При добавлении элемента, который уже присутствует в LinkedHashSet (т.е. с одинаковым ключом), порядок итерации по элементам не изменяется."
  },
  {
    "category": "Collections",
    "question": "Говорят, на LinkedHashMap легко сделать простенький кэш c \"invalidation policy\", знаете как?",
    "answer": "Необходимо использовать LRU-алгоритм (Least Recently Used algorithm) и LinkedHashMap с access-order. В этом случае при обращении к элементу он будет перемещаться в конец списка, а наименее используемые элементы будут постепенно группироваться в начале списка. Для этого в стандартной реализации LinkedHashMap (source) есть метод removeEldestEntries(), который возвращает true, если текущий объект LinkedHashMap должен удалить наименее используемый элемент из коллекции. Метод вызывается при использовании методов put() и putAll(): Простой пример реализации кэша с очисткой старых значений при превышении указанного порога: Стоит заметить, что LinkedHashMap не позволяет полностью реализовать LRU-алгоритм, поскольку при вставке уже имеющегося в коллекции элемента порядок итерации не меняется."
  },
  {
    "category": "Collections",
    "question": "Что позволяет сделать PriorityQueue?",
    "answer": "PriorityQueue - это структура данных, располагающая элементы в порядке натурального упорядочивания, либо используя переданный конструктору Comparator. Используя PriorityQueue, можно, например, реализовать алгоритм Дейкстры для поиска кратчайшего пути от одной вершины графа к другой. Либо применять для хранения объектов согласно их приоритету: например, сортировка пациентов врача - экстренные пациенты перемещаются в начало очереди, менее срочные пациенты - ближе к концу очереди."
  },
  {
    "category": "Collections",
    "question": "В чем заключаются отличия java.util.Comparator от java.lang.Comparable?",
    "answer": "Interface Comparable задает свойство сравнения объекту реализующему его. То есть делает объект сравнимым (по правилам разработчика). Interface Comparator позволяет создавать объекты, которые будут управлять процессом сравнения (например при сортировках)."
  },
  {
    "category": "Java 8.",
    "question": "Какие нововведения, появились в Java 8?",
    "answer": "В Java 8 было добавлено много функций, наиболее значимые из них упомянуты ниже:      Полноценная поддержка лямбда-выражений, которая добавляет функциональные возможности обработки данных для Java.     Ключевое слово default в интерфейсах для поддержки функциональности по умолчанию(интерфейс может иметь реализацию метода по умолчанию).     Ссылки на методы.     Функциональные интерфейсы (предикаты, поставщики и т. д.)     Потоки (stream) для работы с коллекциями     Новое API для работы с датами     Nashorn движок JavaScript, разрабатываемый полностью на Java компанией Oracle."
  },
  {
    "category": "Java 8.",
    "question": "Как сортировать список строк с помощью лямбда-выражения?",
    "answer": "Collection.sort(names,(s1,s2)->s1.compareTo(s2))"
  },
  {
    "category": "Java 8.",
    "question": "Какова структура лямбда-выражения?",
    "answer": "Лямбда выражение имеет следующую структуру: (method params) -> {lambda expression body} где       method params - список входящих параметров, разделенных запятой(в случаи если параметров больше одного заключаются в скобки).      оператор \"->\" - служит разделителем между списком параметров нашего метода и телом, в котором происходит его реализация.      lambda expression body - тело метода, состоящее из одного выражения или нескольких, заключенных в фигурные скобки."
  },
  {
    "category": "Java 8.",
    "question": "К каким переменным есть доступ у Лямбда-выражений?",
    "answer": "Лямбда-выражения имеют доступ к переменным области видимости, в которой их определили. Но доступ возможен только при условии, что переменные являются effective final, то есть либо явно имеют модификатор final, либо не меняют своего значения после инициализации, если переменной присваивается значение во второй раз, лямбда-выражение вызывает ошибку компиляции."
  },
  {
    "category": "Java 8.",
    "question": "Что такое ссылки на метод?",
    "answer": "Ссылки на метод - компактные лямбда-выражения которые позволяют передавать ссылки на методы или конструкторы. Для этого нужно использовать ключевое слово \"::\". Ссылочные методы внедряют полезный синтаксис, чтобы ссылаться на существующие методы или конструкторы Java-классов или объектов (экземпляров). Совместно с лямбда-выражениями, ссылочные методы делают языковые конструкции компактными и лаконичными, делая его шаблонным."
  },
  {
    "category": "Java 8.",
    "question": "Какие виды ссылок на методы вы знаете?",
    "answer": "Существует четыре вида ссылок на методы:      Ссылка на статический метод(ContainingClass::staticMethodName)     Ссылка на метод конкретного объекта(ContainingObject::instanceMethodName)     Ссылка на метод произвольного объекта конкретного типа(ContainingType::methodName)     Ссылка на конструктор(ClassName::new), для дженериков (generics) Class< T >::new."
  },
  {
    "category": "Java 8.",
    "question": "Объясните выражение System.out::println.",
    "answer": "Выражение System.out::println является ссылкой на статический метод println об'єкта out класа System, который эквивалентен лямбда-выражению x -> System.out.println(x)."
  },
  {
    "category": "Java 8.",
    "question": "Что такое функциональные интерфейсы?",
    "answer": "Функциональный интерфейс - это тот интерфейс, который определяет строго один абстрактный метод. В Java 8 была введена новая аннотация @FunctionalInterface для обозначения интерфейса, функциональным, эта аннотация используется для того, чтобы избежать случайного добавления абстрактных методов в функциональный интерфейс. Она не обязательна, но является хорошей практикой написания кода. Функциональные интерфейсы позволяют нам использовать лямбда-выражения для создания экземпляра таких интерфейсов. Лучшим примером функционального интерфейса будет интерфейс java.lang.Runnable с одним абстрактным методом run(). Заметим, интерфейс может включать сколько угодно default методов и при этом оставаться функциональным, потому что default методы - не абстрактные."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс BiConsumer<T,U>?",
    "answer": "Представляет собой операцию, которая принимает два входных параметра, и не возвращает никакого результата."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс BiFunction<T,U,R>?",
    "answer": "Представляет собой функцию, которая принимает два аргумента и возвращает результат."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс BinaryOperator<T>?",
    "answer": "Представляет собой операцию над двумя операндами одного и того же типа, выполняет над ними бинарную операцию и возвращает результат того же типа, что и операнды."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс BiPredicate<T,U>?",
    "answer": "Представляет собой предикат (булеву функцию) двух аргументов."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс BooleanSupplier?",
    "answer": "Представляет собой поставщика булевых результатов."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс Consumer<T>?",
    "answer": "Представляет собой операцию, которая принимает один входной аргумент, выполняет некоторое действие над объектом типа T, при этом ничего не возвращая."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс DoubleBinaryOperator?",
    "answer": "Представляет собой операцию над двумя операндами типа double, возвращает результат типа double."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс DoubleConsumer?",
    "answer": "Представляет собой операцию, которая принимает один аргумент типа double, и не возвращает результат."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс DoubleFunction<R>?",
    "answer": "Представляет собой функцию, которая принимает один аргумент типа double, и возвращает результат."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс DoublePredicate?",
    "answer": "Представляет собой предикат (булеву функцию) одного аргумента типа double."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс DoubleSupplier?",
    "answer": "Представляет собой поставщика double результатов."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс DoubleToIntFunction?",
    "answer": "Представляет собой функцию, которая принимает один аргумент типа double, возвращает результат типу int."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс DoubleToLongFunction?",
    "answer": "Представляет собой функцию, которая принимает один аргумент типа double, и возвращает результат типу long."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс DoubleUnaryOperator?",
    "answer": "Представляет собой операцию над одним аргументом типа double, возвращает результат типу double."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс Function<T,R>?",
    "answer": "Представляет собой функцию перехода от объекта типа T к объекту типа R."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс IntBinaryOperator?",
    "answer": "Представляет собой операцию над двумя операндами типа int, возвращает результат типа int."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс IntConsumer?",
    "answer": "Представляет собой операцию, которая принимает один аргумент типа int, и не возвращает результат."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс IntFunction<R>?",
    "answer": "Представляет собой операцию, которая принимает один аргумент типа int, возвращает результат."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс IntPredicate?",
    "answer": "Представляет собой предикат (булеву функцию) одного аргумента типа int."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс IntSupplier?",
    "answer": "Представляет собой поставщика int результатов."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс IntToDoubleFunction?",
    "answer": "Представляет собой функцию, которая принимает один аргумент типа int, возвращает результат типу double."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс IntToLongFunction?",
    "answer": "Представляет собой функцию, которая принимает один аргумент типа int, возвращает результат типу long."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс IntUnaryOperator?",
    "answer": "Представляет собой операцию над одним аргументом типа int, возвращает результат типу int."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс LongBinaryOperator?",
    "answer": "Представляет собой операцию над двумя операндами типа long, возвращает результат типа long."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс LongConsumer?",
    "answer": "Представляет собой операцию, которая принимает один аргумент типа long, не возвращает результат."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс LongFunction<R>?",
    "answer": "Представляет собой функцию, которая принимает один аргумент типа long, и возвращает результат."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс LongPredicate?",
    "answer": "Представляет собой предикат (булеву функцию) одного аргумента типа long."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс LongSupplier?",
    "answer": "Представляет собой поставщика long результатов."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс LongToDoubleFunction?",
    "answer": "Представляет собой функцию, которая принимает один аргумент типа long, и возвращает результат типу double."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс LongToIntFunction?",
    "answer": "Представляет собой функцию, которая принимает один аргумент типа long, и возвращает результат типу int."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс LongUnaryOperator?",
    "answer": "Представляет собой операцию над одним аргументом типа long, возвращает результат типу long."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс ObjDoubleConsumer<T>?",
    "answer": "Представляет собой операцию, которая принимает один аргумент типа object, и второй типа double, и не возвращает результат."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс ObjIntConsumer<T>?",
    "answer": "Представляет собой операцию, которая принимает один аргумент типа object, и второй типа int, и не возвращает результат."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс ObjLongConsumer<T>?",
    "answer": "Представляет собой операцию, которая принимает один аргумент типа object, и второй типа long, и не возвращает результат."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс Predicate<T>?",
    "answer": "Представляет собой предикат (булеву функцию) одного аргумента."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс Supplier<T>?",
    "answer": "Представляет собой поставщика результатов."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс ToDoubleBiFunction<T,U>?",
    "answer": "Представляет собой функцию, которая принимает два аргумента, возвращает результат типу double."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс ToDoubleFunction<T>?",
    "answer": "Представляет собой функцию, которая принимает один аргумент, возвращает результат типа double."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс ToIntBiFunction<T,U>?",
    "answer": "Представляет собой функцию, которая принимает два аргумента, возвращает результат типу int."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс ToIntFunction<T>?",
    "answer": "Представляет собой функцию, которая принимает один аргумент, возвращает результат типа int."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс ToLongBiFunction<T,U>?",
    "answer": "Представляет собой функцию, которая принимает два аргумента, возвращает результат типу long."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс ToLongFunction<T>?",
    "answer": "Представляет собой функцию, которая принимает один аргумент, возвращает результат типа long."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен функциональный интерфейс UnaryOperator<T>?",
    "answer": "Представляет собой операцию над одним операндом, возвращает результат того же типа, что и операнд."
  },
  {
    "category": "Java 8.",
    "question": "Что такое StringJoiner?",
    "answer": "StringJoiner используется, чтобы создать последовательность символов, разделенных разделителем, может (но это не обязательно) начинаться с префикса и заканчиваться суффиксом. Пример: newStringJoiner(\".\") StringJoiner.add(\"first\").add(''second') // result first.second"
  },
  {
    "category": "Java 8.",
    "question": "Что такое default методы?",
    "answer": "Начиная с Java 8 мы можем использовать в интерфейсах стандартные методы (default methods) и статические методы (static methods).  Default метод - это метод в интерфейсе с по умолчанию реализованной логикой, который не требуется обязательно определять в реализации этого интерфейса."
  },
  {
    "category": "Java 8.",
    "question": "Что такое static методы?",
    "answer": "Static-методы в интерфейсе - это по существу то же самое, что static-методы в абстрактном классе.      Статические методы в интерфейсе являются частью интерфейса, мы не можем использовать его для объектов класса реализации.     Статические методы в интерфейсе хороши для обеспечения вспомогательных методов, например, проверки на null, сортировки коллекций и т.д.     Статические методы в интерфейсе помогают обеспечивать безопасность, не позволяя классам, которые реализуют интерфейс, переопределить их.     Мы не можем определить статические методы для методов класса Object, потому что получим ошибку компиляции."
  },
  {
    "category": "Java 8.",
    "question": "Как вызывать default-метод интерфейса в классе?",
    "answer": "Используя ключевое слово super вместе с именем интерфейса."
  },
  {
    "category": "Java 8.",
    "question": "Как вызывать static-метод интерфейса в классе?",
    "answer": "Используя имя интерфейса."
  },
  {
    "category": "Java 8.",
    "question": "Что такое потоки(stream) в Java 8",
    "answer": "java.util.stream - введен для поддержки распараллеливания вычислений в потоках. Предоставляет возможность обрабатывать последовательность элементов исполняя одну или несколько операций, которые могут выполняться либо последовательно либо паралельно. Потоки делятся на последовательные и параллельные. Самая большая польза от этого - в работе с коллекциями. Операции над потоком относятся либо к промежуточным, либо к терминальным. Все промежуточные операции возвращают поток, так что мы можем объединять несколько промежуточных операций без использования точки с запятой. Терминальные операции возвращают void или непотоковый результат."
  },
  {
    "category": "Java 8.",
    "question": "Для чего нужен метод collect Java 8?",
    "answer": "Большинство операций класса Stream, которые модифицируют набор данных, возвращают этот набор в виде потока. Однако бывают ситуации, когда хотелось бы получить данные не в виде потока, а в виде обычной коллекции, например, ArrayList или HashSet. И для этого у класса Stream определен метод collect. Метод принимает в качестве параметра функцию преобразования к коллекции: <R,A> R collect(Collector<? super T,A,R> collector) Параметр R представляет тип результата метода, параметр Т - тип элемента в потоке, а параметр А - тип промежуточных накапливаемых данных. В итоге параметр collector представляет функцию преобразования потока в коллекцию."
  },
  {
    "category": "Java 8.",
    "question": "В чем разница между коллекцией(Collection) и потоком(Stream)?",
    "answer": "Разница между коллекцией(Collection) данных и потоком(Stream) из новой JDK8 в том что коллекции позволяют работать с элементами по-отдельности, тогда как поток(Stream) не позволяет. Например, с использованием коллекций, вы можете добавлять элементы, удалять, и вставлять в середину. Поток(Stream) не позволяет манипулировать отдельными элементами из набора данных, но вместо этого позволяет выполнять функции над данными как одним целом."
  },
  {
    "category": "Java 8.",
    "question": "Для чего предназначен метод forEach в потоках(stream)?",
    "answer": "Метод void forEach(Consumer<? super T> action) - для каждого элемента выполняется действие action. forEach является терминальной операцией, используется для перебора каждого элемента потока. forEach не гарантирует последовательности вывода элементов в параллельном stream-е, для этого используется метод forEachOrdered - он это гарантирует."
  },
  {
    "category": "Java 8.",
    "question": "Как вывести на экран 10 случайных чисел, используя forEach?",
    "answer": "random.inits().limit(10).forEach(System.out::println)"
  },
  {
    "category": "Java 8.",
    "question": "Для чего предназначен метод map в потоках(stream)?",
    "answer": "Метод <R> Stream<R> map(Function<? super T,? extends R> mapper) - преобразует элементы типа T в элементы типа R и возвращает поток с элементами R. map является промежуточной операцией, метод используется для преобразования элементов в другой объект при помощи переданной функции."
  },
  {
    "category": "Java 8.",
    "question": "Как можно вывести на экран уникальные квадраты чисел используя метод map?",
    "answer": ""
  },
  {
    "category": "Java 8.",
    "question": "Какова цель метода filter в потоках(stream)?",
    "answer": "Метод Stream<T> filter(Predicate<? super T> predicate) - фильтрует элементы в соответствии с условием в предикате. filter является промежуточной операцией, используется для фильтрации массива через функцию. На самом деле filter, не выполняет фильтрацию, вместо этого он создается новый поток, который по завершению формирования, содержит элементы исходного потока, которые соответствуют заданному предикату."
  },
  {
    "category": "Java 8.",
    "question": "Как вывести на экран количество пустых строк с помощью метода filter?",
    "answer": ""
  },
  {
    "category": "Java 8.",
    "question": "Для чего предназначен метод limit в потоках(stream)?",
    "answer": "Метод Stream<T> limit(long maxSize) - оставляет в потоке только maxSize элементов. limit является промежуточной операцией, используется для выборки первых maxSize элементов потока. Этот метод также возвращает модифицированный поток, в котором не более maxSize элементов."
  },
  {
    "category": "Java 8.",
    "question": "Для чего предназначен метод sorted в потоках(stream)?",
    "answer": "Метод Stream<T> sorted()/Stream<T> sorted(Comparator<? super T> comparator) - возвращает отсортированный поток. sorted является промежуточной операцией, метод используется для сортировки потока используя естественный порядок сравнения его элементов. Существует также второй метод sorted(), принимающий либо экземпляр Comparable, либо соответствующее ему лямбда-выражение."
  },
  {
    "category": "Java 8.",
    "question": "Как вывести на экран 10 случайных чисел в отсортированном порядке в Java 8?",
    "answer": ""
  },
  {
    "category": "Java 8.",
    "question": "Параллельная обработка в Java 8?",
    "answer": "Чтобы сделать обычный последовательный поток параллельным, надо вызвать у объекта Stream метод parallel. Кроме того, можно также использовать метод parallelStream() интерфейса Collection для создания параллельного потока из коллекции. В то же время если рабочая машина не является многоядерной, то поток будет выполняться как последовательный."
  },
  {
    "category": "Java 8.",
    "question": "Как найти максимальное число в списке Java 8?",
    "answer": "IntSummaryStatic static =numbers.stream().mapToInt(x->(x)).sumarrystatic static.getMax()"
  },
  {
    "category": "Java 8.",
    "question": "Как найти минимальное число в списке Java 8?",
    "answer": "IntSummaryStatic static =numbers.stream().mapToInt(x->(x)).sumarrystatic static.getMin()"
  },
  {
    "category": "Java 8.",
    "question": "Как получить сумму всех чисел в списке, используя Java 8?",
    "answer": "IntSummaryStatic static =numbers.stream().mapToInt(x->(x)).sumarrystatic static.getSum()"
  },
  {
    "category": "Java 8.",
    "question": "Как получить среднее значение всех чисел, в списке, используя Java 8?",
    "answer": "IntSummaryStatic static =numbers.stream().mapToInt(x->(x)).sumarrystatic static.getAverage()"
  },
  {
    "category": "Java 8.",
    "question": "Что такое Optional?",
    "answer": "Optional - это контейнер объекта, он может содержать значение или некоторый тип Т, или просто быть null. Он предоставляет много полезных методов избавляющие от добавления повторяющихся if null/notNull проверок, что позволяет нам сфокусироваться на том, что мы хотим сделать. Метод isPresent() возвращает true если экземпляр Optional содержит не null значение и false в противном случае. Метод orElseGet() содержит запасной механизм результата, если Optional содержит null, принимая функции для генерации значения по умолчанию. Метод map() преобразует текущее значение Optional и возвращает новый экземпляр Optional. Метод orElse() похож на orElseGet(), но вместо функции он принимает значение по умолчанию."
  },
  {
    "category": "Java 8.",
    "question": "Что такое Nashorn?",
    "answer": "Nashorn - это движок JavaScript, разрабатываемый полностью на Java компанией Oracle.  Он призван дать возможность встраивать код JavaScript в приложения Java. В сравнении с Rhino, который поддерживается Mozilla  Foundation, Nashorn обеспечивает от 2 до 10 раз более высокую производительность, так как он непосредственно компилирует код в памяти и передает байт-код виртуальной машине Java. Nashorn умеет компилировать код JavaScript и генерировать классы Java, которые загружаются специальным загрузчиком. Возможен вызов кода Java прямо из JavaScript."
  },
  {
    "category": "Java 8.",
    "question": "Что такое jjs в Java 8?",
    "answer": "Nashorn поставляется с cmd-утилитой jjs, которая позволяет исполнять JavaScript прямо в консоли. jjs принимает список JavaScript файлов исходного кода и запускает их. Чтобы запустить файл давайте передадим его как аргумент в jjs: jjs fileName.js"
  },
  {
    "category": "Java 8.",
    "question": "Что такое LocalDateTime в Java 8?",
    "answer": "LocalDateTime объединяет вместе LocaleDate и LocalTime и содержит дату и время, но без часового пояса в календарной системе ISO-8601. Время хранится с точностью до наносекунды, так что в LocalTime можно хранить, например, величину \"13:45.30.123456789\". Есть множество удобных методов, таких как plusMinutes, plusHours, isAfter, toSecondOfDay и т.д."
  },
  {
    "category": "Java 8.",
    "question": "Что такое ZonedDateTime в Java 8?",
    "answer": "ZonedDateTime - аналог java.util.Calendar. Это самый мощный класс с полной информацией о временном контексте, включает временную зону. Он содержит дату и время в календарной системе ISO-8601."
  },
  {
    "category": "Java 8.",
    "question": "Как получить текущую дату с использованием time API из Java 8?",
    "answer": "LocalDate.now()"
  },
  {
    "category": "Java 8.",
    "question": "Как добавить 1 неделю к текущей дате с использованием time API?",
    "answer": "today = LocalDate.now() today.plus(1,ChronoUnit.WEEKS)"
  },
  {
    "category": "Java 8.",
    "question": "Как добавить 1 месяц к текущей дате с использованием time API?",
    "answer": "today = LocalDate.now() today.plus(1,ChronoUnit.MOUTH)"
  },
  {
    "category": "Java 8.",
    "question": "Как добавить 1 год к текущей дате с использованием time API?",
    "answer": "today = LocalDate.now() today.plus(1,ChronoUnit.YEARS)"
  },
  {
    "category": "Java 8.",
    "question": "Как добавить 10 лет к текущей дате с использованием time API?",
    "answer": "today = LocalDate.now() today.plus(1,ChronoUnit.DECADES)"
  },
  {
    "category": "Java 8.",
    "question": "Как получить следующий вторник используя time API?",
    "answer": "today = LocalDate.now() today.with(TemporalAdjustrs.next(DayOfWeek.TUESDAY)"
  },
  {
    "category": "Java 8.",
    "question": "Как получить вторую субботу текущего месяца используя time API?",
    "answer": ""
  },
  {
    "category": "Java 8.",
    "question": "Как получить текущею дату в миллисекундах используя time API?",
    "answer": ""
  },
  {
    "category": "Java 8.",
    "question": "Як получить текущею дату по местному времени в миллисекундах используя используя time API?",
    "answer": ""
  },
  {
    "category": "Java 8.",
    "question": "Какой класс появился в Java 8 для декодирования данных?",
    "answer": "В Java 8 для этого появился класс public static class Base64.Decoder - этот класс реализует декодер для декодирования байт данных, используя схему кодирования Base64 как указано в RFC 4648 и RFC 2045, класс безопасен для использования несколькими параллельными потоками."
  },
  {
    "category": "Java 8.",
    "question": "Какой класс появился в Java 8 для кодирования данных?",
    "answer": "В Java 8 для этого появился класс public static class Base64.Encoder - этот класс реализует кодер для кодирования байт данных, используя схему кодирования Base64 как указано в RFC 4648 и RFC 2045, класс безопасен для использования несколькими параллельными потоками."
  },
  {
    "category": "Java 8.",
    "question": "Как создать Base64 декодировщик?",
    "answer": "Используя метод getDecoder() класса Base64 он возвращает декодировщик Base64.Decoder, который декодирует данные с помощью схемы кодирования base64."
  },
  {
    "category": "Java 8.",
    "question": "Как создать Base64 кодировщик?",
    "answer": "Используя метод getEncoder() класса Base64 он возвращает кодировщик Base64.Encoder, который кодирует данные с помощью схемы кодирования base64."
  },
  {
    "category": "Потоки ввода/вывода в java.",
    "question": "Что такоє символьная ссылка?",
    "answer": "Символьная ссылка (Symbolic link, симлинк) - специальный файл в файловой системе, содержащий только текстовую строку с указателем. Эта строка трактуется как путь к файлу, который должен быть открыт при попытке обратиться к данному файлу."
  },
  {
    "category": "Потоки ввода/вывода в java.",
    "question": "Какая разница между I/О и NIO?",
    "answer": "I/O (input/output, ввод-вывод ) - взаимодействие между обработчиком информации и её поставщиком и/или получателем. Ввод - сигнал или данные, полученные обработчиком, а вывод - сигнал или данные, посланные им (или из него). NIO (/*в контексте Java*/ Non-blocking I/O, New I/O) - коллекция прикладных программных интерфейсов для языка Java, предназначенных для реализации высокопроизводительных операций ввода-вывода. Также встречается аббревиатура NIO.2 - она относится к нововведениям относительно этого направления в Java 7."
  },
  {
    "category": "Потоки ввода/вывода в java.",
    "question": "Какие особенности NIO вы знаете?",
    "answer": "Ключевые особенности NIO:      Каналы и селекторы: NIO поддерживает различные типы каналов. Канал является абстракцией объектов более низкого уровня файловой системы (например, отображенные в памяти файлы и блокировки файлов), что позволяет передавать данные с более высокой скоростью. Каналы не блокируются и поэтому Java предоставляет еще такие инструменты, как селектор, который позволяет выбрать готовый канал для передачи данных, и сокет, который является инструментом для блокировки.     Буферы: в Java 7 была введена буферизация для всех классов-обёрток примитивов (кроме Boolean). Появился абстрактный класс Buffer, который предоставляет такие операции, как clear, flip, mark и т.д. Его подклассы предоставляют методы для получения и установки данных.     Кодировки: в Java 7 появились кодировки (java.nio.charset), кодеры и декодеры для отображения байт и символов Unicode."
  },
  {
    "category": "Потоки ввода/вывода в java.",
    "question": "Какие существуют виды потоков ввода/вывода?",
    "answer": "Потоки ввода/вывода используются для передачи данных в файловые потоки, на консоль или на сетевые соединения. Существует два вида потоков ввода/вывода: байтовые и символьные."
  },
  {
    "category": "Потоки ввода/вывода в java.",
    "question": "Назовите основные классы потоков ввода/вывода.",
    "answer": "Байтовые: java.io.InputStream, java.io.OutputStream  Символьные: java.io.Reader, java.io.Writer"
  },
  {
    "category": "Потоки ввода/вывода в java.",
    "question": "Чем отличаются и что общего у OutputStream, InputStream, Writer, Reader?",
    "answer": "Класс OutputStream - это абстрактный класс, определяющий потоковый байтовый вывод. В этой категории находятся классы, определяющие, куда направляются ваши данные: в массив байтов (но не напрямую в String  предполагается что вы сможете создать их из массива байтов), в файл или канал. Базовый класс InputStream представляет классы, которые получают данные из различных источников:      массив байтов     строка (String)     файл     канал (pipe): данные помещаются с одного конца и извлекаются с другого     последовательность различных потоков, которые можно объединить в одном потоке     другие источники (например, подключение к интернету)  Символьные потоки имеют два основных абстрактных класса Reader и Writer, управляющие потоками символов Unicode. Класс Reader - абстрактный класс, определяющий символьный потоковый ввод. Класс Writer - абстрактный класс, определяющий символьный потоковый вывод. В случае ошибок все методы класса передают исключение IOException."
  },
  {
    "category": "Потоки ввода/вывода в java.",
    "question": "Какие подклассы базового класса InputStream ви знаєте, для чего они предназначены?",
    "answer": "Подклассы базового класса InputStream:      StringBufferInputStream - превращает строку (String) во входной поток данных InputStream.     SequenceInputStream - сливает два или более потока InputStream в единый поток.     PushbackInputStream - входной поток, поддерживающий однобайтовый возврат во входной поток.     PrintStream - выходной поток, включающий методы print() и println().     PipedInputStream - реализует понятие входного канала.     ObjectInputStream - входной поток для объектов.     InputStream - абстрактный класс, описывающий поток ввода.     FilterInputStream - абстрактный класс, предоставляющий интерфейс для классов-надстроек, которые добавляют к существующим потокам полезные свойства.     FileInputStream - для чтения информации из файла.     DataInputStream - входной поток, включающий методы для чтения стандартных типов данных Java.     ByteArrayInputStream - позволяет использовать буфер в памяти (массив байтов) в качестве источника данных для входного потока.     BufferedInputStream - буферизированный входной поток."
  },
  {
    "category": "Потоки ввода/вывода в java.",
    "question": "Что вы знаете о RandomAccessFile?",
    "answer": "RandomAccessFile это класс который наследуется напрямую от Object и не наследуется от вышеприведенных базовых классов ввода\\вывода. Предназначен для работы с файлами, поддерживая произвольный доступ к их содержимому. Работа с классом RandomAccessFile напоминает использование совмещенных в одном классе потоков DataInputStream и DataOutputStream (они реализуют те же интерфейсы DataInput и DataOutput). Кроме того, метод seek() позволяет переместиться к определенной позиции и изменить хранящееся там значение. При использовании RandomAccessFile необходимо знать структуру файла. Класс RandomAccessFile содержит методы для чтения и записи примитивов и строк UTF-8."
  },
  {
    "category": "Потоки ввода/вывода в java.",
    "question": "Какие есть режимы доступа к файлу есть у RandomAccessFile ?",
    "answer": "RandomAccessFile может открываться в режиме чтения (\"r\") или чтения/записи (\"rw\"). Также есть режим \"rws\", когда файл открывается для операций чтения-записи и каждое изменение данных файла немедленно записывается на физическое устройство."
  },
  {
    "category": "Потоки ввода/вывода в java.",
    "question": "Какие подклассы базового класса OutputStream ви знаєте, для чего они предназначены?",
    "answer": "Класс OutputStream - это абстрактный класс, определяющий потоковый байтовый вывод. В этой категории находятся классы, определяющие, куда направляются ваши данные: в массив байтов (но не напрямую в String  предполагается что вы сможете создать их из массива байтов), в файл или канал. Подклассы базового класса OutputStream:      PipedOutputStream - реализует понятие выходного канала.     ObjectOutputStream - выходной поток для объектов     FilterOutputStream - абстрактный класс, предоставляющий интерфейс для классов-надстроек, которые добавляют к существующим потокам полезные свойства.     FileOutputStream - отправка данных в файл на диске. Реализация класса OutputStream.     DataOutputStream - выходной поток, включающий методы для записи стандартных типов данных Java.     ByteArrayOutputStream - создает буфер в памяти. Все данные, посылаемые в этот поток, размещаются в созданном буфере.     BufferedOutputStream - буферизированный выходной поток."
  },
  {
    "category": "Потоки ввода/вывода в java.",
    "question": "Для чего используется PushbackInputStream?",
    "answer": "Разновидность буферизации, обеспечивающая чтение байта с последующим его возвратом в поток. Класс PushbackInputStream представляет механизм \"заглянуть\" во входной поток и увидеть, что оттуда поступит в следующий раз, не извлекая информации. У класса есть дополнительный метод unread()."
  },
  {
    "category": "Потоки ввода/вывода в java.",
    "question": "Для чего используется SequenceInputStream?",
    "answer": "Класс SequenceInputStream позволяет соединять вместе несколько экземпляров класса InputStream. Конструктор принимает в качестве аргумента либо пару объектов класса InputStream, либо интерфейс Enumeration. Во время работы класс выполняет запросы на чтение из первого объекта класса InputStream и до конца, а затем переключается на второй. При использовании интерфейса работа продолжится по всем объектам класса InputStream. По достижении конца каждого файла, связанный с ним поток закрывается. Закрытие потока, созданного объектом класса SequenceInputStream, приводит к закрытию всех открытых потоков."
  },
  {
    "category": "Потоки ввода/вывода в java.",
    "question": "Какие подклассы базового класса Reader ви знаєте, для чего они предназначены?",
    "answer": "Подклассы базового класса Reader:      StringReader - входной поток, читающий из строки.     Reader - абстрактный класс, описывающий символьный ввод.     PushbackReader - входной поток, позволяющий возвращать символы обратно в поток.     PipedReader - входной канал.     LineNumberReader - входной поток, подсчитывающий строки.     InputStreamReader - входной поток, транслирующий байты в символы.     FilterReader - фильтрующий читатель.     FileReader - входной поток, читающий файл.     CharArrayReader - входной поток, который читает из символьного массива.     BufferedReader - буферизированный входной символьный поток."
  },
  {
    "category": "Потоки ввода/вывода в java.",
    "question": "Какие подклассы базового класса Writer ви знаєте, для чего они предназначены?",
    "answer": "Подклассы базового класса Writer:      Writer - абстрактный класс, описывающий символьный вывод     StringWriter - выходной поток, пишущий в строку     PrintWriter - выходной поток, включающий методы print() и println()     PipedWriter - выходной канал     OutputStreamWriter - выходной поток, транслирующий байты в символы     FilterWriter - фильтрующий писатель     FileWriter - выходной поток, пишущий в файл     CharArrayWriter - выходной поток, который пишет в символьный массив     BufferedWriter - буферизированный выходной символьный поток"
  },
  {
    "category": "Потоки ввода/вывода в java.",
    "question": "Что такое абсолютный путь и относительный путь?",
    "answer": "Абсолютный путь - это путь, который указывает на одно и то же место в файловой системе, вне зависимости от текущей директории. Полный путь всегда начинается с корневого каталога. Относительный путь - это путь по отношению к текущему рабочему каталогу."
  },
  {
    "category": "Потоки ввода/вывода в java.",
    "question": "В каких пакетах лежат классы-потоки?",
    "answer": "Стандартный классы ввода\\вывода в Java лежат в пакете java.io.*. В JDK 7 добавлен более современный способ работы с потоками под названием Java NIO или Java New IO ети классы лежат в пакете java.nio.*. Для работы с архивами используются классы из пакета java.util.*."
  },
  {
    "category": "Потоки ввода/вывода в java.",
    "question": "Что вы знаете о классах-надстройках?",
    "answer": "Классы-настройки ето классы которые добавляют к существующим потокам полезные дополнительные свойства. Примеры классов: BufferedOutputStream, BufferedInputStrem, BufferedWriter , BufferedReader -  буферезируют поток и повышают производительность."
  },
  {
    "category": "Потоки ввода/вывода в java.",
    "question": "Какой класс-надстройка позволяет читать данные из входного байтового потока в формате примитивных типов данных?",
    "answer": "Для чтения байтовых данных (не строк) применяется класс DataInputStream. В этом случае необходимо использовать классы из группы InputStream. Для преобразования строки в массив байтов, пригодный для помещения в поток ByteArrayInputStream, в классе String предусмотрен метод getBytes(). Полученный ByteArrayInputStream представляет собой поток InputStream, подходящий для передачи DataInputStream. При побайтовом чтении символов из форматированного потока DataInputStream методом readByte() любое полученное значение будет считаться действительным, поэтому возвращаемое значение неприменимо для идентификации конца потока. Вместо этого можно использовать метод available(), который сообщает, сколько еще осталось символов. Класс DataInputStream позволяет читать элементарные данные из потока через интерфейс DataInput, который определяет методы, преобразующие элементарные значения в форму последовательности байтов. Такие потоки облегчают сохранение в файле двоичных данных."
  },
  {
    "category": "Потоки ввода/вывода в java.",
    "question": "Какой класс-надстройка позволяет ускорить чтение/запись за счет использования буфера?",
    "answer": "Для этого используются классы, позволяющие буферизировать поток:      java.io.BufferedInputStream - буферизированный входной поток. Конструкторы: BufferedInputStream(InputStream in), BufferedInputStream(InputStream in, int size).     java.io.BufferedOutputStream - буферизированный выходной поток. Конструкторы: BufferedOutputStream(OutputStream out), BufferedOutputStream(OutputStream out, int size).     java.io.BufferedReader - буферизированный входной символьный поток. Конструкторы: BufferedReader(Reader r), BufferedReader(Reader in, int sz).     java.io.BufferedWriter - буферизированный выходной символьный поток. Конструкторы: BufferedWriter(Writer out), BufferedWriter(Writer out, int sz)."
  },
  {
    "category": "Потоки ввода/вывода в java.",
    "question": "Какие классы позволяют преобразовать байтовые потоки в символьные и обратно?",
    "answer": "OutputStreamWriter - это мост между классом OutputStream и классом Writer. Символы, записанные в поток, преобразовываются в байты. InputStreamReader - аналог для чтения. При помощи методов класса Reader читаются байты из потока InputStream и далее преобразуются в символы."
  },
  {
    "category": "Потоки ввода/вывода в java.",
    "question": "В чем отличие класса PrintWriter от PrintStream?",
    "answer": "Прежде всего, в классе PrintWriter применен усовершенствованный способ работы с символами UNICODE и другой механизм буферизации вывода. В классе PrintStream буфер вывода сбрасывался всякий раз, когда вызывался метод print или println. При использовании класса PrintWriter вы можете отказаться от автоматического сброса буферов, выполняя его явным образом при помощи метода flush. В классе PrintWriter предусмотрено два конструктора, позволяющих работать с выходными потоками класса OutputStream:      public PrintWriter(OutputStream out)  - создает поток без автоматического сброса буферов.     public PrintWriter(OutputStream out, boolean autoFlush)  - способ сброса буферов при использовании второго конструктора зависит от значения параметра autoFlush. Если он равен true, автоматический сброс буферов выполняется, а если false - нет.  Набор реализаций основных методов print и println класса PrintWriter аналогичен набору реализация этих методов класса PrintStream. Здесь же мы упомянем только методы flush и checkError. Метод flush вызывает принудительный сброс буфера вывода. Если поток PrintWriter создан на базе стандартного потока вывода System.out, то записанные в него данные появятся на консоли только после выполнения сброса буфера (автоматического или сделанного методом flush). Что же касается метода checkError, то в случае возникновения ошибок он возвращает значение true."
  },
  {
    "category": "Потоки ввода/вывода в java.",
    "question": "Какой класс предназначен для работы с элементами файловой системы?",
    "answer": "В отличие от большинства классов ввода/вывода, класс File работает не с потоками, а непосредственно с файлами. Данный класс позволяет получить информацию о файле: права доступа, время и дата создания, путь к каталогу. А также осуществлять навигацию по иерархиям подкаталогов. Класс java.io.File может представлять имя определённого файла, а также имена группы файлов, находящихся в каталоге. Если класс представляет каталог, то его метод list() возвращает массив строк с именами всех файлов. Для создания объектов класса File можно использовать один из следующих конструкторов.      File(File dir, String name) - указывается объекта класса File (каталог) и имя файла     File(String path) - указывается путь к файлу без указания имени файла     File(String dirPath, Sring name) - указывается путь к файлу и имя файла     File(URI url) - указывается объекта URI, описывающий файл"
  },
  {
    "category": "Потоки ввода/вывода в java.",
    "question": "Какой символ является разделителем при указании пути в файловой системе?",
    "answer": "Для различных систем символ разделителя различается. Вытащить его можно используя file.separator, а так же в статическом поле File.separator.  Для Windows это \"\\\"."
  },
  {
    "category": "Потоки ввода/вывода в java.",
    "question": "Какие методы класса File ви знаєте?",
    "answer": "У класса File очень много методов, перечислим некоторые.      getAbsolutePath() - абсолютный путь файла, начиная с корня системы. В Android корневым элементом является символ слеша (/)     canRead() - доступно для чтения     canWrite() - доступно для записи     exists() - файл существует или нет     getName() - возвращает имя файла     getParent() - возвращает имя родительского каталога     getPath() - путь     lastModified() - дата последнего изменения     isFile() - объект является файлом, а не каталогом     isDirectory - объект является каталогом     isAbsolute() - возвращает true, если файл имеет абсолютный путь     renameTo(File newPath) - переименовывает файл. В параметре указывается имя нового имени файла. Если переименование прошло неудачно, то возвращается false     delete() - удаляет файл. Также можно удалить пустой каталог"
  },
  {
    "category": "Потоки ввода/вывода в java.",
    "question": "Что вы знаете об интерфейсе FileFilter?",
    "answer": "Интерфейс FileFilter применяется для проверки, попадает ли объект ли объект File под некоторое условие. Этот интерфейс содержит единственный метод boolean accept(File pathName). Этот метод необходимо переопределить и реализовать."
  },
  {
    "category": "Потоки ввода/вывода в java.",
    "question": "Какие классы позволяют архивировать объекты?",
    "answer": "DeflaterOutputStream, InflaterInputStream, ZipInputStream, ZipOutputStream,  GZIPInputStream, GZIPOutputStream."
  },
  {
    "category": "Multithreading.",
    "question": "Чем отличается процесс от потока?",
    "answer": "Процесс это некоторая единица операционной системы, которой выделена память и другие ресурсы. Поток это единица исполнения кода. Поток имеет стэк - некоторую свою память для исполнения. Остальная память процесса - общая для всех его потоков. Потоки исполняются на ядрах процессора.  В некоторых OS разница между процессами и потоками сведена к минимуму."
  },
  {
    "category": "Multithreading.",
    "question": "Каким образом можно создать поток?",
    "answer": "Есть несколько способов создания и запуска потоков:      С помощью класса, реализующего Runnable:         Создать объект класса Thread.         Создать объект класса, реализующего интерфейс Runnable.         Вызвать у созданного объекта Thread метод start() (после этого запустится метод run() у переданного объекта, реализующего Runnable).     С помощью класса, расширяющего Thread:         Создать объект класса ClassName extends Thread.         Переопределить run() в этом классе (смотрите примере ниже, где передается имя потока 'Second').     С помощью класса, реализующего java.util.concurrent.Callable:         Создать объект класса, реализующего интерфейс Callable.         Создать объект ExecutorService с указанием пула потоков.         Создать объект Future. Запуск происходит через метод submit()  Сигнатура: <T> Future<T> submit(Callable<T> task)."
  },
  {
    "category": "Multithreading.",
    "question": "Что такое монитор?",
    "answer": "Контроль за доступом к объекту-ресурсу обеспечивает понятие монитора. Монитор экземпляра может иметь только одного владельца. При попытке конкурирующего доступа к объекту, чей монитор имеет владельца, желающий заблокировать объект-ресурс поток должен подождать освобождения монитора этого объекта и только после этого завладеть им и начать использование объекта-ресурса."
  },
  {
    "category": "Multithreading.",
    "question": "Какие способы синхронизации в Java?",
    "answer": "Ниже приведены некоторые способы синхронизации в Java:      Системная синхронизация с использованием wait/notify. Поток, который ждет выполнения каких-либо условий, вызывает у этого объекта метод wait, предварительно захватив его монитор. На этом его работа приостанавливается. Другой поток может вызвать на этом же самом объекте метод notify (опять же, предварительно захватив монитор объекта), в результате чего, ждущий на объекте поток \"просыпается\" и продолжает свое выполнение.      Системная синхронизация с использованием join. Метод join, вызванный у экземпляра класса Thread, позволяет текущему потоку остановиться до того момента, как поток, связаный с этим экземпляром, закончит работу.      Использование классов из пакета java.util.concurrent, который предоставляет набор классов для организации межпоточного взаимодействия. Примеры таких классов - Lock, семафор (Semaphore), etc. Концепция данного подхода заключается в использовании атомарных операций и переменных."
  },
  {
    "category": "Multithreading.",
    "question": "Как работают методы wait и notify/notifyAll?",
    "answer": "Эти метеоды предназначены для межпоточной синхронизации, для взаимодействия потоков между собой. Как работают эти методы. Во-первых они могут вызваны только потоком, который захватил монитор объекта, для которого эти методы вызываются. То есть они вызываются внутри блока synchronized и для объекта, монитор которого этим synchronized захвачен. Если внутри synchronized метода - то для класса, к которому относятся эти методы. Что делает метод wait(). Метод wait() отдает (освобождает) монитор объекта, так что другие потоки теперь могут его (монитор) захватить, то есть войти в блок synchronized для этого объекта. Затем метод wait() переходит в состояние ожидания, до тех пор пока другой поток не вызывет метод notify() или notifyAll() для этого же объекта. После чего поток, в котором был вызван wait(), пытается снова захватить монитор объекта и когда монитор становится свободным, то есть когда другой поток освобождает его, захватывает монитор и продолжает выполнение со следующего после wait() оператора. Причем у потока вызвашего wait() нет никакого преимущества перед другими потоками, ожидающими захвата того же монитора. Что делают методы notify(), notifyAll(). Они \"пробуждают\" поток, ожидающий методом wait() (если такой есть), и переводят его в состояние ожидания освобождения монитора. Разница между notify() и notifyAll() в том, что notify() пробуждает только один поток , ожидающий методом wait(), какой именно будет пробужден - определить нельзя, а notifyAll() - все такие потоки."
  },
  {
    "category": "Multithreading.",
    "question": "Чем отличается работа метода wait с параметром и без параметра?",
    "answer": "Разница методов в следующем:      final void wait()  - метод используется в многопоточной среде, может вызываться только потоком, владеющим объектом синхронизации. При этом объект синхронизации освобождается, а текущий поток переходит в режим ожидания сигнала освобождения объекта синхронизации другим потоком путем вызова метода notify() либо notifyAll().     final void wait(long time)  - аналогично wait() данный метод используется в многопоточной среде, переходит текущий поток в режим ожидания сигнала освобождения объекта синхронизации другим потоком путем вызова метода notify() либо notifyAll(), или ожидание происходит заданное время time, затем выполнение продолжается безусловно."
  },
  {
    "category": "Multithreading.",
    "question": "Как работает метод Thread.yield()? Чем отличаются методы Thread.sleep() и Thread.yield()?",
    "answer": "Основные отличия:      метод yield() - пытается сказать планировщику потоков, что нужно выполнить другой поток, что ожидает в очереди на выполнение. Метод не пытается перевести текущий поток в состояние блокировки, сна или ожидания. Он просто пытается его перевести из состояние \"работающий\" в состояние \"работоспособный\". Однако выполнение метода может вообще не произвести никакого эффекта. состояние потока остатается RUNNABLE      метод sleep() - приостанавливает поток на указанное. состояние меняется на TIMED_WAITING, по истечению - RUNNABLE     метод wait() - меняет состояние потока на WAITING может быть вызвано только у объекта владеющего блокировкой, в противном случае выкинется исключение IllegalMonitorStateException. при срабатывании метода блокировка отпускается, что позволяет продолжить работу другим потокам ожидающим захватить ту же самую блокировку . в случае wait(int) с аргументом состояние будет TIMED_WAITING."
  },
  {
    "category": "Multithreading.",
    "question": "Как работает метод Thread.join()?",
    "answer": "Метод join() вызывается для того, чтобы привязать текущий поток в конец потока для которого вызывается метод. То есть второй поток будет в режиме блокировки пока первый поток не выполнится."
  },
  {
    "category": "Multithreading.",
    "question": "Что такое dead lock?",
    "answer": "Это когда один поток А получил блокировку на объект А1, а поток В получил блокировку на объект В1. В то время как поток А пытается получит блокировку на объект В1, а поток В на А1."
  },
  {
    "category": "Multithreading.",
    "question": "На каком объекте происходит синхронизация при вызове static synchronized метода?",
    "answer": "Представьте себе ситуацию что два потока одновременно изменяют состояние какого-то объекта, это недопустимо. Для этого необходимо синхронизировать потоки. Как это сделать? Ключевое слово synchronized позволяет это сделать установив в сигнатуре метода. Или же в методе можно описать блок synchronized, только в качестве параметра необходимо передать объект, который будет блокироватся. Представьте себе ситуацию когда один поток ждет пока разблокируется объект… а если это ждут несколько потоков? Нет гарантии что тот объект что больше всех ждал снятия блокировки будет выполнятся первым.  Статические синхронизированные методы и нестатические  синхронизированные методы не будет  блокировать друг друга, никогда. Статические  методы блокируются на экземпляре класса Class в то время как нестатические методы блокируются на текущем экземпляре (this). Эти действия не мешают друг другу. wait() - отказывается от блокировки остальные методы сохраняют блокировку."
  },
  {
    "category": "Multithreading.",
    "question": "Для чего используется ключевое слово volatile, synchronized, transient, native?",
    "answer": "Краткое описание ключевых слов:      volatile - указывает на то, что поле синхронизировано для нескольких потоков     synchronized - указывает на то что метод синхронизированный или же в методе может находится такой блок синхронизации.     transient - указывает на то, что переменная не подлежит сериализации     native - говорит о том, что реализация метода написана на другой программной платформе"
  },
  {
    "category": "Multithreading.",
    "question": "Что значит приоритет потока?",
    "answer": "Приоритет потока - это число от 1 до 10, в  зависимости от которого, планировщик потоков выбирает какой поток  запускать. Однако полагаться на приоритеты для предсказуемого выполнения многопоточной  программы нельзя!"
  },
  {
    "category": "Multithreading.",
    "question": "Что такое потоки –демоны в джава?",
    "answer": "Это потоки, которое работают в фоновом  режиме и не гарантируют что они завершатся. Тоеть если все потоки завершились, то поток демон просто обрывается вместе с закрытием приложения."
  },
  {
    "category": "Multithreading.",
    "question": "Что значит усыпить поток?",
    "answer": "Перевести поток в спящее состояние можно  с помощью метода sleep(long ms) ms - время в миллисекундах.  При вызове этого метода, поток переходит  в спящее состояние, после сна, поток переходит в пул потоков и  находится в состоянии \"работоспособный\", т.е. не гарантируется что после пробуждения он будет сразу выполняться. Также поток не может усыпить другой поток, так как метод sleep - это статический метод! Вы просто усыпите текущий поток и не более того! Также метод sleep() может возбуждать InterruptedException()."
  },
  {
    "category": "Multithreading.",
    "question": "В каких состояниях может быть поток в джава? Как вообще работает поток?",
    "answer": "нас есть текущий поток, в котором  выполняется метод main. Этот поток имеет свой стек и этот стек начинается с вызова метода main. Далее в методе main мы создаем новый поток, что происходит… создается новый поток и для него выделяется свой стек с первоначальным методом run(). Когда мы запускаем несколько потоков, то мы не можем гарантировать определенный порядок их вызовов. Планированием  потоков занимается планировщик  потоков JVM, выбирая из пулов потоков  поток. Мы даже не можем гарантировать  что если первый поток начался  выполнятся первым, то он и закончит выполнятся первым, он может закончить выполнятся последним. Еще такой ньюанс, что поток, который закончил свое выполнение, не может быть повторно запущен! Он находится в состоянии \"мертвый\", а для запуска потока нового потока, объект должен находится в состоянии \"новый\". Потоки  имеют такие состояния:      новый(это когда только создали экземпляр класса Thread)     живой  или работоспособный(переходит в это состояние после запуска метода start(), но это не означает что поток уже работает! Или же он может перейти в это состояние из состояние работающий или блокированный)     работающий(это когда метод run() начал выполнятся)     ожидающий (waiting)/Заблокированный (blocked)/Спящий(sleeping). Эти состояния характеризуют поток как не готовый к работе. Я объединил эти состояния т.к. все они имеют общую черту – поток еще жив (alive), но в настоящее время не может быть выполнен. Другими словами поток уже не работает, но он может вернутся в рабочее состояние. Поток может быть заблокирован, это может  означать что он ждет освобождение каких-то ресурсов. Поток может спать, если встретился метод sleep(long s) , или же он может ожидать, если встретился метод wait(), он будет ждать пока не вызовится метод notify() или notifyall().     мертвый(состояние когда метод run() завершил свою работу)"
  },
  {
    "category": "Multithreading.",
    "question": "Чем отличаются два интерфейса для реализации задач Runnable и Callable?",
    "answer": "Основные различия:      Интерфейс Runnable появиля в Java 1.0, а интерфейс Callable был введен в Java 5.0 в составе библиотеки java.util.concurrent.     Классы, реализующие  интерфейс Runnable должны реализовывать метод run() для выполнения задачи. Классы, реализующие интерфейс Callable должны реализовывать метод call() для выполнения задачи.     Метод Runnable.run() не возвращает никакого значения, его тип void, а метод Callable.call() может возвращать значение типа T. Интерфейс Callable является параметризированным  Callable<T> и тип значения, которое будет возвращаться в методе call() задается этим параметром T.      Метод run() не может бросить проверяемое исключение, в то время как метод call() может бросить проверяемое исключение."
  },
  {
    "category": "Multithreading.",
    "question": "Различия между CyclicBarrier и CountDownLatch?",
    "answer": "Хоть оба эти синхронизаторы позволяют нитям дожидаться друг друга, главное различие между ними в том, что вы не можете заново использовать CountDownLatch после того, как его счётчик достигнет нуля, но вы можете использовать CyclicBarrier снова, даже после того, как барьер сломается."
  },
  {
    "category": "Multithreading.",
    "question": "Что такое состояние гонки (race condition)?",
    "answer": "Состояние гонки - причина трудноуловимых багов. Как сказано в самом названии, состояние гонки возникает из-за гонки между несколькими нитями, если нить, которая должна исполнятся первой, проиграла гонку и исполняется вторая, поведение кода изменяется, из-за чего возникают недетерменированные баги. Это одни из сложнейших к отлавливанию и воспроизведению багов, из-за беспорядочной природы гонок между нитями. Пример состояния гонки - беспорядочное исполнение."
  },
  {
    "category": "Multithreading.",
    "question": "Как остановить нить?",
    "answer": "Java предоставляет богатые API для всего, но, по иронии судьбы, не предоставляет удобных способов остановки нити. В JDK 1.0 было несколько управляющих методов, например stop(), suspend() и resume(), которые были помечены как deprecated в будущих релизах из-за потенциальных угроз взаимной блокировки, с тех пор разработчики Java API не предприняли попыток представить стойкий, ните-безопасный и элегантный способ остановки нитей. Программисты в основном полагаются на факт того, что нить останавливается сама, как только заканчивает выполнять методы run() или call(). Для остановки вручную, программисты пользуются преимуществом volatile boolean переменной и проверяют её значение в каждой итерации, если в методе run() есть циклы, или прерывают нити методом interrupt() для внезапной отмены заданий."
  },
  {
    "category": "Multithreading.",
    "question": "Что происходит, когда в нити появляется исключение?",
    "answer": "Это один из хороших вопросов с подвохом. Простыми словами, если исключение не поймано - нить мерта, если установлен обработчик непойманных исключений, он получит колбек. Thread.UncaughtExceptionHandler – интерфейс, определённый как вложенный интерфейс для обработчиков, вызываемых, когда нить внезапно останавливается из-за непойманного исключения. Когда нить собирается остановится из-за непойманного исключения, JVM проверит её на наличие UncaughtExceptionHandler, используя Thread.getUncaughtExceptionHandler(), и вызовет у обработчика метод uncaughtException(), передав нить и исключение в виде аргументов."
  },
  {
    "category": "Multithreading.",
    "question": "Что такое ThreadLocal переменная?",
    "answer": "ThreadLocal переменные - специальный вид переменных, доступных Java программисту. Так же, как для состояний есть переменная состояния, для нитей есть ThreadLocal переменные. Это неплохой способ достичь ните-безопасности для затратных-для-создания объектов, например вы можете сделать SimpleDateFormat ните-безопасным, используя ThreadLocal. Так как это затратный класс, его нежелательно использовать в локальной области, которая требует отдельных экземпляров на каждый вызов. Предоставляя каждой нити её собственную копию, вы убиваете двух зайцев. Во-первых, вы уменьшаете количество экземпляров затратных объектов, используя по новой фиксированное количество экземпляров, и во-вторых, вы достигаете ните-безопасности, без потерь синхронизации и неизменяемости. Ещё один хороший пример локальной переменной у нити - класс ThreadLocalRandom, который уменьшает количество экземпляров затратных-для-создания объектов Random в много-нитиевой среде."
  },
  {
    "category": "Multithreading.",
    "question": "Что такое FutureTask?",
    "answer": "FutureTask представляет собой отменяемое асинхронное вычисление в параллельном Java приложении. Этот класс предоставляет базовую реализацию Future, с методами для запуска и остановки вычисления, методами для запроса состояния вычисления и извлечения результатов. Результат может быть получен только когда вычисление завершено, метод получения будет заблокирован, если вычисление ещё не завершено. Объекты FutureTask могут быть использованы для обёртки объектов Callable и Runnable. Так как FutureTask реализует Runnable, его можно передать Executor’у на выполнение."
  },
  {
    "category": "Multithreading.",
    "question": "Различие между interrupted и isInterrupted?",
    "answer": "Основное различие между interrupted() и isInterrupted() в том, что первый сбрасывает статус прерывания, а второй нет. Механизм прерывания в Java реализован с использованием внутреннего флага, известного как статус прерывания. Прерывание нити вызовом Thread.interrupt() устанавливает этот флаг. Когда прерванная нить проверяет статус прерывания, вызывая статический метод Thread.interrupted(), статус прерывания сбрасывается. Нестатический метод isInterrupted(), который используется нитью для проверки статуса прерывания у другой нити, не изменяет флаг прерывания. Условно, любой метод, который завершается, выкинув InterruptedException сбрасывает при этом флаг прерывания. Однако, всегда существует возможность того, что флаг тут же снова установится, если другая нить вызовет interrupt()."
  },
  {
    "category": "Multithreading.",
    "question": "Почему методы wait и notify вызываются в синхронизированном блоке?",
    "answer": "Основная причина вызова wait и notify из синхронизированого блока или метода в том, что Java API обязательно требует этого. Если вы вызовете их не из синхронизированного блока, ваш код выбросит IllegalMonitorStateException. Более хитрая причина в том, чтобы избежать состояния гонки между вызовами wait и notify."
  },
  {
    "category": "Multithreading.",
    "question": "Что такое пул нитей?",
    "answer": "Создание нити затратно в плане времени и ресурсов. Если вы создаёте нить во время обработки запроса, это замедлит время отклика, также процесс может создать только ограниченное число нитей. Чтобы избежать этих проблем, во время запуска приложения создаётся пул нитей и нити повторно используются для обработки запросов. Этот пул нитей называется \"thread pool\", а нити в нём – рабочая нить. Начиная с Java 1.5 Java API предоставляет фреймворк Executor, который позволяет вам создавать различные пулы нитей, например single thread pool, который обрабатывает только одно задание за единицу времени, fixed thread pool, пул с фиксированным количеством нитей, и cached thread pool, расширяемый пул, подходящий для приложений с множеством недолгих заданий."
  },
  {
    "category": "Multithreading.",
    "question": "Различия между livelock и deadlock?",
    "answer": "Livelock схож с deadlock, только в livelock состояния нитей или вовлечённых процессов постоянно изменяются в зависимости друг от друга. Livelock - особый случай нехватки ресурсов. Реальный пример livelock'а - когда два человека встречаются в узком коридоре и каждый, пытаясь быть вежливым, отходит в сторону, и так они бесконечно двигаются из стороны в сторону."
  },
  {
    "category": "Multithreading.",
    "question": "Как проверить, удерживает ли нить lock?",
    "answer": "Я и не подозревал, что можно проверять, удерживает ли нить lock в данный момент, до тех пор, пока не столкнулся с этим вопросом в одном телефонном интервью. В java.lang.Thread есть метод holdsLock(), он возвращает true, тогда и только тогда, когда текущая нить удерживает монитор у определённого объекта."
  },
  {
    "category": "Multithreading.",
    "question": "Как получить дамп нити?",
    "answer": "Дамп нити позволяет узнать, чем нить занимается в данный момент. Существует несколько способов получения дампа нити, зависящих от операционной системы. В Windows вы можете использовать комбинацию ctrl + Break, в Linux - команду kill -3. Также вы можете воспользоваться утилитой jstack, она оперирует над id процесса, который вы можете узнать с помощью другой утилиты jps."
  },
  {
    "category": "Multithreading.",
    "question": "Какой JVM параметр используется для контроля размера стека нити?",
    "answer": "Это один из простых, -Xss параметер используется для контроля размера стека нити в Java."
  },
  {
    "category": "Multithreading.",
    "question": "Различия между synchronized и ReentrantLock?",
    "answer": "Были времена, когда единственный способ достижения взаимного исключения был через ключевое слово synchronized, но он имеет несколько недостатков, например нельзя расширить lock за пределами метода или блока кода и т.д. Java 5 решает эту проблему, предоставляя более утончённый контроль через интерфейс Lock. ReentrantLock – распространённая реализация Lock, которая предоставляет Lock с таким же базовым поведением и семантикой, как у неявного монитора, достигаемый использованием синхронизированных методов, но с расширенными возможностями."
  },
  {
    "category": "Multithreading.",
    "question": "Что такое Semaphore?",
    "answer": "Semaphore - это новый тип синхронизатора. Это семафор со счётчиком. Концептуально, семафор управляет набором разрешений. Каждый acquire() блокируется, если необходимо, до того, как разрешение доступно, затем получает его. Каждый release() добавляет разрешение, потенциально освобождая блокирующий получатель (acquirer). Однако при этом не используются фактические объекты разрешений  Semaphore просто хранит количество доступных и действует соответственно. Semaphore используется для защиты дорогих ресурсов, которые доступны в ограниченном количестве, например подключение к базе данных в пуле."
  },
  {
    "category": "Multithreading.",
    "question": "Что будет, если очередь пула нитей уже заполнена, а вы подадите задачу?",
    "answer": "Если очередь пула нитей заполнилась, то поданная задача будет \"отклонена\". Метод submit() у ThreadPoolExecutor'а выкидывает RejectedExecutionException, после чего вызывается RejectedExecutionHandler."
  },
  {
    "category": "Multithreading.",
    "question": "Различия между методами submit() и execute() у пула нитей?",
    "answer": "Оба метода являются способами подачи задачи в пул нитей, но между ними есть небольшая разница. Execute(Runnable command) определён в интерфейсе Executor и выполняет поданную задачу в будущем, но, что более важно, ничего не возвращает. С другой стороны submit() – перегруженный метод, он может принимать задачи типов Runnable и Callable и может возвращать объект Future, который можно использовать для отмены выполнения и/или ожидания результата вычислений. Этот метод определён в интерфейсе ExecutorService, который наследуется от интерфейса Executor, и каждый класс пула нитей, например ThreadPoolExecutor или ScheduledThreadPoolExecutor, наследует эти методы."
  },
  {
    "category": "Multithreading.",
    "question": "Что такое блокирующий метод?",
    "answer": "Блокирующий метод - метод, который блокируется, до тех пор, пока не выполнится задание, например метод accept() у ServerSocket блокируется в ожидании подключения клиента. Здесь блокирование означает, что контроль не вернётся к вызывающему методу до тех пор, пока не выполнится задание. С другой стороны, существуют асинхронные или не блокирующиеся методы, которые завершаются до выполнения задачи."
  },
  {
    "category": "Multithreading.",
    "question": "Что такое ReadWriteLock?",
    "answer": "В целом, ReadWriteLock - это результат техники разбора lock'а для улучшения производительности параллельных приложений. Это интерфейс, который был добавлен в Java 5. Он оперирует парой связанных lock’ов, один для операций чтения, один для записи. Читающий lock может удерживаться одновременно несколькими читающими нитями, до тех пор пока не будет записывающих. Записывающий lock эксклюзивен. Если хотите, вы можете реализовать интерфейс с вашим набором правил, или вы можете использовать ReentrantReadWriteLock, который поддерживает максимум 65535 рекурсивных записывающих lock'ов и 65535 читающих lock'ов."
  },
  {
    "category": "Multithreading.",
    "question": "Что такое double checked locking Синглтона?",
    "answer": "Это старый способ создания ните-безопасного синглтона, который пытается оптимизировать производительность, блокируясь только когда экземпляр синглтона создаётся впервые."
  },
  {
    "category": "Multithreading.",
    "question": "Что такое фреймворк Fork/Join?",
    "answer": "Фреймворк Fork/Join, представленный в JDK 7, - это мощная утилита, позволяющая разработчику пользоваться преимуществами нескольких процессоров у современных серверов. Он разработан для работы, которую можно рекурсивно разбить на маленькие частицы. Цель - использовать всю доступную вычислительную мощь, для увеличения производительности вашего приложения. Одного значительное преимущество этого фреймворка в том, что он использует work-stealing алгоритм (от work - работа и steal - красть). Рабочие нити, у которых закончились свои задания, могут \"своровать\" задания у других нитей, которые всё ещё заняты."
  },
  {
    "category": "Сериализация.",
    "question": "Что такое сериализация?",
    "answer": "Сериализация - это процес чтения или записи объекта. Это процесс сохранения состояния объекта и считывание этого состояния. Для реализации сериализации нужен интерфейс - маркер Serializable. Обратная операция - перевод байтов в объект, называется десериализацией."
  },
  {
    "category": "Сериализация.",
    "question": "Как исключить поля из сериализации?",
    "answer": "Для того чтоб исключить поля из сериализуемого потока, необходимо пометить поле модификатором transient."
  },
  {
    "category": "Сериализация.",
    "question": "transient что значит?",
    "answer": "Свойства класса, помеченные модификатором transient, не сериализуются. Обычно в таких полях хранится промежуточное состояние объекта, которое, к примеру, проще вычислить, чем сериализовать, а затем десериализавать. Другой пример такого поля - ссылка на экземпляр объекта, который не требует сериализации или не может быть сериализован."
  },
  {
    "category": "Сериализация.",
    "question": "Как изменить стандартное поведение сериализации/десериализации?",
    "answer": "В большинстве случаев мы не определяем поведение вручную, а полагаемся на стандартную реализацию, и очень не удобно постоянно переопределять какие-то методы сериализации + постоянно следить за добавлением новых полей, добавлять их в методы. Ну и специально для этих целей есть Externalizable. Тем не менее, мы знаем, что можно изменить стандартное поведение сериализации предопределив и поместив в свои файлы классов два метода: Обратите внимание, что оба метода объявлены как private, поскольку это гарантирует что методы не будут переопределены или перезагружены. Весь фокус в том, что виртуальная машина при вызове соответствующего метода автоматически проверяет, не были ли они объявлены в классе объекта. Виртуальная машина в любое время может вызвать private методы вашего класса, но другие объекты этого сделать не смогут. Таким образом обеспечивается целостность класса и нормальная работа протокол сериализации."
  },
  {
    "category": "Сериализация.",
    "question": "Вы создали класс, чей суперкласс сериализуемый, но при этом вы не хотите чтобы ваш класс был сериализуемым, как остановить сериализацию?",
    "answer": "Вы не можете \"разреализовать\" интерфейс, поэтому если суперкласс реализует Serializable, то и созданный вами новый класс также будет реализовать его. Чтобы остановить автоматическую сериализацию вы можете применить private методы для создания исключительной ситуации NotSerializableException. Вот как это можно сделать: Любая попытка записать или прочитать этот объект теперь приведет к возникновению исключительной ситуации. Запомните, если методы объявлены как private, никто не сможет модифицировать ваш код не изменяя исходный код класса. Java не позволяет переопределять такие методы."
  },
  {
    "category": "Сериализация.",
    "question": "Как создать собственный протокол сериализации?",
    "answer": "Вместо реализации интерфейса Serializable, вы можете реализовать интерфейс Externalizable, который содержит два метода: Для создания собственного протокола нужно просто переопределить эти два метода. В отличие от двух других вариантов сериализации, здесь ничего не делается автоматически. Протокол полностью в ваших руках. Хотя это и наиболее сложный способ, при этом он наиболее контролируемый."
  },
  {
    "category": "Сериализация.",
    "question": "Какая роль поля serialVersionUID в сериализации?",
    "answer": "Поле private static final long serialVersionUID содержит уникальный идентификатор версии сериализованного класса. Оно вычисляется по содержимому класса - полям, их порядку объявления, методам, их порядку объявления. Соответственно, при любом изменении в классе это поле поменяет свое значение. Это поле записывается в поток при сериализации класса. Кстати, это, пожалуй, единственный известный случай, когда static-поле сериализуется."
  },
  {
    "category": "Сериализация.",
    "question": "В чем проблема сериализации Singleton-ов?",
    "answer": "Проблема в том что после десериализации мы получим другой объект. Таким образом, сериализация дает возможность создать Singleton еще раз, что не совсем не нужно. Конечно можно запретить сериализовать Singleton-ы, но это, фактически, уход от проблемы, а не ее решение. Решение же заключается в следующем. В классе определяется метод со следующей сигнатурой Модификатор доступа может быть private, protected и по умолчанию (default). Можно, наверное, сделать его и public, но смысла я в этом не вижу. Назначение этого метода - возвращать замещающий объект вместо объекта, на котором он вызван."
  },
  {
    "category": "Design patterns.",
    "question": "Что такое SOLID?",
    "answer": "SOLID, (single responsibility, open-closed, Liskov substitution, interface segregation и dependency inversion) -  акроним для первых пяти принципов, которые означали пять основных принципов объектно-ориентированного программирования и проектирования. Это часть общей стратегии гибкой и адаптивной разработки.\n\nSingle responsibility principle - принцип единственной обязанности (на каждый класс должна быть возложена одна-единственная обязанность). Если один класс java реализует 2 набора функций, их сцепление создает ситуацию, при которой изменение одного нарушит имеющееся сочетание.\n\nOpen/closed principle - принцип объектно-ориентированного программирования, устанавливающий следующее положение: \"программные сущности (классы, модули, функции и т. п.) должны быть открыты для расширения, но закрыты для изменения\"  это означает, что такие сущности могут позволять менять свое поведение без изменения их исходного кода.\n\nLiskov substitution principle - принцип подстановки Барбары Лисков (функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом. Подклассы не могут замещать поведения базовых классов. Подтипы должны дополнять базовые типы).\n\nInterface segregation principle - принцип разделения интерфейса (много специализированных интерфейсов лучше, чем один универсальный). Иными словами большие, объемные интерфейсы надо разбивать на мелкие таким образом, чтобы клиенты маленьких интерфейсов знали только о тех методах которые необходимы им в работе. И чтобы при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют.\n\nDependency inversion principle -  принцип инверсии зависимостей (зависимости внутри системы строятся на основе абстракций. Модули верхнего уровня не зависят от модулей нижнего уровня. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций)."
  },
  {
    "category": "Design patterns.",
    "question": "Что такое шаблоны проектирования?",
    "answer": "Шаблоны проектирования GoF - это многократно используемые решения широко распространенных проблем, возникающих при разработке программного обеспечения."
  },
  {
    "category": "Design patterns.",
    "question": "Из каких элементов состоит шаблон?",
    "answer": "В общем случае шаблон состоит из четырех основных элементов: \n\nимя. Точное имя предоставляет возможность сразу понять проблему и определить решение. Уровень абстракции при проектировании повышается\n\nзадача. Область применения в рамках решения конкретной проблемы \n\nрешение. Абстрактное описание элементов дизайна задачи проектирования и способа ее решения с помощью обобщенного набора классов\n\nрезультаты."
  },
  {
    "category": "Design patterns.",
    "question": "Какие есть типы шаблонов?",
    "answer": "Выделяются порождающие шаблоны, структурные шаблоны и шаблоны поведения, а также антишаблоны."
  },
  {
    "category": "Design patterns.",
    "question": "Назовите порождающие шаблоны, и кратко опишите их.",
    "answer": "Порождающие шаблоны предназначаются для организации процесса создания объектов и все до единого соответствуют шаблону Creator из GRASP. К порождающим шаблонам относятся:\n\n Abstract Factory (Абстрактная Фабрика) - предоставляет интерфейс для создания связанных между собой объектов семейств классов без указания их конкретных реализаций (families of product objects)\n\n Factory Method (Фабричный метод) - определяет интерфейс для создания объектов из иерархического семейства классов на основе передаваемых данных (subclass of object that is instantiated)\n\nBuilder (Строитель) - создает объект конкретного класса различными способами (how a composite object gets created) \n\nSingleton (Одиночка) - гарантирует существование только одного или конечного числа экземпляров класса (the sole instance of a class)\n\nPrototype (Прототип) - применяется при создании сложных объектов. На основе прототипа объекты сохраняются и воссоздаются, например, путем копирования (class of object that is instantiated)."
  },
  {
    "category": "Design patterns.",
    "question": "Назовите шаблоны поведения, и кратко опишите их.",
    "answer": "Шаблоны поведения GoF характеризуют способы взаимодействия классов или объектов между собой. К шаблонам поведения относятся:\n\n Chain of Responsibility (Цепочка Обязанностей) - организует независимую от объекта-отправителя цепочку не знающих возможностей друг друга объектов-получателей, которые передают запрос друг другу (object that can fulfill a request) \n\n Command (Команда) - используется для определения по некоторому признаку объекта конкретного класса, которому будет передан запрос для обработки (when and how a request is fulfilled)\n\nIterator (Итератор) - позволяет последовательно обойти все элементы коллекции или другого составного объекта, не зная деталей внутреннего представления данных (how an aggregate’s elements are accessed, traversed) \n\n Mediator (Посредник) - позволяет снизить число связей между классами при большом их количестве, выделяя один класс, знающий все о методах других классов (how and which objects interact with each other) \n\nMemento (Хранитель) - сохраняет текущее состояние объекта для дальнейшего восстановления (what private information is stored outside an object, and when)\n\n Observer (Наблюдатель) - позволяет при зависимости между объектами типа «один ко многим» отслеживать изменения объекта (number of objects that depend on another object  how the dependent objects stay up to date) \n\nState (Состояние) - позволяет объекту изменять свое поведение за счет изменения внутреннего объекта состояния (states of an object)\n\n Strategy (Стратегия) - задает набор алгоритмов с возможностью выбора одного из классов для выполнения конкретной задачи во время создания объекта (an algorithm)\n\nTemplate Method (Шаблонный Метод) - создает родительский класс, использующий несколько методов, реализация которых возложена на производные классы (steps of an algorithm) \n\nVisitor (Посетитель) - представляет операцию в одном или нескольких связанных классах некоторой структуры, которую вызывает специфичный для каждого такого класса метод в другом классе (operations that can be applied to object(s) without changing their class(es))\n\n Interpreter (Интерпретатор) - для определенного способа представления информации определяет правила (grammar and interpretation of a language)."
  },
  {
    "category": "Design patterns.",
    "question": "Назовите структурные шаблоны, и кратко опишите их.",
    "answer": "Структурные шаблоны GoF отвечают за композицию объектов и классов, и не только за объединение частей приложения, но и за их разделение. К структурным шаблонам относятся:\n\n  Adapter (Адаптер) - применяется при необходимости использовать классы вместе с несвязанными интерфейсами. Поведение адаптируемого класса при этом изменяется на необходимое (interface to an object)\n\nBridge (Мост) - разделяет представление класса и его реализацию, позволяя независимо изменять то и другое (implementation of an object)\n\nComposite (Компоновщик) - группирует объекты в иерархические древовидные структуры и позволяет работать с единичным объектом так же, как с группой объектов (structure and composition of an object)\n\nDecorator (Декоратор) - представляет способ изменения поведения объекта без создания подклассов. Позволяет использовать поведение одного объекта в другом (responsibilities of an object without subclassing)\n\n Facade (Фасад) - создает класс с общим интерфейсом высокого уровня к некоторому числу интерфейсов в подсистеме (interface to a subsystem)\n\n Flyweight (Легковес) - разделяет свойства класса для оптимальной поддержки большого числа мелких объектов (storage costs of objects)\n\n Proxy (Заместитель) - подменяет сложный объект более простым и осуществляет контроль доступа к нему (how an object is accessed... its location)."
  },
  {
    "category": "Design patterns.",
    "question": "Абстрактная фабрика в Android",
    "answer": "Абстрактная фабрика (Abstract Factory) - это паттерн проектирования, который позволяет создавать семейства взаимосвязанных объектов без указания их конкретных классов. Он позволяет создавать объекты, которые взаимодействуют друг с другом и относятся к определенной группе или семейству классов.\n\nВ контексте разработки Android-приложений, абстрактная фабрика может быть использована для создания различных компонентов приложения, таких как взаимодействие с базой данных, сетевые запросы или создание визуальных элементов интерфейса.\n\nВот пример применения абстрактной фабрики в Android:\njava\n\n// Абстрактная фабрика для создания различных источников данных\npublic interface DataSourceFactory {\n    DataSource createDataSource();\n    DataRepository createRepository();\n}\n\n// Реализация фабрики для локального источника данных\npublic class LocalDataSourceFactory implements DataSourceFactory {\n    @Override\n    public DataSource createDataSource() {\n        return new LocalDataSource();\n    }\n\n    @Override\n    public DataRepository createRepository() {\n        return new LocalDataRepository();\n    }\n}\n\n// Реализация фабрики для удаленного источника данных\npublic class RemoteDataSourceFactory implements DataSourceFactory {\n    @Override\n    public DataSource createDataSource() {\n        return new RemoteDataSource();\n    }\n\n    @Override\n    public DataRepository createRepository() {\n        return new RemoteDataRepository();\n    }\n}\n\n// Абстрактный класс источника данных\npublic abstract class DataSource {\n    // Методы для работы с данными\n    public abstract void fetchData();\n    public abstract void saveData();\n}\n\n// Конкретная реализация локального источника данных\npublic class LocalDataSource extends DataSource {\n    @Override\n    public void fetchData() {\n        // Логика получения данных из локального источника\n    }\n\n    @Override\n    public void saveData() {\n        // Логика сохранения данных в локальном источнике\n    }\n}\n\n// Конкретная реализация удаленного источника данных\npublic class RemoteDataSource extends DataSource {\n    @Override\n    public void fetchData() {\n        // Логика получения данных из удаленного источника\n    }\n\n    @Override\n    public void saveData() {\n        // Логика сохранения данных в удаленном источнике\n    }\n}\n\n// Абстрактный класс репозитория данных\npublic abstract class DataRepository {\n    // Методы для работы с данными\n    public abstract void loadData();\n    public abstract void storeData();\n}\n\n// Конкретная реализация локального репозитория данных\npublic class LocalDataRepository extends DataRepository {\n    @Override\n    public void loadData() {\n        // Логика загрузки данных из локального репозитория\n    }\n\n    @Override\n    public void storeData() {\n        // Логика сохранения данных в локальном репозитории\n    }\n}\n\n// Конкретная реализация удаленного репозитория данных\npublic class RemoteDataRepository extends DataRepository {\n    @Override\n    public void loadData() {\n        // Логика загрузки данных из удаленного репозитория\n    }\n\n    @Override\n    public void storeData() {\n        // Логика сохранения данных в удаленном репозитории\n    }\n}\n\n// Использование абстрактной фабрики\npublic class App {\n    private DataSource dataSource;\n    private DataRepository dataRepository;\n\n    public App(DataSourceFactory factory) {\n        dataSource = factory.createDataSource();\n        dataRepository = factory.createRepository();\n    }\n\n    public void fetchData() {\n        dataSource.fetchData();\n        dataRepository.loadData();\n    }\n\n    public void saveData() {\n        dataSource.saveData();\n        dataRepository.storeData();\n    }\n}\n\n// Использование приложения с локальными источниками данных\nDataSourceFactory localFactory = new LocalDataSourceFactory();\nApp appWithLocalData = new App(localFactory);\nappWithLocalData.fetchData();\nappWithLocalData.saveData();\n\n// Использование приложения с удаленными источниками данных\nDataSourceFactory remoteFactory = new RemoteDataSourceFactory();\nApp appWithRemoteData = new App(remoteFactory);\nappWithRemoteData.fetchData();\nappWithRemoteData.saveData();\n\nВ данном примере абстрактная фабрика (DataSourceFactory) определяет методы для создания источника данных (DataSource) и репозитория данных (DataRepository). Реализации фабрики (LocalDataSourceFactory и RemoteDataSourceFactory) создают соответствующие объекты источника данных и репозитория данных. Классы источников данных и репозиториев данных предоставляют конкретную реализацию методов для работы с данными.\n\nПриложение (App) получает инстанции источника данных и репозитория данных от фабрики и использует их для выполнения операций загрузки (fetchData) и сохранения (saveData) данных. Выбор конкретной реализации источника данных и репозитория данных определяется передачей соответствующей фабрики в конструктор приложения.\n\nТаким образом, абстрактная фабрика позволяет создавать и взаимодействовать с семействами взаимосвязанных объектов, а не привязываться к конкретным классам, что делает код более гибким и легко расширяемым."
  },
  {
    "category": "Design patterns.",
    "question": "Паттерн репозиторий",
    "answer": "Паттерн \"Репозиторий\" (Repository) является популярным паттерном проектирования, который используется для организации доступа к данным в приложении. Он предоставляет абстрактный интерфейс для взаимодействия с данными, скрывая детали реализации хранения и извлечения данных.\n\nОсновная идея паттерна репозиторий состоит в том, чтобы создать слой абстракции между бизнес-логикой приложения и источником данных (например, базой данных, веб-сервисом и т.д.). Репозиторий предоставляет методы для добавления, удаления, обновления и извлечения данных, а также скрывает сложность работы с конкретным источником данных.\n\nПример реализации паттерна репозиторий в Android:\njava\n\n// Интерфейс репозитория\npublic interface UserRepository {\n    User getUserById(int userId);\n    void addUser(User user);\n    void updateUser(User user);\n    void deleteUser(User user);\n}\n\n// Реализация репозитория с использованием базы данных\npublic class DbUserRepository implements UserRepository {\n    private DatabaseHelper dbHelper;\n\n    public DbUserRepository(DatabaseHelper dbHelper) {\n        this.dbHelper = dbHelper;\n    }\n\n    @Override\n    public User getUserById(int userId) {\n        // Логика извлечения пользователя из базы данных по идентификатору\n        return dbHelper.getUserById(userId);\n    }\n\n    @Override\n    public void addUser(User user) {\n        // Логика добавления пользователя в базу данных\n        dbHelper.addUser(user);\n    }\n\n    @Override\n    public void updateUser(User user) {\n        // Логика обновления пользователя в базе данных\n        dbHelper.updateUser(user);\n    }\n\n    @Override\n    public void deleteUser(User user) {\n        // Логика удаления пользователя из базы данных\n        dbHelper.deleteUser(user);\n    }\n}\n\n// Использование репозитория\npublic class UserService {\n    private UserRepository userRepository;\n\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n\n    public User getUserById(int userId) {\n        return userRepository.getUserById(userId);\n    }\n\n    public void createUser(User user) {\n        userRepository.addUser(user);\n    }\n\n    public void updateUser(User user) {\n        userRepository.updateUser(user);\n    }\n\n    public void deleteUser(User user) {\n        userRepository.deleteUser(user);\n    }\n}\n\nВ этом примере UserRepository представляет интерфейс для работы с данными пользователей. DbUserRepository реализует этот интерфейс, используя базу данных (DatabaseHelper) для сохранения, обновления, извлечения и удаления данных пользователей.\n\nUserService представляет службу, которая использует репозиторий для выполнения операций с пользователями. Она принимает экземпляр UserRepository через конструктор и использует его методы для доступа к данным.\n\nПреимущества использования паттерна репозиторий включают:\n\n    Разделение ответственности: Репозиторий отделяет бизнес-логику приложения от деталей работы с данными.\n    Улучшенная тестируемость: Можно легко заменить реализацию репозитория фиктивной реализацией для тестирования бизнес-логики без фактического доступа к источнику данных.\n    Гибкость: Изменение источника данных (например, замена базы данных на веб-сервис) может быть выполнено с минимальными изменениями в бизнес-логике.\n\nПаттерн репозиторий полезен в Android-приложениях для организации доступа к данным, обеспечивая модульность, гибкость и улучшенную тестируемость вашего кода."
  },
  {
    "category": "Design patterns.",
    "question": "Фабричный метод в Android",
    "answer": "Фабричный метод (Factory Method) - это паттерн проектирования, который предоставляет интерфейс для создания объектов, но позволяет подклассам выбирать класс создаваемых экземпляров. То есть, он делегирует создание объектов подклассам, что позволяет изменять тип создаваемых объектов в зависимости от конкретных потребностей.\n\nВ контексте разработки Android-приложений, фабричный метод может быть использован для создания различных объектов, таких как фрагменты, представления (views), адаптеры и другие компоненты, где требуется гибкость в выборе класса создаваемого объекта.\n\nВот пример применения фабричного метода в Android:\njava\n\n// Абстрактный класс для создания объектов\npublic abstract class ObjectFactory {\n    // Метод, возвращающий созданный объект\n    public abstract Object createObject();\n}\n\n// Конкретная реализация фабричного метода для создания фрагментов\npublic class FragmentFactory extends ObjectFactory {\n    @Override\n    public Fragment createObject() {\n        return new MyFragment();\n    }\n}\n\n// Конкретная реализация фабричного метода для создания представлений\npublic class ViewFactory extends ObjectFactory {\n    @Override\n    public View createObject() {\n        return new MyView();\n    }\n}\n\n// Конкретная реализация фабричного метода для создания адаптеров\npublic class AdapterFactory extends ObjectFactory {\n    @Override\n    public Adapter createObject() {\n        return new MyAdapter();\n    }\n}\n\n// Использование фабричного метода\nObjectFactory factory = new FragmentFactory();\nObject object = factory.createObject();\n// Используем созданный объект\n\nВ данном примере абстрактный класс ObjectFactory определяет абстрактный метод createObject(), который должен быть реализован в конкретных подклассах. Каждый подкласс фабричного метода (FragmentFactory, ViewFactory, AdapterFactory) реализует метод createObject() и возвращает соответствующий созданный объект (Fragment, View, Adapter).\n\nПри использовании фабричного метода, вы создаете экземпляр нужного подкласса фабричного метода (ObjectFactory) и вызываете метод createObject(), чтобы получить созданный объект. Таким образом, вы делегируете создание объекта подклассам и можете легко заменять тип создаваемого объекта, просто изменяя экземпляр фабричного метода.\n\nПрименение фабричного метода в Android позволяет сделать код более гибким и расширяемым, поскольку вы можете добавлять новые подклассы фабричного метода для создания разных типов объектов без изменения кода, который использует фабрику. Это также упрощает тестирование и разделение ответственности между классами."
  },
  {
    "category": "Design patterns.",
    "question": "Делигирование",
    "answer": "Делегирование (delegation)- это механизм, который позволяет классу передать выполнение определенных операций другому объекту (делегату). Вместо того чтобы самостоятельно реализовывать определенное поведение, класс делегирует его делегату, который занимается выполнением этого поведения.\nВ Kotlin делегирование может быть реализовано с использованием ключевого слова by. Класс, который делегирует операции, объявляет свойство с использованием ключевого слова by и указывает на делегата. Делегат должен реализовывать интерфейс или наследовать абстрактный класс, определенный делегирующим классом.:\n\ninterface Printer {fun print(message: String)}\n\nclass ConsolePrinter : Printer {override fun print(message: String) {println(message)}}\n\nclass PrintLogger(private val printer: Printer) : Printer by printer {\nfun log(message: String) {print(\\\"[LOG] $message\\\")}\n}\nfun main() {\nval consolePrinter = ConsolePrinter()\nval logger = PrintLogger(consolePrinter)\nlogger.print(\\\"Hello, world!\\\") \nlogger.log(\\\"Some log message\\\")\n}\n\nВ этом примере есть интерфейс Printer, который определяет метод print(). Класс ConsolePrinter реализует этот интерфейс и выполняет печать в консоль. Класс PrintLogger делегирует операцию печати своему делегату (в данном случае Printer), используя ключевое слово by. Класс PrintLogger также добавляет свой собственный метод log(), который делегируется делегату.\nВ функции main() создается экземпляр ConsolePrinter, а затем экземпляр PrintLogger, который использует ConsolePrinter в качестве делегата. При вызове методов print() и log() на объекте PrintLogger, соответствующие операции делегируются делегату ConsolePrinter.\nДелегирование также может быть использовано для делегирования реализации методов интерфейсов, делегирования доступа к свойствам и т. д. \n\nПодобным образом один объект может делегировать выполнение различных функций разным объектам. Например:\n\nfun main() {\n    val telegram = InstantMessenger(\"Telegram\")\n    val photoCamera = PhotoCamera()\n    val pixel = SmartPhone(\"Pixel 5\", telegram, photoCamera)\n    pixel.send(\"Hello Kotlin\")\n    pixel.takePhoto()\n}\n \ninterface Messenger{\n    fun send(message: String)\n}\nclass InstantMessenger(val programName: String) : Messenger{\n    override fun send(message: String) = println(\"Send message: `$message`\")\n}\ninterface PhotoDevice{\n    fun takePhoto()\n}\nclass PhotoCamera: PhotoDevice{\n    override fun takePhoto() = println(\"Take a photo\")\n}\nclass SmartPhone(val name: String, m: Messenger, p: PhotoDevice)\n    : Messenger by  m, PhotoDevice by p\n\nЗдесь класс SmartPhone также реализует интерфейс PhotoDevice, который предоставляет функцию takePhoto() для съемки фото. Но выполнение этой функции он делегирует параметру p, который представляет интерфейс PhotoDevice и в роли которого выступает объект PhotoCamera."
  },
  {
    "category": "Design patterns.",
    "question": "Какие антишаблоны вы знаете?",
    "answer": "Некоторые антишаблоны: \n\nBig ball of mud (Большой Ком Грязи) - термин для системы или просто программы, которая не имеет хоть немного различимой архитектуры. Как правило, включает в себя более одного антишаблона. Этим страдают системы, разработанные людьми без подготовки в области архитектуры ПО. \n\nYo-Yo problem (Проблема Йо-Йо) - возникает, когда необходимо разобраться в программе, иерархия наследования и вложенность вызовов методов которой очень длинны и сложны. Программисту вследствие этого необходимо лавировать между множеством различных классов и методов, чтобы контролировать поведение программы. Термин происходит от названия игрушки йо-йо.\n\n Magic Button - возникает, когда код обработки формы сконцентрирован в одном месте и, естественно, никак не структурирован.\n\nMagic Number - наличие в коде многократно повторяющихся одинаковых чисел или чисел, объяснение происхождения которых отсутствует.\n\nGas Factory (Газовый Завод) - необязательный сложный дизайн для простой задачи. \n\n Analiys paralisys. В разработке ПО (Паралич анализа) - проявляет себя через чрезвычайно длинные фазы планирования проекта, сбора необходимых для этого артефактов, программного моделирования и дизайна, которые не имеют особого смысла для достижения итоговой цели. \n\n Interface Bloat (Распухший Интерфейс) - термин, используемый для описания интерфейсов, которые пытаются вместить в себя все возможные операции над данными.\n\nAccidental complexity (Случайная сложность) - проблема в программировании, которой легко можно было избежать. Возникает вследствие неправильного понимания проблемы или неэффективного планирования."
  },
  {
    "category": "Design patterns.",
    "question": "Что такое OOAD?",
    "answer": "OOAD, Object Oriented Analysis and Design (Объектно-ориентированный анализ и проектирование) - дисциплина, описывающая способы (варианты) задания (определения) объектов и их взаимодействие для решения проблемы, которая определена и описана в ходе объектно-ориентированного анализа. Основная идея объектно-ориентированного анализа и проектирования (object-oriented analysis and design) состоит в рассмотрении предметной области и логического решения задачи с точки зрения объектов (понятий и сущностей). В процессе объектно-ориентированного анализа основное внимание уделяется определению и описанию объектов (или понятий) в терминах предметной области. В процессе объектно-ориентированного проектирования определяются логические программные объекты, которые будут реализованы средствами объектно-ориентированного языка программирования. Эти программные объекты включают в себя атрибуты и методы. И, наконец, в процессе конструирования (construction) или объектно-ориентированного программирования (object-oriented programming) обеспечивается реализация разработанных компонентов и классов."
  },
  {
    "category": "Design patterns.",
    "question": "Что такое OOD?",
    "answer": "OOD, Object Oriented Design (Объектно-ориентированное проектирование) - это методология проектирования, соединяющая в себе процесс объектной декомпозиции и приемы представления логической и физической, а также статической и динамической моделей проектируемой системы."
  },
  {
    "category": "Design patterns.",
    "question": "Что такое OOA?",
    "answer": "OOA, Object  Oriented Analysis (Объектно-ориентированный анализ) - это методология, при которой требования к системе воспринимаются с точки зрения классов и объектов, выявленных в предметной области, это методология проектирования, соединяющая в себе процесс объектной декомпозиции и приемы представления логической и физической, а также статической и динамической моделей проектируемой системы."
  },
  {
    "category": "Design patterns.",
    "question": "Что такое DRY principles?",
    "answer": "DRY, Don’t repeat yourself (не повторяй себя) - этот принцип настолько важен, что не требует повторения! Это принцип разработки программного обеспечения, нацеленный на снижение повторения информации различного рода, особенно в системах со множеством слоёв абстрагирования, простими словами НЕ пишите повторяющегося кода, используйте принцип абстракции, обобщая простые вещи в одном месте."
  },
  {
    "category": "Design patterns.",
    "question": "Что такое KISS?",
    "answer": "KISS, Keep it short and simple или Keep it simple, stupid (делайте вещи проще) -  это принцип проектирования и программирования, запрещающий использование более сложных средств, чем необходимо. Принцип декларирует простоту системы в качестве основной цели и/или ценности."
  },
  {
    "category": "Design patterns.",
    "question": "Что такое YAGNI?",
    "answer": "YAGNI, You ain't gonna need it (Вам это не понадобится) - процесс и принцип проектирования ПО, при котором в качестве основной цели и/или ценности декларируется отказ от избыточной функциональности. Суть в том, чтобы реализовать только поставленные задачи и отказаться от избыточного функционала."
  },
  {
    "category": "Design patterns.",
    "question": "Что такое Yoda conditions?",
    "answer": "Yoda conditions (Условия Йоды в жаргоне программистов) - \"безопасный\" стиль записи выражений сравнения при программировании на языках с Си-синтаксисом, заключающийся в написании константного члена выражения (константы или вызова функции) слева от оператора сравнения (то есть 5 == a вместо привычного а == 5). Такой стиль призван предотвратить свойственную данным языкам ошибку - использование оператора присваивания \"=\" вместо сравнения \"==\". Ошибочное использование присваивания превращает нотацию Йоды в попытку изменить константу, вызывая ошибку на этапе компиляции, что исключает возможность появления в готовой программе ошибок данного вида, а также облегчает их поиск и исправление в новом коде."
  },
  {
    "category": "Design patterns.",
    "question": "Что такое CRC cards?",
    "answer": "CRC cards, Class-responsibility-collaboration card (Класс-Ответственность-Кооперация) - метод мозгового штурма, предназначенный для проектирования объектно-ориентированного программного обеспечения. Как правило, CRC-карты используются в тех случаях, когда сначала в процессе проектирования ПО определяются классы и способы их взаимодействий. CRC-карты акцентируют внимание дизайнера на сущности класса и скрывают от него детали, рассмотрение которых на данном этапе будет контрпродуктивным. CRC-карты также заставляют дизайнера воздержаться от назначения классу слишком многих обязанностей."
  },
  {
    "category": "Design patterns.",
    "question": "Что такое GRASP?",
    "answer": "GRASP, General Responsibility Assignment Software Patterns (общие шаблоны распределения обязанностей) -  шаблоны проектирования, используемые для решения общих задач по назначению обязанностей классам и объектам. Известно девять GRAPS шаблонов."
  },
  {
    "category": "Design patterns.",
    "question": "Кратко опишите шаблоны GRAPS",
    "answer": "GRASP выделяет следующие 9 принципов-шаблонов:      Information Expert (Информационные эксперт) - информационный эксперт описывает основополагающие принципы назначения обязанностей классам и объектам. Согласно описанию, информационным экспертом (объектом наделенным некоторыми обязанностями) является объект, обладающий максимумом информацией, необходимой для выполнения назначенных обязанностей.     Creator (Создатель) - суть ответственности такого объекта в том, что он создает другие объекты. Сразу напрашивается аналогия с фабриками. Так оно и есть. Фабрики тоже имеют именно ответственность - Создатель.     Controller (Контроллер) - отвечает за обработку входных системных событий, делегируя обязанности по их обработке компетентным классам. В общем случае, контроллер реализует один или несколько вариантов использования. Использование контроллеров позволяет отделить логику от представления, тем самым повышая возможность повторного использования кода.     Low Coupling (Слабая связанность) - если объекты в приложении сильно связаны, то любой их изменение приводит к изменениям во всех связанных объектах. А это неудобно и порождает баги. Вот по-этому везде пишут, что необходимо, чтобы код был слабо связан и зависел только от абстракций.     High Cohesion (Высокая сцепленность) - этот принцип тесно соотносится с слабой связанностью, и они идут в паре, когда одно всегда приводит к другому, это как мера того, что мы не нарушаем single resposibility principle. Вернее сказать, высокая сцепленность получается в результате соблюдения такого принципа из SOLID, как single resposibility principle (SRP).     Pure Fabrication (Чистая выдумка или чистое синтезирование) -  это класс, не отражающий никакого реального объекта предметной области, но специально придуманный для усиления связности, ослабления связанности или увеличения степени повторного использования. Pure Fabrication отражает концепцию сервисов в модели Программирование от предметной области.     Indirection (Посредник) - шаблон перенаправление реализует низкую связность между классами, путем назначения обязанностей по их взаимодействию дополнительному объекту - посреднику.     Protected Variations (Сокрытие реализации или защищенные изменения) - защищает элементы от изменения других элементов (объектов или подсистем) с помощью вынесения взаимодействия в фиксированный интерфейс. Всё взвимодействие между элементами должно происходить через него. Поведение может варьироваться лишь с помощью создания другой реализации интерфейса.     Polymorphism (Полиморфизм) - позволяет обрабатывать альтернативные варианты поведения на основе типа и заменять подключаемые компоненты системы. Обязанности распределяются для различных вариантов поведения с помощью полиморфных операций для этого класса. Все альтернативные реализации приводятся к общему интерфейсу."
  },
  {
    "category": "JDBC.",
    "question": "Что такое JDBC?",
    "answer": "API JDBC (Java DataBase Connectivity) - стандартный прикладной интерфейс языка Java для организации взаимодействия между приложением и СУБД. Взаимодействие осуществляется с помощью драйверов JDBC, обеспечиваю щих реализацию общих интерфейсов для конкретных СУБД и конкретних протоколов. В JDBC определяются четыре типа драйверов."
  },
  {
    "category": "JDBC.",
    "question": "Этапы работы с базой данных с использованием JDBC?",
    "answer": "Этапы работы с базой данных с использованием JDBC:      Подключение библиотеки с классом-драйвером базы данных.     Установка соединения с БД.     Создание объекта для передачи запросов.     Выполнение запроса.     Обработка результатов выполнения запроса.     Закрытие соединения, statement"
  },
  {
    "category": "JDBC.",
    "question": "Как создать Connection?",
    "answer": "Для установки соединения с БД вызывается статический метод getConnection() класса java.sql.DriverManager. В качестве параметров методу передаються URL базы данных, логин пользователя БД и пароль доступа. Загрузка класса драйвера базы данных при отсутствии ссылки на экземпляр этого класса в JDBC 4.1 происходит автоматически при установке соединения екземпляром DriverManager. Метод возвращает объект Connection. URL базы данных, состоящий из типа и адреса физического расположения БД, может создаваться в виде отдельной строки или извлекаться из файла ресурсов. Соответственно: В результате будет возвращен объект Connection и будет одно установленное соединение с БД с именем testphones. Класс DriverManager предоставляет средства для управления набором драйверов баз данных."
  },
  {
    "category": "JDBC.",
    "question": "Чем отличается Statement от PreparedStatement?",
    "answer": "Объект Statement используется для выполнения SQL-запросов к БД. Существует три типа объектов Statement. Все три служат как бы конейнерами для выполнения SQL-выражений через данное соединение: Statement, PreparedStatement, наследующий от Statement, и CallableStatement, наследующий от PreparedStatement. Они специализируются на различных типах запросов: Statement используется для выполнения простых SQL-запросов без параметров  PreparedStatement используется для выполнения прекомпилированных SQL-запросов с или без входных (IN) параметров  CallableStatement используется для вызовов хранимых процедур. Интерфейс Statement предоставляет базовые методы для выполнения запросов и извлечения результатов. Интерфейс PreparedStatement добавляет методы управления входными (IN) параметрами  CallableStatement добавляет методы для манипуляции выходними (OUT) параметрами. Интерфейс PreparedStatement наследует от Statement и отличается от последнего следующим: Экземпляры PreparedStatement \"помнят\" скомпилированные SQL-выражения. Именно поэтому они называются \"prepared\" (\"подготовленные\"). SQL-выражения в PreparedStatement могут иметь один или более входной (IN) параметр. Входной параметр - это параметр, чье значение не указывается при создании SQL-выражения. Вместо него в выражении на месте каждого входного параметра ставится знак (\"?\"). Значение каждого вопросительного знака устанавливается методами setXXX перед выполнением запроса."
  },
  {
    "category": "JDBC.",
    "question": "Как вызвать хранимую процедуру?",
    "answer": "Хранимые процедуры – это именованный набор операторов Transact-SQL хранящийся на сервере. Такую процедуру можно легко вызвать из Java-класса с помощью специального синтаксиса. При вызове такой процедуры необходимо указать ее имя и определить список параметров. Имя и список параметров посылаются по JDBC-соединению в СУБД, которая выполняет вызываемую процедуру и возвращает результат (если таковой имеется) обратно, используя это же соединение. JDBC Java-код для выполнения хранимой процедуры, использующий объект Statement без параметров."
  },
  {
    "category": "JDBC.",
    "question": "Как правильно закрыть Connection?",
    "answer": "st.close cn.close После того, как база больше не нужна, соединение закрывается. Для того, чтобы правильно пользоваться приведенными методами, программисту требуется знать типы полей БД. В распределенных системах это знание предполагается изначально. В Java 7 для объектов-ресурсов, требующих закрытия, реализована технология try with resources."
  },
  {
    "category": "JDBC.",
    "question": "Какие есть уровни изоляции транзакций?",
    "answer": "Уровни изоляции транзакций определены в виде констант интерфейса Connection (по возрастанию уровня ограничения):      TRANSACTION_NONE - информирует о том, что драйвер не поддерживает транзакции      TRANSACTION_READ_UNCOMMITTED - позволяет транзакциям видеть несохраненные изменения данных, что разрешает грязное, неповторяющееся и фантомное чтения      TRANSACTION_READ_COMMITTED - означает, что любое изменение, сделанное в транзакции, не видно вне ее, пока она не сохранена. Это предотвращает грязное чтение, но разрешает неповторяющееся и фантомное      TRANSACTION_REPEATABLE_READ - запрещает грязное и неповторяющееся чтение, но фантомное разрешено      TRANSACTION_SERIALIZABLE - определяет, что грязное, неповторяющееся и фантомное чтения запрещены."
  },
  {
    "category": "JDBC.",
    "question": "Какие есть типов чтения транзакций?",
    "answer": "Для транзакций существует несколько типов чтения:      грязное чтение (dirty reads) происходит, когда транзакциям разрешено видеть несохраненные изменения данных. Иными словами, изменения, сделанные в одной транзакции, видны вне ее до того, как она была сохранена. Если изменения не будут сохранены, то, вероятно, другие транзакции выполняли работу на основе некорректных данных      неповторяющееся чтение (nonrepeatable reads) происходит, когда транзакция А читает строку, транзакция Б изменяет эту строку, транзакция А читает ту же строку и получает обновленные данные      фантомное чтение (phantom reads) происходит, когда транзакция А считывает все строки, удовлетворяющие WHERE-условию, транзакция Б вставляет новую или удаляет одну из строк, которая удовлетворяет этому условию, транзакция А еще раз считывает все строки, удовлетворяющие WHERE-условию, уже вместе с новой строкой или недосчитавшись старой."
  },
  {
    "category": "Базы данных.",
    "question": "Что такое База Данных?",
    "answer": "Под базой данных (БД) понимается некий организованный набор информации. В качестве примера простейшей БД можно привести список товаров, каждый из которых обладает набором стандартных характеристик (наименование, единица измерения, количество, цена и т. д.)."
  },
  {
    "category": "Базы данных.",
    "question": "Модель данных в реляционных СУБД?",
    "answer": "Прежде чем сохранять какие-либо данные в СУБД, необходимо описать их модель. По типу модели данных СУБД делятся на сетевые, объектные, иерархические и реляционные. СУБД реляционного типа являются наиболее распространенными и часто используемыми. В качестве примеров можно привести Oracle и Microsoft SQL Server."
  },
  {
    "category": "Базы данных.",
    "question": "Что такое нормализация?",
    "answer": "Процесс приведения базы данных к виду, в котором она будет соответствовать правилам нормальных форм, называется нормализацией базы данных. Нормализация базы данных сводит к минимуму количество избыточной информации. Ее целью является сохранять данные только один раз, но в нужном месте. Нормализованная база данных исключает дублирование и многократное обслуживание данных, а также появление проблем с целостностью данных, возникающих при повторном вводе одинаковых данных. Первоначально доктором Эдгаром Коддом были определены только 3 нормальные формы. Дальнейшая разработка реляционной теории привела к появлению еще нескольких форм и на данный момент их насчитывается 8. На практике соответствие базы данных правилам 3-ей нормальной формы вполне достаточно.      Первая нормальная форма гласит: информация в каждом поле таблицы является неделимой и не может быть разбита на подгруппы.     Вторая нормальная форма гласит: таблица соответствует 1НФ и в таблице нет неключевых атрибутов, зависящих от части сложного (состоящего из нескольких столбцов) первичного ключа.     Третья нормальная форма гласит: таблица соответствует первым двум НФ, и все неключевые атрибуты зависят только от первичного ключа и не зависят друг от друга."
  },
  {
    "category": "Базы данных.",
    "question": "Какие есть типы связей в базе данных. Приведите пример.",
    "answer": "Связь работает путем сопоставления данных в ключевых столбцах  обычно это столбцы с одним и тем же именем в обеих таблицах. В большинстве случаев связь сопоставляет первичный ключ одной таблицы, являющийся уникальным идентификатором каждой строки этой таблицы, с записями внешнего ключа другой таблицы. Существует три типа связей между таблицами. Тип создаваемой связи зависит от того, как определены связанные столбцы. Один-к-одному - в связи \"одному к одному\" строке таблицы А может сопоставляться только одна строка таблицы Б, и наоборот. Связь \"один к одному\" создается, если для обоих связанных ключей определены ограничения первичного ключа или уникальности. Этот тип связи обычно не используется, так как большую часть связанных таким образом данных можно хранить в одной таблице. Связь \"один к одному\" можно использовать для:      Разделения таблицы со многими столбцами.     Изоляции части таблицы из соображений безопасности.     Хранения кратковременных данных, которые можно легко удалить вместе со всей таблицей.     Хранения данных, которые относятся только к части основной таблицы.  Столбец, являющийся первичным ключом в связи \"один к одному\", отмечается символом ключа. Столбец, являющийся внешним ключом, также отмечается символом ключа. Один-ко-многим - самая распространенная. В этом типе связей у строки таблицы А может быть несколько совпадающих строк таблицы Б, но каждой строке таблицы Б может соответствовать только одна строка из А. Например, между таблицами publishers и titles установлена связь \"один ко многим\": каждый издатель публикует много книг, но каждая книга публикуется только у одного издателя. Используйте связь \"один ко многим\", если только у одного из связанных столбцов есть ограничение первичного ключа или уникальности. Столбец, являющийся первичным ключом в связи \"один ко многим\", отмечается символом ключа. Столбец, являющийся внешним ключом в связи \"один ко многим\", отмечается символом бесконечности. Многие-ко-многим - строке таблицы А может сопоставляться несколько строк таблицы Б, и наоборот. Такие связи создаются определением третьей таблицы, которая называется таблицей соединения, чей первичный ключ состоит из внешних ключей А и Б. Например, между таблицами authors и titles связь \"многие ко многим\" определена через связи \"один ко многим\" каждой из этих таблиц с таблицей titleauthors. Первичный ключ таблицы titleauthors представляет собой сочетание столбца au_id (первичный ключ таблицы authors) и столбца title_id (первичный ключ таблицы titles)."
  },
  {
    "category": "Базы данных.",
    "question": "Что такое primary key (первичный ключ)?",
    "answer": "Первичный ключ (или главный ключ, primary key, PK). Представляет собой столбец или совокупность столбцов, значения которых однозначно идентифицируют строки. В данном примере первичным ключом в таблице Сотрудники является столбец Табельный №, ибо в одной организации не бывает сотрудников с одинаковыми табельными номерами. Очевидно, что в таблице Отделы первичным ключом является столбец, содержащий номер отдела."
  },
  {
    "category": "Базы данных.",
    "question": "Что такое foreign key (внешний ключ)?",
    "answer": "Вторичный (или внешний ключ, foreign key, FK). Столбец или совокупность столбцов, которые в данной таблице не являются первичными ключами, но являются первичными ключами в другой таблице. В рассматриваемом примере(в предыдущем вопросе) столбец № отдела таблицы Сотрудники содержит вторичный ключ, с помощью которого может быть установлена логическая взаимосвязь строк таблицы с соответствующими строками таблицы Отделы."
  },
  {
    "category": "Базы данных.",
    "question": "Что такое индексы в базе данных? Для чего их используют? Чем они хороши и чем плохи?",
    "answer": "Индексы - это специальные структуры в базах данных, которые позволяют ускорить поиск и сортировку по определенному полю или набору полей в таблице, а также используются для обеспечения уникальности данных. Проще всего индексы сравнить с указателями в книгах. Если нет указателя, то нам придется просмотреть всю книгу, чтобы найти нужное место, а с указателем то же действие можно выполнить намного быстрее. Обычно чем больше индексов, тем больше производительность запросов к базе данных. Однако при излишнем увеличении количества индексов падает производительность операций изменения данных (вставка/изменение/удаление), увеличивается размер БД, поэтому к добавлению индексов следует относиться осторожно. Некоторые общие принципы, связанные с созданием индексов:      индексы необходимо создавать для столбцов, которые используются в джойнах, по которым часто производится поиск и операции сортировки. При этом необходимо учесть, что индексы всегда автоматически создаются для столбцов, на которые накладывается ограничение primary key. Чаще всего они создаются и для столбцов с foreign key (в Access - автоматически)      индекс обязательно в автоматическом режиме создается для столбцов, на которые наложено ограничение уникальности      лучше всего индексы создавать для тех полей, в которых - минимальное число повторяющихся значений и данные распределены равномерно. В Oracle есть специальные битовые индексы для столбцов с большим количеством повторяющихся значений, в SQL Server и Access такой разновидности индексов не предусмотрено      если поиск постоянно производится по определенному набору столбцов (одновременно), то в этом случае, возможно, есть смысл создать композитный индекс (только в SQL Server) - один индекс для группы столбцов      при внесении изменений в таблицы автоматически изменяются и индексы, наложенные на эту таблицу. В результате индекс может быть сильно фрагментирован, что сказывается на производительности. Периодически следует проверять степень фрагментации индексов и дефрагментировать их. При загрузке большого количества данных иногда есть смысл вначале удалить все индексы, а после завершения операции создать их заново      индексы можно создавать не только для таблиц, но и для представлений (только в SQL Server). Преимущества - возможность вычислять поля не в момент запроса, а в момент появления новых значений в таблицах."
  },
  {
    "category": "Базы данных.",
    "question": "Какие есть типы индекса?",
    "answer": "В базе данных, в зависимости от ее функциональных возможностей, можно создавать индексы четырех типов: уникальный, кластерный, полнотекстовый и индекс первичного ключа. Индексы создаются в конструкторе баз данных. Сведения о функциях индексации, поддерживаемых в той или иной базе данных.      Уникальный индекс - уникальным является индекс, в котором не может быть двух строк с одним и тем же значением индекса. В большинстве баз данных не допускается сохранение таблицы с созданным в ней уникальным индексом, если в существующих данных имеются повторяющиеся значения ключа. В базе данных может быть также запрещено добавление новых данных, приводящее к появлению дубликатов значений ключа в таблице. Например, если создать уникальный индекс по фамилии сотрудника (lname) в таблице employee, в ней не должно быть двух сотрудников с одинаковыми фамилиями.     Индекс первичного ключа - в таблице базы данных обычно имеется столбец или комбинация столбцов, значения которых однозначно идентифицируют каждую строку таблицы. Такой столбец называется первичным ключом таблицы. Определение первичного ключа для таблицы в схеме базы данных автоматически приводит к созданию индекса первичного ключа, который является разновидностью уникального индекса. Этот индекс требует уникальности каждого значения первичного ключа. Он также обеспечивает быстрый доступ к данным при использовании индекса первичного ключа в запросах.      Кластерный индекс - в кластерном индексе физический порядок строк в таблице совпадает с логическим (индексированным) порядком значений ключа. У таблицы может быть только один кластерный индекс. Если индекс не кластеризован, физический порядок строк таблицы отличается от логического порядка значений ключа. Кластерный индекс обычно обеспечивает более быстрый доступ к данным, чем прочие индексы.     Полнотекстовый индекс - полнотекстовый индекс создается, если нужно выполнять полнотекстовый поиск по текстовым столбцам таблиц базы данных. Полнотекстовый индекс зависит от обычного индекса, поэтому сначала надо будет создать его. Обычный индекс должен быть создан для одного столбца, не допускающего значения NULL, и лучше всего выбирать столбцы с маленькими значениями, а не большими."
  },
  {
    "category": "SQL.",
    "question": "Что такое SQL?",
    "answer": "SQL (structured query language - \"язык структурированных запросов\") - формальный непроцедурный язык программирования, применяемый для создания, модификации и управления данными в произвольной реляционной базе данных, управляемой соответствующей системой управления базами данных (СУБД). SQL основывается на исчислении кортежей."
  },
  {
    "category": "SQL.",
    "question": "Какие есть типы JOIN'ов. Кратко опишите каждый из типов.",
    "answer": "(INNER)JOIN - внутреннее соединение. В результирующем наборе присутствуют только записи, значения связанных полей в которых совпадают. LEFT JOIN - левое внешнее соединение. В результирующем наборе присутствуют все записи из Table1 и соответствующие им записи из Table2. Если соответствия нет, поля из Table2 будут пустыми. RIGHT JOIN - правое внешнее соединение. В результирующем наборе присутствуют все записи из Table2 и соответствующие им записи из Table1. Если соответствия нет, поля из Table1 будут пустыми. FULL JOIN - полное внешнее соединение. Комбинация двух предыдущих. В результирующем наборе присутствуют все записи из Table1 и соответствующие им записи из Table2. Если соответствия нет - поля из Table2 будут пустыми. Записи из Table2, которым не нашлось пары в Table1, тоже будут присутствовать в результирующем наборе. В этом случае поля из Table1 будут пустыми. CROSS JOIN - Cartesian product. Результирующий набор содержит все варианты комбинации строк из Table1 и Table2. Условие соединения при этом не указывается."
  },
  {
    "category": "SQL.",
    "question": "Что такое LEFT JOIN, RIGHT JOIN? Чем они отличаются?",
    "answer": "LEFT JOIN - левое внешнее соединение. В результирующем наборе присутствуют все записи из Table1 и соответствующие им записи из Table2. Если соответствия нет, поля из Table2 будут пустыми. RIGHT JOIN - правое внешнее соединение. В результирующем наборе присутствуют все записи из Table2 и соответствующие им записи из Table1. Если соответствия нет, поля из Table1 будут пустыми."
  },
  {
    "category": "SQL.",
    "question": "Для чего используется слово HAVING?",
    "answer": "Секция HAVING определяет условие, которое затем применяется к групам строк. Следовательно, это предложение имеет тот же смысл для группы строк, что и предложение WHERE в отношении соодержимого соответствующей таблицы. Синтаксис предложения HAVING  HAVING  condition где condition содержит агрегатные функции или константы. Важно понимать, что секции HAVING и WHERE взаимно дополняют друг друга. Сначала с помощью ограничений WHERE формируется итоговая выборка, затем выполняется разбивка на группы по значениям полей, заданных в GROUP BY. Далее по каждой группе вычисляется групповая функция и в заключение накладывается условие HAVING. Пример: SELECT DeptNum, MAX(SALARY) FROM Employees GROUP BY DeptNum HAVING MAX(SALARY) > 1000 В приведенном примере в результат попадут только отделы, максимальная зарплата в которых превышает 1000."
  },
  {
    "category": "SQL.",
    "question": "Что такое DDL?",
    "answer": "DDL(Data Definition Language) - Команды определения структуры данных. В состав DDL-группы входят команды, позволяющие определять внутреннюю структуру базы данных. Перед тем, как сохранять данные в БД, необходимо создать в ней таблицы и, возможно, некоторые другие сопутствующие объекты Пример некоторых DDL-команд:(CREATE TABLE, DROP TABLE)"
  },
  {
    "category": "SQL.",
    "question": "Что такое DML?",
    "answer": "DML(Data Manipulation Language) - Команды манипулирования данными. DML-группа содержит команды, позволяющие вносить, изменять, удалять и извлекать данные из таблиц. Примеры DML-команд: UPDATE,DELETE,INSERT, SELECT"
  },
  {
    "category": "SQL.",
    "question": "Что такое TCL?",
    "answer": "TCL(Transaction Control Language) - TCL-команды используются для управления изменениями данных, производимыми DML-командами. С их помощью несколько DML-команд могут быть объединены в единое логическое целое, называемое транзакцией. При этом все команды на изменение данных в рамках одной транзакции либо завершаются успешно, либо все могут быть отменены в случае возникновения каких-либо проблем с выполнением любой из них. COMMIT,ROLLBACK,SETTRANSACTION"
  },
  {
    "category": "SQL.",
    "question": "Что такое DCL?",
    "answer": "DCL(Data Control Language) - Команды управления доступом. DCL-команды управляют доступом пользователей к БД и отдельным объектам:GRANT,REVOKE"
  },
  {
    "category": "SQL.",
    "question": "Какой общий синтаксис команди SELECT?",
    "answer": ""
  },
  {
    "category": "SQL.",
    "question": "Про NULL в SQL.",
    "answer": "Необходимо отметить, что язык SQL, в отличие от языков программирования, имеет встроенные средства поддержки факта отсутствия каких-либо данных. Осуществляется это с помощью NULL-концепции. NULL не является каким-то фиксированным значением, хранящимся в поле записи вместо реальных данных. Значение NULL не имеет определенного типа. NULL — это индикатор, говорящий пользователю (и SQL) о том, что данные в поле записи отсутствуют. Поэтому его нельзя использовать в операциях сравнения. Для проверки факта наличия-отсутствия данных в SQL введены специальные выражения."
  },
  {
    "category": "SQL.",
    "question": "Если вы собираетесь соединить несколько таблиц в запросе (например, n таблиц), сколько условий соединения вам нужно использовать?",
    "answer": "Тогда нужно использовать n-1 условий соединения чтоб исключить декартовой соединения, может быть и такое, что потребуется больше чем n-1 условий соединения, и совсем другие условия соединения для дальнейшего сокращения результирующего набора данных."
  },
  {
    "category": "SQL.",
    "question": "Какое практическое применение временных таблиц?",
    "answer": "Временная таблица - это объект базы данных, который хранится и управляется системой базы данных на временной основе. Они могут быть локальными или глобальными. используется для сохранения результатов вызова хранимой процедуры, уменьшение числа строк при соединениях, агрегирование данных из различных источников или замена курсоров и параметризованных представлений."
  },
  {
    "category": "SQL.",
    "question": "Как оператор GROUP BY обрабатывает значение NULL? Ли это общем трактовке таких значений?",
    "answer": "При использовании GROUP BY все значения NULL считаются равными. Значение NULL - это специальное значение, которое можно присвоить ячейке таблицы. Это значение обычно применяется, когда информация в ячейке неизвестна или неприемлема."
  },
  {
    "category": "SQL.",
    "question": "В чем разница между COUNT (*) и COUNT (столбец)?",
    "answer": "форма COUNT (столбец) подсчитывает количество значений в \"столбец\". При подсчете количества значений столбца эта форма функции COUNT не принимает во внимание значение NULL. функция COUNT (*) подсчитывает количество строк в таблице, не игнорирует значение NULL, поскольку эта функция оперирует строками, а не столбцами."
  },
  {
    "category": "SQL.",
    "question": "В чем разница между операторами DISTINCT и GROUP BY?",
    "answer": "DISTINCT - указывает, что для вычислений используются только уникальные значения столбца. NULL считается как отдельное значение. Если нужно удалить только дубликаты лучше использовать DISTINCT. GROUP BY группирует выбранный набор строк для получения набора сводных строк по значениям одного или нескольких столбцов или выражений. GROUP BY создает отдельную группу для всех возможных значений (включая значение NULL). GROUP BY лучше использовать для определения групп выходных строк, к которым могут применяться агрегатные функции (COUNT, MIN, MAX, AVG и SUM)."
  },
  {
    "category": "SQL.",
    "question": "Есть таблица table1 с колонками id и datetime написать запрос который вернет максимальное значение id и значение даты для этого id.",
    "answer": ""
  },
  {
    "category": "SQL.",
    "question": "Для чего нужны операторы UNION, INTERSECT, EXCEPT?",
    "answer": "Оператор UNION - применяется для объединения результатов двух SQL-запросов в единую таблицу, состоящую из похожих срок. Оба запроса Должны возвращать одинаковое число столбцов и совместимые типы данных в соответствующих столбцах. Оператор INTERSECT - используется для нахождения пересечения двух множеств. Результатом его выполнения будет множество строк, которые присутствуют в обоих множествах. Оператор EXCEPT - используется для нахождения разности двух множеств. Результатом выполнения является множество строк из множества 1, которые отсутствуют в множестве 2. Приоритет выполнения операторов над множествами: INTERSECT -> EXCEPT -> UNION"
  },
  {
    "category": "SQL.",
    "question": "Что лучше использовать соединение или подзапросы?",
    "answer": "Обычно лучше использовать JOIN, поскольку в большинстве случаев он понятен, и лучше оптимизируется с помощью Database Engine. но не всегда. Соединение имеет преимущество над подзапросов в случае, когда список выбора SELECT в запросе содержит столбцы более чем одной таблицы. Подзапросы лучшие тогда, когда нужно вычислять агрегатные значение и использовать их во внешних запросах для сравнений."
  },
  {
    "category": "SQL.",
    "question": "Что делает функция EXISTS?",
    "answer": "Аргументом функции EXISTS есть внутренний запрос. она возвращает истину, если запрос возвращает один или более строк, и возвращает ложь если запрос вернет ноль строк."
  },
  {
    "category": "SQL.",
    "question": "Использование оператора PIVOT.",
    "answer": "Реляционный оператор PIVOT можно использовать для изменения возвращающего табличное значение выражения в другой таблице. Оператор PIVOT разворачивает возвращающее табличное значение выражение, преобразуя уникальные значения одного столбца выражения в несколько выходных столбцов, а также, в случае необходимости, объединяет оставшиеся повторяющиеся значения столбца и отображает их в выходных данных."
  },
  {
    "category": "SQL.",
    "question": "Опишите разницу типов данных DATETIME и TIMESTAMP.",
    "answer": "DATETIME предназначен для хранения целого числа: YYYYMMDDHHMMSS. И это время не зависит от временной зоны настроенной на сервере.Хранит: 8 байт TIMESTAMP хранит значение равное количеству секунд, прошедших с полуночи 1 января 1970 года по усреднённому времени Гринвича. При получении из базы отображается с учётом часового пояса. Хранит: 4 байта."
  },
  {
    "category": "SQL.",
    "question": "Для каких числовых типов недопустимо использовать операцию сложения (вычитания), а значит и функцию SUM()?",
    "answer": "В качестве операндов операций сложения и вычитания допустимо любое корректное выражение любого типа данных числовой категории, кроме типа данных bit."
  },
  {
    "category": "SQL.",
    "question": "Что такое хранимые процедуры?",
    "answer": "Хранимая процедура - компилируемый набор SQL-инструкций, являющийся частью базы данных и хранимый на сервере. Есть много общего между ХП и обычными процедурами языков программирования: они могут иметь входные параметры и выходной результат, они могут как выполнять различные численные вычисления, так и выполнять стандартные операции с БД. Как и в процедурах других языков программирования, в них могут быть циклы и ветвления."
  },
  {
    "category": "SQL.",
    "question": "Функции ранжирования что это и какие существует?",
    "answer": "Ранжирующие функции возвращают ранжирующее значение для каждой строки в секции. В зависимости от используемой функции значения некоторых строк могут совпадать. Ранжирующие функции являются недетерминированными.  Transact-SQL содержит следующие ранжирующие функции:      RANK     NTILE     DENSE_RANK     ROW_NUMBER"
  },
  {
    "category": "SQL.",
    "question": "Может ли значение в столбце(ах), на который наложено ограничение foreign key, равняться null?",
    "answer": "Может, если на данный столбец не наложено ограничение not null, пример: при построении таблицы дерева файловой системы, где столбец foreign key - ссылка на эту же самую таблицу, на кортеж с информацией о родительской директории, тогда для корневой директории файловой системы в столбце родительской директории будет - null."
  },
  {
    "category": "SQL.",
    "question": "Назовите основные свойства транзакции.",
    "answer": "ACID - atomicity (атомарность), consistency (непротиворечивость), isolation (изолированность), durability (устойчивость).      Свойство атомарности гарантирует неделимость набора операторов, которые изменяют данные в базе данных и являются частью транзакции. Это означает, что или выполняются все изменения данных в транзакции, или в случае любой ошибки все уже выполненные изменения отменяются.     Согласованность гарантирует, что транзакция не даст возможности базе данных содержать несогласованные данные. Другими словами, трансформация данных в рамках одной транзакции переводит базу данных из одного согласованного состояния в другое согласованное состояние.     Свойство изолированности разделяет все одновременно выполняющиеся транзакции. Другими словами, ни одна активная транзакция не может видеть изменения данных, выполненные в параллельной, но не завершенной транзакции. Это означает, что для обеспечения изолированности для некоторых транзакций может быть выполнен откат.     Устойчивость - после своего завершения транзакция сохраняется в системе, которую ничто не может вернуть в исходное (до начала транзакции) состояние, т.е. происходит фиксация транзакции, означающая, что ее действие постоянно даже при сбое системы."
  },
  {
    "category": "SQL.",
    "question": "Как удалить повторяющиеся строки с использованием ключевого слова Distinct?",
    "answer": "SELECT DISTINCT columnsName FROM tableName  где: columnsName - одно или несколько реальных имен столбцов,перечисленных через запятую  tableName - имя той таблицы, из которой выбираются эти столбцы. Если в предложение SELECT DISTINCT включить более одного столбца, то в результате уникальность любой строки будет определяться уникальностью соответствующей комбинации всех значений столбцов, включенных в предложение, на этой самой строке среди аналогичных комбинаций, соответствующих другим строкам.  Несмотря на то что значения null никогда не бывают равны друг другу (поскольку считаются неизвестными), предложение DISTINCT , напротив, считает их дубликатами. Поэтому команда SELECT DISTINCT вернет только одно значение null, независимо от того, сколько значений null она встретит."
  },
  {
    "category": "SQL.",
    "question": "Когда полное сканирование таблицы выгоднее доступа по индексу? Опишите вкратце общие принципы, как оптимизатор выбирает производить ли полное сканирование таблицы или доступ по индексу.",
    "answer": "Полное сканирование производится многоблочным чтением. Сканирование по индексу - одноблочным. Также, при доступе по индексу сначала идет сканирование самого индекса, а затем чтение блоков из таблицы. Число блоков, которые надо при этом прочитать из таблицы зависит от фактора кластеризации. Если суммарная стоимость всех необходимых одноблочных чтений больше стоимости полного сканирования многоблочным чтением, то полное сканирование выгоднее и оно выбирается оптимизатором. Таким образом, полное сканирование выбирается при слабой селективности предикатов зароса и/или слабой кластеризации данных, либо в случае очень маленьких таблиц.      Им"
  },
  {
    "category": "SQL.",
    "question": "Имеет ли смысл индексировать поля таблицы, имеющих тип boolean или подобные им - с небольшим количеством возможных значений?",
    "answer": "Индекс по логическим полям имеет смысл, только в случае, если значения ИСТИНА и ЛОЖЬ распределены примерно равномерно по таблице. Предельный случай - две трети и одна треть."
  },
  {
    "category": "SQL.",
    "question": "Что такое агрегатная функция? Приведите примеры агрегатных функций в SQL.",
    "answer": "Агрегатная функция - это функция, которая возвращает одиночное значение на основании множества записей. Вот список некоторых агрегатных функций SQL:      COUNT(*) - Возвращает количество строк источника записей     COUNT - Возвращает количество значений в указанном столбце     SUM - Возвращает сумму значений в указанном столбце     AVG - Возвращает среднее значение в указанном столбце     MIN - Возвращает минимальное значение в указанном столбце     MAX - Возвращает максимальное значение в указанном столбце"
  },
  {
    "category": "SQL.",
    "question": "Дайте определение третьей нормальной форме БД.",
    "answer": "Определение третьей нормальной форме БД.      Любое поле любой записи хранит только одно значение. (1NF) Например, если в поле хранится список идентификаторов, разделённых запятыми, то это нарушение данного определения.     Выполняется условие 1NF и любое неключевое поле полностью зависит от ключа. (2NF) Например, у нас есть запись с полями (Идентификатор, Название CD-Диска, Название группы), где ключом является поле «Идентификатор». При этом, очевидно, что поле «Название группы» зависит не только от «Идентификатора» но и от поля «Название CD-Диска». Поэтому такая БД не находится во второй нормальной форме.     Выполняется условие 2NF и нет неключевых полей зависящих от значения других неключевых полей. Например у нас в записи хранятся код региона и его название. Понятно, что название региона зависит от кода, и наоборот, поэтому такая БД не будет находиться в третьей нормальной форме."
  },
  {
    "category": "SQL.",
    "question": "Что такое денормализация БД? Для чего она нужна?",
    "answer": "Денормализация - это процесс осознанного приведения базы данных к виду, в котором она не будет соответствовать правилам нормализации. Обычно это необходимо для повышения производительности и скорости извлечения данных, за счет увеличения избыточности данных. Если приложению необходимо часто выполнять выборки, которые занимают слишком много времени (например, объединение данных из множества таблиц), то следует рассмотреть возможность проведения денормализации. Возможное решение следующее: вынести результаты выборки в отдельную таблицу. Это позволит увеличить скорость выполнения запросов, но также означает появление необходимости в постоянном обслуживании этой новой таблицы. Прежде чем приступать к денормализации, необходимо убедится, что ожидаемые результаты оправдывают издержки, с которыми придется столкнуться."
  },
  {
    "category": "SQL.",
    "question": "Что такое триггер?",
    "answer": "Триггер - это SQL процедура, которая срабатывает при каком-нибудь событии (INSERT, DELETE или UPDATE). Триггеры хранятся и управляются СУБД. Триггеры используются для поддержания ссылочной целостности данных в одинаковый манер реагируя на события изменения этих данных. Триггер не может быть вызван или выполнен вручную, СУБД автоматически вызывает его после модификации данных в соответствующей таблице. В этом и есть его отличие от хранимых процедур, которые нужно выполнять вручную вызовом CALL. Также триггер может вызывать другие процедуры. Триггер также может содержать вызовы INSERT, DELETE и UPDATE внутри себя, таким образом вызывая другой триггер. Такие триггеры называются вложенными (nested)."
  },
  {
    "category": "SQL.",
    "question": "Что такое курсоры в базах данных?",
    "answer": "Курсор - это объект базы данных, который позволяет приложениям работать с записями \"по-одной\", а не сразу с множеством, как это делается в обычных SQL командах. Порядок работы с курсором такой:      Определить курсор (DECLARE)     Открыть курсор (OPEN)     Получить запись из курсора (FETCH)     Обработать запись     Закрыть курсор (CLOSE)"
  },
  {
    "category": "SQL.",
    "question": "Какие компромиссы предлагает использование индексов?",
    "answer": "Некоторые из них:      Более быстрые выборки, но более медленные изменения. (При изменениях тратиться время на перестройку индекса).     Для хранения индексов необходимо дополнительное дисковое пространство."
  },
  {
    "category": "SQL.",
    "question": "Что делает SQL операция MERGE?",
    "answer": "Операция MERGE официально появилась в стандарте ANSI SQL:2008. Она позволяет одновременно вставлять или изменять записи таблицы согласно критерию. При выполнении критерия строки изменяются, иначе - вставляются. Ее можно заменить последовательным вызовом INSERT и UPDATE. В некоторых базах данных похожая операция называется UPSERT."
  },
  {
    "category": "SQL.",
    "question": "В чем различие между выражениями HAVING и WHERE?",
    "answer": "WHERE - это ограничивающее выражение. Оно выполняется до того, как будет получен результат операции. HAVING - фильтрующее выражение. Оно применяется к результату операции и выполняется уже после того как этот результат будет получен, в отличии от where. Выражения WHERE используются вместе с операциями SELECT, UPDATE, DELETE, в то время как HAVING только с SELECT и предложением GROUP BY. Например, WHERE нельзя использовать таким образом: В данном случае больше подходит HAVING: То есть, использовать WHERE в запросах с агрегатными функциями нельзя, для этого и был введен HAVING."
  },
  {
    "category": "SQL.",
    "question": "Что такое целостность данных? Объясните, что такое ограничения.",
    "answer": "Целостность данных - важное свойство SQL. При правильном использовании оно обеспечивает корректность и валидность хранимых данных в любой момент времени. Также, с их помощью можно обнаруживать ошибки в приложениях, которые тяжело найти другими способами. Целостность данных поддерживается с помощью ограничений. В SQL стандарта ANSI есть 4 основных ограничения: PRIMARY KEY, CHECK, UNIQUE и FOREIGN KEY. Они не являются обязательными для таблицы.      PRIMARY KEY - набор полей (1 или более), значения которых образуют уникальную комбинацию и используются для однозначной идентификации записи в таблице. Для таблицы может быть создано только одно такое ограничение. Данное ограничение используется для обеспечения целостности сущности, которая описана таблицей.     CHECK используется для ограничения множества значений, которые могут быть помещены в данный столбец. Это ограничение используется для обеспечения целостности предметной области, которую описывают таблицы в базе.     Ограничение UNIQUE обеспечивает отсутствие дубликатов в столбце или наборе столбцов. Разница между PRIMARY KEY и UNIQUE описана в primary и unique ключи     Ограничение FOREIGN KEY защищает от действий, которые могут нарушить связи между таблицами. FOREIGN KEY в одной таблице указывает на PRIMARY KEY в другой. Поэтому данное ограничение нацелено на то, чтобы не было записей FOREIGN KEY, которым не отвечают записи PRIMARY KEY. Таким образом, FOREIGN KEY поддерживает ссылочную целостность данных."
  },
  {
    "category": "SQL.",
    "question": "В чем отличие между кластерными индексами и некластерными?",
    "answer": "Некластерные индексы создаются СУБД по умолчанию. Данные физически расположены в произвольном порядке, но логически упорядочены согласно индексу. Такой тип индексов подходит для таблиц, где часто изменяются значения. При кластерном индексировании данные физически упорядочены, что серьезно повышает скорость выборок данных (но только в случае последовательного доступа к данным). Для одной таблицы может быть создан только один кластерный индекс."
  },
  {
    "category": "SQL.",
    "question": "Какие отличия между ограничениями primary и unique?",
    "answer": "Ограничения primary и unique призваны обеспечить уникальность значений столбца, на котором они определены. Но по умолчанию ограничение primary создает кластерный индекс на столбце, а unique - некластерный. Другим отличием является то, что primary не разрешает NULL записей, в то время как unique разрешает только одну NULL запись."
  },
  {
    "category": "MongoDB",
    "question": "Что такое NoSQL?",
    "answer": "NoSQL (Not only SQL) - это ряд технологий, подходов, проектов направленных на реализацию моделей баз данных, имеющих существенные отличия от традиционных СУБД, работающих с языком SQL. Концепция NoSQL не отрицает SQL, она лишь стремится решить проблемы и вопросы, с которыми не достаточно хорошо справляется РСУБД. Чаще всего данные в NoSQL решении представляются в виде хеш-таблиц, деревьев, документов и пр."
  },
  {
    "category": "MongoDB",
    "question": "Какие есть типы хранилищ данных в NoSQL?",
    "answer": "В зависимости от модели данных и подходов к распределённости и репликации можно выделить четыре типа хранилищ:      \"ключ-значение\" (key-value store)     документно-ориентированные (document store)     хранилища семейств колонок (column database)     графовые базы данных (graph database)."
  },
  {
    "category": "MongoDB",
    "question": "Что такое MongoDB?",
    "answer": "MongoDb - это документо-ориентированная база данных, в отличие от традиционных реляционных баз данных, таких как MySQL или PostgreSQL не использует табличный способ представления со связями через внешние ключи, основанная на принципе хранении документов в BSON(Binary JSON) формате. Т.е. каждая запись это документ, без жестко заданной схемы, который может содержать вложенные документы."
  },
  {
    "category": "MongoDB",
    "question": "На каком языке написана MongoDB?",
    "answer": "MongoDB написана и реализована на С++"
  },
  {
    "category": "MongoDB",
    "question": "Какие языки программирования можно использовать с MongoDB?",
    "answer": "Клиентские драйверы MongoDB поддерживают все популярные языки программирования, так что выбор языка не является проблемой. Вы можете использовать любой язык, какой хотите."
  },
  {
    "category": "MongoDB",
    "question": "Использует ли таблицы для хранения данных, база данных MongoDB?",
    "answer": "Нет. Для хранения данных вместо таблиц, MongoDB использует \"Коллекции\" (collections)."
  },
  {
    "category": "MongoDB",
    "question": "Какие преимущества MongoDB?",
    "answer": "Основные возможности MongoDB:      Документо-ориентированное хранилище (простая и мощная JSON-подобная схема данных)     Достаточно гибкий язык для формирования запросов     Динамические запросы     Полная поддержка индексов     Профилирование запросов     Быстрые обновления \"на месте\"     Эффективное хранение двоичных данных больших объёмов, напр., фото и видео     Журналирование операций, модифицирующих данные в БД     Поддержка отказоустойчивости и масштабируемости: асинхронная репликация, набор реплик и шардинг     Может работать в соответствии с парадигмой MapReduce     Имеет распределенный доступ к данным, расположенных на нескольких серверах"
  },
  {
    "category": "MongoDB",
    "question": "Какие недостатки MongoDB?",
    "answer": "Недостатки:      Отсутствует оператор \"join\". Обычно данные могут быть организованы более денормализованным способом, но на разработчиков ложится дополнительная нагрузка по обеспечению непротиворечивости данных.     Нет такого понятия, как \"транзакция\". Атомарность гарантируется только на уровне целого документа, т.е. частичное обновление документа произойти не может.     Отсутствует понятие \"изоляции\". Любые данные, которые считываются одним клиентом, могут параллельно изменяться другим клиентом.     Менее чем более стабильна, не рекомендовано использовать в биллинге     Требовательна к ресурсам - память и место на диске"
  },
  {
    "category": "MongoDB",
    "question": "Что такое пространство имен в MongoDB?",
    "answer": "Пространство имен в MongoDB это конкатенация имени базы данных и названия коллекции. Для например school.students, где school - имя базы данных и students - название коллекции."
  },
  {
    "category": "MongoDB",
    "question": "Что такое репликация?",
    "answer": "Репликация - это процесс синхронизации данных между несколькими серверами. Позволяет добиться большей масштабируемости, и повысить доступность и сохранность данных. Репликация также позволяет восстанавливать даные после сбоя аппаратного обеспечения. С помощью дополнительных копий данных, вы можете выделить один сервер для аварийного восстановления, отчетности или резервного копирования. MongoDB поддерживает 2 формы репликации:      реплисеты(Replica Sets )     ведущий-ведомый(Master-Slave)."
  },
  {
    "category": "MongoDB",
    "question": "Поддерживает ли MongoDB ограничения внешнего ключа(foreign key)?",
    "answer": "Нет"
  },
  {
    "category": "MongoDB",
    "question": "Как мы можем достичь primary key - foreign key отношения в MongoDB?",
    "answer": "По умолчанию MongoDB не поддерживает primary key - foreign key отношения. Тем не менее, мы можем достичь этой концепции путем встраивания одного документа внутри другого. Для например документ \"адрес\" может быть встроен внутри документа \"клиент\"."
  },
  {
    "category": "MongoDB",
    "question": "Объясните структуру ObjectID в MongoDB.",
    "answer": "ObjectID ето 12-байт типа BSON, имеющий следующую структуру:.      Первые 4 байта, представляющие секунды с эпохи Unix      Следующие 3 байта являются идентификатором машины     Следующие 2 байта являются идентификатором процесса     Последние 3 байта ето случайная величина счетчика:   MongoDB использует ObjectID как значение по умолчанию поля _id каждого документа, который генерируется во время создания любого документа. ObjectID делает все поля _id уникальными. Для создания нового ObjectID используется следующий код: NewObjectId = ObjectId()"
  },
  {
    "category": "MongoDB",
    "question": "Если удалить документ из базыданных, удалится ли он с диска?",
    "answer": "Да. Удаление документа из базы данных приведет к его удалению с диска."
  },
  {
    "category": "MongoDB",
    "question": "Что такое индексы в MongoDB?",
    "answer": "Индексы - ето специальная структура данных, которая хранит небольшую часть набора данных. Индекс сохраняет значение конкретного поля или набора полей, упорядоченых по величине поля, как указано в индексе.  Индексы поддерживать эффективное выполнение запросов. Без индексов, MongoDB должна сканировать каждый документ коллекции, чтобы выбрать те документы, которые соответствуют оператору запроса. Это сканирование крайне неэффективно и требует от  MongoDB обработки большого объема данных. Индексы в MongoDB работают схожим образом с индексами в реляционных базах данных: они ускоряют выборку и сортировку данных. Индексы создаются с помощью ensureIndex."
  },
  {
    "category": "MongoDB",
    "question": "Сколько индексов создается по умолчанию в MongoDB для новой коллекции?",
    "answer": "По умолчанию, MongoDB создает только _id для каждой коллекции."
  },
  {
    "category": "MongoDB",
    "question": "Что такое скрытый запрос в MongoDB?",
    "answer": "В соответствии с официальной документации MongoDB, скрытый запрос ето запрос в котором:      все поля в запросе являются частью индекса используемого в запросе     все поля в запросе возвращаются в том же индексе"
  },
  {
    "category": "MongoDB",
    "question": "Поддерживает ли MongoDB поиск текста?",
    "answer": "Да. MongoDB поддерживает создание текстовых индексов для поддержки поиска текста внутри строки. Эта функция, была введена в версии 2.6."
  },
  {
    "category": "MongoDB",
    "question": "Какая команда позволяет получить все индексы определенной коллекции?",
    "answer": "db.collections.getIndexes()"
  },
  {
    "category": "MongoDB",
    "question": "Что такое Шардинг в MongoDB?",
    "answer": "Шардинг - это подход к масштабируемости, когда отдельные части данных хранятся на разных серверах. Шардинг решает проблему горизонтального масштабирования. Примитивный пример: хранить данные пользователей, чьё имя начинается на буквы A-M на одном сервере, а остальных - на другом."
  },
  {
    "category": "MongoDB",
    "question": "По умолчанию, MongoDB пишет и читает данные из primary и secondary наборов реплик. Правда ето или ложь?",
    "answer": "Ложь. MongoDB записывает данные только в primary набор реплик."
  },
  {
    "category": "MongoDB",
    "question": "Почему MongoDB не является предпочтительным решением для 32-битных систем?",
    "answer": "При работе с 32-разрядной сборкой MongoDB, общий размер хранилища для сервера, включая данные и индексы, составляет 2 гигабайта. По этой причине, не рекомендуеться развертывать MongoDB для продакшина на 32-разрядных машинах. Если вы используете 64-разрядную сборку MongoDB, практически нет никаких ограничений на размер хранилища."
  },
  {
    "category": "MongoDB",
    "question": "Какая команда,позволяет проверить, являетесь ли вы на главном сервере или нет?",
    "answer": "db.isMaster()"
  },
  {
    "category": "MongoDB",
    "question": "Что такое GridFS?",
    "answer": "GridFS - это спецификация, определённая в базе данных MongoDB для хранения и извлечения файлов, размер которых превышает 16 Мб. Такое ограничение размера обусловлено использованием в MongoDB формата BSON. Согласно спецификации GridFS файл разбивается на несколько фрагментов (англ. chunks), каждый из которых не может быть больше, чем 255 Кб. Каждый такой фрагмент хранится как отдельный файл и к нему может быть осуществлён доступ как к отдельному файлу. Для обеспечения корректной сборки разбитого на фрагменты файла GridFS хранит коллекцию метаданных - отдельных файлов, содержащих информацию о хранящихся в файловой системе документах."
  },
  {
    "category": "MongoDB",
    "question": "Что такое Map/Reduce?",
    "answer": "Map/Reduce - это подход к обработке больших объемов данных, который состоит из двух фаз: Map - предварительная обработка входных данных и Reduce - обработка тем или иным способом выборки, полученной на стадии Map. Map/Reduce не является свойством исключительно NoSQL-решений. Аналогичным образом можно работать с большими объемами данных и в РСУБД. Но большинство NoSQL-систем (за исключением, может быть, самых простых key-value хранилищ) реализуют Map/Reduce в том или ином виде. Map/Reduce имеет два серьёзных преимущества по сравнению с традиционными решениями. Первое и самое главное преимущество - это производительность. Теоретически MapReduce может быть распараллелен, что позволяет обрабатывать огромные массивы данных на множестве ядер/процессоров/машин. Это пока не является преимуществом MongoDB. Вторым преимуществом MapReduce является возможность описывать обработку данных нормальным кодом. По сравнению с тем, что можно сделать с помощью SQL, возможности кода внутри MapReduce намного богаче и позволяют расширить рамки возможного даже без использования специализированных решений."
  },
  {
    "category": "MongoDB",
    "question": "Как создать/удалить коллекцию в MongoDB?",
    "answer": "db.createCollection(name,options) - для создания коллекции в MongoDB db.collection.drop() - для удаления коллекции в MongoDB"
  },
  {
    "category": "MongoDB",
    "question": "Какова роль профайлера в MongoDB?",
    "answer": "Профайлера базы данных MongoDB показывает рабочие характеристики каждой операции с базой данных. Для примера вы можете найти запросы с помощью профилировщика которие на самом деле медленнее, чем они должны быть. Профайлер MongoDB можно включить с помощью следующего вызова: db.setProfilingLevel(2) чтобы выключить профайлер, нужно повторно вызвать setProfileLevel, только передав 0 в качестве аргумента."
  },
  {
    "category": "MongoDB",
    "question": "Какая команда позволяет вставить документ?",
    "answer": "database.collection.insert(document) - для вставки документа в колекцию."
  },
  {
    "category": "MongoDB",
    "question": "Приведите пример использования индекса в MongoDB.",
    "answer": "db.COOLECTION_NAME.ensureIndex({ KEY : 1 })"
  },
  {
    "category": "MongoDB",
    "question": "Какой метод вернёт список всех документов в колекции?",
    "answer": "db.unicorns.find()"
  },
  {
    "category": "MongoDB",
    "question": "Что такое селекторы запросов в MongoDB?",
    "answer": "Селектор - это JSON-объект, в простейшем случае это может быть даже {}, что означает выборку всех документов (аналогичным образом работает null). Селектор запросов MongoDB аналогичен предложению where SQL-запроса. Как таковой он используется для поиска, подсчёта, обновления и удаления документов из коллекций."
  },
  {
    "category": "MongoDB",
    "question": "Что вы знаете об обновлении/вставке в MongoDB?",
    "answer": "Один из приятных сюрпризов операции обновления - это возможность обновления/вставки (upsert от update - обновить и insert - вставить) Обновление/вставка обновляет документ, если он найден, или создаёт новый - если не найден. Обновление/вставка - полезная вещь в некоторых случаях когда столкнётесь с подобным, сразу поймёте. Чтобы разрешить вставку при обновлении, установите третий параметр в true. Пример из жизни - счётчик посещений для веб-сайта. Если мы хотим в реальном времени видеть количество посещений страницы, мы должны посмотреть, существует ли запись, и - в зависимости от результата - выполнить update либо insert."
  },
  {
    "category": "MongoDB",
    "question": "Что вы знаете об  условных оператораторах в MongoDB?",
    "answer": "В MongoDB в запросах можно использовать условные:      $gt - больше чем     $lt - меньше чем     $gte  - больше или равно     $lte - меньше или равно     $ne  - извлекает все документы, не соответствующие некоторому условию     $or - определяет набор пар ключ-значение, которые должны иметься в документе. И если документ имеет хоть одну такую пару ключ-значение, то он соответствует данному запросу и извлекается из бд     $size - используется для нахождения документов, в которых массивы имеют число элементов, равным значению $size     $exists - позволяет извлечь только те документы, в которых определенный ключ присутствует или отсутствует     $regex - задает регулярное выражение, которому должно соответствовать значение поля  Поиск по массивам и операторы $in, $nin, $all      $in - определяет массив возможных выражений и ищет те ключи, значение которых имеется в массиве     $nin - определяет массив возможных выражений и ищет те ключи, значение которых отсутствует в этом массиве     $all - похож на $in: он также определяет массив возможных выражений, но требует, чтобы документы имели весь определяемый набор выражений"
  },
  {
    "category": "MongoDB",
    "question": "Как удалить документ в MongoDB?",
    "answer": "Для удаления документов в MongoDB предусмотрен метод remove: db.users.remove({name: \"Tom\"})"
  },
  {
    "category": "Тестирование. JUNIT.",
    "question": "Чем стаб (stub) отличается от мока (mock)?",
    "answer": "Stub - объекты, которые предоставляют заранее заготовленные ответы на вызовы во время выполнения теста и обычно не отвечающие ни на какие другие вызовы, которые не требуются в тесте. Также могут запоминать какую-то дополнительную информацию о количестве вызовов, параметрах и возвращать их потом тесту для проверки. Используется для \"затычки\" сервисов, методов, классов и т.д. Абсолютно все равно что они вернут при работе или сколько раз произойдет вызов. Mock - объекты, которые заменяют реальный объект в условиях теста и позволяют проверять вызовы своих членов как часть системы или unit-теста. Содержат заранее запрограммированные ожидания вызовов, которые они ожидают получить. Применяются в основном для т.н. interaction (behavioral) testing. Используется для подмены результатов вызова функций в юнит тестах (важен результат), для учета количества вызовов функций и просто ожидания их вызовов. Используется в области Assert юнит теста."
  },
  {
    "category": "Тестирование. JUNIT.",
    "question": "Что такое unit testing?",
    "answer": "Модульное тестирование или unit testing - процесс проверки на корректность функционирования отдельных частей исходного кода программы путем запуска тестов в искусственной среде."
  },
  {
    "category": "Тестирование. JUNIT.",
    "question": "Что такое Фикстуры?",
    "answer": "Фикстура (Fixture) - состояние среды тестирования, которое требуется для успешного выполнения тестового метода. Может быть представлено набором каких-либо объектов, состоянием базы данных, наличием определенных файлов, соединений и проч."
  },
  {
    "category": "Тестирование. JUNIT.",
    "question": "Какие есть аннотации фикстур?",
    "answer": "Предусмотрено четыре аннотации фикстур - две для фикстур уровня класса и две для фикстур уровня метода.      @BeforeClass - запускается только один раз при запуске теста.     @Before - запускается перед каждым тестовым методом.     @After - запускается после каждого метода.     @AfterClass - запускается после того, как отработали все тестовые методы."
  },
  {
    "category": "Тестирование. JUNIT.",
    "question": "Для чего нужна Аннотация @Ignore?",
    "answer": "Аннотация @Ignore заставляет инфраструктуру тестирования проигнорировать данный тестовый метод. Аннотация предусматривает наличие комментария о причине игнорирования теста, полезного при следующем к нему обращении."
  },
  {
    "category": "Тестирование. JUNIT.",
    "question": "Что такое интеграционные тесты?",
    "answer": "Интеграционные тесты - это тесты, проверяющие работоспособность двух или более модулей системы, но в совокупности - то есть нескольких объектов как единого блока."
  },
  {
    "category": "Log4j.",
    "question": "Из чего состоит логгер?",
    "answer": "Любой регистратор событий состоит из трех элементов:      cобственно регистрирующего - logger      направляющего вывод - appender      форматирующего вывод - layout."
  },
  {
    "category": "Log4j.",
    "question": "Какие есть уровни сообщении в log4j?",
    "answer": "Приоритетов может быть ШЕСТЬ (log4j1.2.*):      FATAL - произошла фатальная ошибка - у этого сообщения наивысший приоритет     ERROR - в программе произошла ошибка     WARN - предупреждение в программе что-то не так     INFO - информация.     DEBUG - детальная информация для отладки     TRACE– трассировка всех сообщений в указанный аппендер  OFF< TRACE< DEBUG< INFO< WARN< ERROR< FATAL< ALL"
  },
  {
    "category": "Log4j.",
    "question": "Что такое Appender?",
    "answer": "Вывод регистратора может быть направлен в различные места назначения: файл, консоль и т. д. Каждому из них соответствует класс, реализующий интерфейс org.apache.log4j.Appender. Кроме того, вывод в базу данных можно произвести с помощью класса JDBCAppender, в журнал событий ОС - NTEventLogAppender, на SMTP-сервер - SMTPAppender. Если логгер - это та точка, откуда уходят сообщения в коде, то аппендер - это та точка, куда они приходят в конечном итоге. Например, файл или консоль. Список таких точек, поддерживаемых Log4J:      консоль      файлы (несколько различных типов)      JDBC      темы (topics) JMS      NT Event Log      SMTP      Сокет      Syslog      Telnet      любой java.io.Writer или java.io.OutputStream."
  },
  {
    "category": "Log4j.",
    "question": "Какие основные аппендеры Log4j?",
    "answer": "Основными аппендерами, использующимися наиболее широко, являются файловые аппендеры. Их есть несколько типов:      org.apache.log4j.FileAppender     org.apache.log4j.RollingFileAppender     org.apache.log4j.DailyRollingFileAppender"
  },
  {
    "category": "Log4j.",
    "question": "Что такое Layout?",
    "answer": "Вывод регистратора может иметь различный формат. Каждый формат представлен классом, производным от Layout. Все методы класса Layout предназначены только для создания подклассов.      org.apache.log4j.SimpleLayout - наиболее простой вариант. На выходе читается уровень вывода и сообщение.     org.apache.log4j.HTMLLayout - данный компоновщик форматирует сообщения в виде HTML-страницы.     org.apache.log4j.xml.XMLLayout - формирует сообщения в виде XML.     org.apache.log4j.PatternLayout и org.apache.log4j.EnhancedPatternLayout используют шаблонную строку для форматирования выводимого сообщения."
  },
  {
    "category": "UML.",
    "question": "Что такое UML?",
    "answer": "Унифицированный язык моделирования (Unified Modeling Language) - графический язык визуализации, специфицирования, конструирования и документирования программного обеспечения."
  },
  {
    "category": "UML.",
    "question": "Что такое Нотации и метамодель в UML?",
    "answer": "Нотация - совокупность графических объектов, которые используются в моделях. В качестве примера на диаграмме показано, как в нотации диаграммы класса определяют понятия и предметы типа «класс», «ассоциацция»,«множественность» и т. д. Метамодель - диаграмма, определяющая нотацию. Метамодель помогает понять, что такое хорошо организованная, т. е. синтаксически правильная, модель."
  },
  {
    "category": "UML.",
    "question": "Какие есть типы диаграмм?",
    "answer": "Структурные диаграммы:      диаграммы классов (class diagrams) предназначены для моделирования структуры объектно-ориентированных приложений - классов, их атрибутов и заголовков методов, наследования, а также связей классов друг с другом      диаграммы компонент (component diagrams) используются при моделировании компонентной структуры распределенных приложений  внутри каждая компонента может быть реализована с помощью множества классов      диаграммы объектов (object diagrams) применяются для моделирования фрагментов работающей системы, отображая реально существующие в runtime экземпляры классов и значения их атрибутов      диаграммы композитных структур (composite structure diagrams) используются для моделирования составных структурных элементов моделей - коопераций, композитных компонент и т.д.      диаграммы развертывания (deployment diagrams) предназначены для моделирования аппаратной части системы, с которой ПО непосредственно связано (размещено или взаимодействует)      диаграммы пакетов (package diagrams) служат для разбиения объемных моделей на составные части, а также (традиционно) для группировки классов моделируемого ПО, когда их слишком много.  Поведенческие диаграммы:      диаграммы активностей (activity diagrams) используются для спецификации бизнес-процессов, которые должно автоматизировать разрабатываемое ПО, а также для задания сложных алгоритмов      диаграммы случаев использования(use case diagrams) предназначены для \"вытягивания\" требований из пользователей, заказчика и экспертов предметной области      диаграммы конечных автоматов (state machine diagrams) применяются для задания поведения реактивных систем      диаграммы взаимодействий (interaction diagrams):     диаграммы последовательностей (sequence diagrams) используются для моделирования временных аспектов внутренних и внешних протоколов ПО      диаграммы схем взаимодействия (interaction overview diagrams) служат для организации иерархии диаграмм последовательностей      диаграммы коммуникаций (communication diagrams) являются аналогом диаграмм последовательностей, но по-другому изображаются (в привычной, графовой, манере)      временные диаграммы (timing diagrams) являются разновидностью диаграмм последовательностей и позволяют в наглядной форме показывать внутреннюю динамику взаимодействия некоторого набора компонент системы.  Основные понятия. К основным понятиям UML относятся:      сущности - абстракции, являющиеся основными элементами модели      отношения - связывают различные сущности      диаграммы - группируют представляющие интерес совокупности сущностей."
  },
  {
    "category": "UML.",
    "question": "Какие отношение обобщения реализуется при наследовании классов.",
    "answer": "Реализацией (Realization) называется отношение между классификаторами (классами, интерфейсами), при котором один описывает контракт (интерфейс сущности), а другой гарантирует его выполнение. Ассоциация (Association) показывает, что объект одного класса связан с объектом другого класса и отражает некоторое отношение между ними. Агрегация - ассоциация, моделирующая взаимосвязь «часть/целое» между классами, которые в то же время могут быть равноправными. Оба класса при этом находятся на одном концептуальном уровне, и ни один не является более важным, чем другой."
  },
  {
    "category": "XML.",
    "question": "Что такое XML?",
    "answer": "XML(eXtensible Markup Language - расширяемый язык разметки) - текстовый формат, предназначенный для хранения структурированных данных (взамен существующих файлов баз данных), для обмена информацией между программами, а также для создания на его основе более специализированных языков разметки (например, XHTML)."
  },
  {
    "category": "XML.",
    "question": "Как определяется корректность XML-документа?",
    "answer": "Корректность XML-документа определяют следующие два компонента:      синтаксическая корректность (well-formed) - то есть соблюдение всех синтаксических правил XML      действительность (valid) - то есть данные соответствуют некоторому набору правил, определенных пользователем  правила определяют структуру и формат данных в XML. Валидность XML-документа определяется наличием DTD или XML-схемы (XSD) и соблюдением правил, которые там приведены."
  },
  {
    "category": "XML.",
    "question": "Чем well-formed XML отличается от valid?",
    "answer": "Отличие:      well-formed XML - тот, который пропускается парсером     valid XML - тот, который пропускается парсером И валидатором"
  },
  {
    "category": "XML.",
    "question": "Что такое пространство имен?",
    "answer": "Пространство имен (namespace) - введено для разделения наборов элементов с соответствующими правилами, описанными схемой. Пространство имен объявляется с помощью атрибута xmlns и префикса, который используется для элементов из данного пространства."
  },
  {
    "category": "XML.",
    "question": "Что такое простые типы в XSD?",
    "answer": "Элементы, которые не имеют атрибутов и дочерних элементов, называются простыми и должны иметь простой тип данных. Существуют стандартные простые типы, например string (представляет строковое значение), boolean (логическое значение), integer (целое значение), float (значение с плавающей точкой), ID (уникальный идентификатор), gYear (год) и др."
  },
  {
    "category": "XML.",
    "question": "Что такое сложныетипы в XSD?",
    "answer": "Элементы, содержащие в себе атрибуты и/или дочерние элементы, называются сложными. Сложные элементы создаются с помощью элемента complexType. Так же, как и в простом типе атрибут name задает имя типа."
  },
  {
    "category": "XML.",
    "question": "Какие элементы и атрибуты XSD Вы знаете? Кратко опишите их.",
    "answer": "Ниже приведён список  элементов и атрибутов ХСД:      schema - корневой элемент любой схемы XML. Может содержать несколько атрибутов, например версию схемы.     xmlns - каждый элемент схемы имеет стандартный префикс xs: (или xsd:, может быть использован любой префикс), который связан с пространством имен схемы XML (xmlns) путем объявления: xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\".     element - элементы объявляются с помощью элемента element. Например, order - это элемент, который в документе выглядит как <order id=\"1234\" date=\"11/08/2013\" total_amount=\"93.48\">.     type - элемент может иметь простой тип, например string, decimal, long или double (type=\"xs:long\") или сложный (type=\"customer\").     minOccurs, maxOccurs - определяет минимальное или максимальное количество появлений типа. Может быть положительным целым числом или иметь значение unbounded, которое говорит о том, что верхней границы нет.     complexType - определяет комплексный тип, имеющий собственные элементы, подэлементы и атрибуты. Элемент типа complexType может содержать другие элементы типа complexType. Например, комплексный тип order содержит другой комплексный элемент.     sequence - элемент может содержать другие элементы, которые называются элементами-потомками. Элемент такого типа указывает, что элементы-потомки должны следовать в цепочке. Каждый потомок может встречаться от 0 до неограниченного количества раз.     attribute - комплексный тип может иметь один или несколько атрибутов, которые определены с помощью элементов типа attribute. Тип orderLine имеет два атрибута: item и quantity.     choice - используется для указания, что может присутствовать только один набор элементов.     complexContent - комплексный тип может расширять или ограничивать другой комплексный тип с помощью элемента типа complexContent.     extension - элемент такого типа расширяет существующий элемент типа simpleType или complexType."
  },
  {
    "category": "XML.",
    "question": "Какие существуют XML парсеры?",
    "answer": "Существуют SAX, DOM, JDOM парсеры. А STAX, TRAX, XPATH  - это API для работы с ними."
  },
  {
    "category": "XML.",
    "question": "Что такое XPath?",
    "answer": "XPath (XML Path Language) - это язык запросов  который предназначен для произвольного обращения к частям XML или XHTML документа. В документе всегда имеется корневой элемент. У элемента дерева всегда существуют предки (кроме корневого элемента, у которого предков нет) и могут существовать потомки. Каждый элемент дерева находится на определенном уровне вложенности. У элементов на одном уровне бывают предыдущие и следующие за ним элементы. Строка XPath - это фактически путь к элементу в дереве, где каждый уровень разделяется косой чертой «/». В результате обработки выражения XPath получается объект, который может быть:      набор узлов (node-set) - неупорядоченный набор узлов без дубликатов     булево значение (boolean) - true или false     число (number) - число с плавающей точкой     строка (string) - последовательность UCS символов"
  },
  {
    "category": "XML.",
    "question": "Что такое XQuery?",
    "answer": "XQuery - это универсальный язык запросов к XML-данным, содержащий средства как для выборки, так и для трансформации XML-данных. XQuery синтаксически похож на SQL, его набор ключевых слов включает в себя FOR, LET, WHERE, ORDER BY или RETURN. С помощью XQuery можно выполнять сложные запросы, создавая сложные условия или упорядочивая результаты."
  },
  {
    "category": "XML.",
    "question": "Каким парсером можно сделать изменения в XML структуре и сохранить в файл?",
    "answer": "Изменение можно сделать с помощью DOM  и XPATH."
  },
  {
    "category": "XML.",
    "question": "Кратко опишите DOM, SAX, StAX анализаторы.",
    "answer": "DOM (Document Object Model - объектная модель документов) - платформенно-независимый программный интерфейс, позволяющий программами скриптам управлять содержимым документов HTML и XML, а также изменять их структуру и оформление. Модель DOM не накладывает ограничений на структуру документа. Любой документ известной структуры с помощью DOM может быть представлен в виде дерева узлов, каждый узел которого содержит элемент, атрибут, текстовый, графический или любой другой объект. Узлы связаны между собой отношениями родитель-потомок. SAX (Simple API for XML) базируется на модели последовательной одноразовой обработки и не создает внутренних деревьев. При прохождении по XML вызывает соответствующие методы у классов, реализующих интерфейсы, предоставляемые SAX-парсером. StAX (Streaming API for XML) не создает дерево объектов в памяти, но, в отличие от SAX-парсера, за переход от одной вершины XML к другой отвечает приложение, которое запускает разбор документа."
  },
  {
    "category": "XML.",
    "question": "Когда следует использовать DOM, а когда - SAX, StAX анализаторы?",
    "answer": "DOM-анализаторы следует использовать тогда, когда нужно знать структуру документа и может понадобиться изменять эту структуру либо использовать информацию из XML-документа несколько раз. SAX/StAX-анализаторы используются тогда, когда нужно извлечь информацию о нескольких элементах из XML-файла либо когда информация из документа нужна только один раз."
  },
  {
    "category": "XML.",
    "question": "Недостатки XML DTD перед XML Schema",
    "answer": "Недостатки XML DTD.      Отличный от XML синтаксис языка. То есть, DTD не является XML. В связи с этим могут возникать разнообразные проблемы с кодировкой и верификацией XML-документов.     Нет проверки типов данных. В XML DTD существует лишь один тип данных – строка. В связи с этим, например, если в числовом поле будет текст, документ все равно пройдет верификацию, так как XML DTD не может проверить тип данных.     Нельзя поставить в соответствие одному XML-документу больше одного DTD описания. То есть, верифицировать документ можно лишь одним DTD описанием. Если их несколько, то придется переделывать описания и совмещать все в одном файле, что очень неудобно.     Это были основные недостатки XML DTD, которые с успехом исправлены в промышленном стандарте описания XML-документов XML Schema."
  },
  {
    "category": "XML.",
    "question": "XML Schema - промышленный стандарт описания XML-документов",
    "answer": "Если быть кратким, то XML Schema делает следующее:      Описывает названия элементов и атрибутов (словарь).     Описывает взаимосвязь между элементами и атрибутами, а также их структуру (модель содержания).     Описывает типы данных.  Также хочу заметить, что на данный момент при помощи схем можно описывать практически все. То есть, схема - это универсальный способ описания грамматики данных, который может применяться не только для верификации XML-документов, но и описания баз данных и т.д. Таким образом, область применения схем на данный момент очень широкая."
  },
  {
    "category": "XML.",
    "question": "Что такое XSLT?",
    "answer": "XSLT (eXtensible Stylesheet Language Transformations) - расширяемый язык преобразования листов стилей. Язык XSLT служит транслятором, с помощью которого можно свободно модифицировать исходный текст. XLST играет решающую роль в утверждении XML в качестве универсального языка хранения и передачи данных. Область применения XSLT широка - от электронной коммерции до беспроводного Web."
  },
  {
    "category": "XML.",
    "question": "Что такое маршаллизация и демаршализация?",
    "answer": "Маршаллизация - механизм преобразования данных из java-объектов в конкретное хранилище, будь то документ XML, база данных или простой текстовый файл. Демаршаллизация - обратный процесс преобразования данных из внешних источников в структуру хранения, поддерживаемую виртуальной машиной. Проблемой остается организация взаимно однозначного соответствия информации в источнике, например, XML-документе, и экземпляре типа данных,принимающем эту информацию."
  },
  {
    "category": "XML.",
    "question": "Что такое JAXP?",
    "answer": "JAXP (Java API for XML Processing) - набор абстрактных API, упрощающих обработку XML данных с помощью программ, написанных на Java. Усиливает стандартные анализаторы SAX (Simple API for XML Parsing) и DOM (Document Object Model). JAXP также поддерживает преобразования расширяемого языка таблиц стилей (XSLT) стандарт, давая вам контроль над представлением данных и позволяя преобразовать данные в другие XML-документы или в другие форматы, такие как HTML. JAXP обеспечивает поддержку пространств имен (namespace), то есть имеется возможность работать с DTD. JAXP дает приложению возможность производить лексический разбор и модификацию документов XML независимо от конкретной реализации обработки XML. С версии 1.4, JAXP реализует API Потоковой передачи для XML (StAX) стандарт. Архитектура JAXP:"
  },
  {
    "category": "XML.",
    "question": "Назовите основные пакеты JAXP.",
    "answer": "JAXP (Java API for XML Processing) - набор абстрактных API, упрощающих обработку XML данных с помощью программ, написанных на Java. Усиливает стандартные анализаторы SAX (Simple API for XML Parsing) и DOM (Document Object Model). JAXP также поддерживает преобразования расширяемого языка таблиц стилей (XSLT) стандарт, давая вам контроль над представлением данных и позволяя преобразовать данные в другие XML-документы или в другие форматы, такие как HTML. JAXP обеспечивает поддержку пространств имен (namespace), то есть имеется возможность работать с DTD. JAXP дает приложению возможность производить лексический разбор и модификацию документов XML независимо от конкретной реализации обработки XML. С версии 1.4, JAXP реализует API Потоковой передачи для XML (StAX) стандарт. Архитектура JAXP:"
  },
  {
    "category": "XML.",
    "question": "Что такое JAXB?",
    "answer": "JAXB (Java Architecture for XML Binding) - это мост между XML и Java, Java API для маршалинга объекта в XML и восстановления (демаршалинг) объекта из XML файла. Часто используется в веб сервисах для представления объекта в виде XML схемы и передачи ее по сети. Также, такой способ передачи данных имеет свой плюс при обмене данных между системами, написанными на разных языках."
  },
  {
    "category": "Android",
    "question": "Clean Architecture",
    "answer": ""
  },
  {
    "category": "Android",
    "question": "Расскажите об операционной системе Android",
    "answer": "Android представляет собой операционную систему, написанную на основе ядра Linux. Ядро является главной частью ОС Linux, и практически полностью было перенесено в ОС Android, но с некоторыми модификациями, их около 250.  \n\nПо умолчанию система назначает каждому приложению уникальный идентификатор пользователя Linux, этот идентификатор используется только системой и для приложения не доступен. Система устанавливает полномочия для всех файлов в приложении, с тем чтобы доступ к ним был разрешен только пользователю с идентификатором, назначенным этому приложению. Android запускает процесс, когда требуется выполнить какой-либо компонент приложения, а затем завершает процесс, когда он больше не нужен либо когда системе требуется освободить память для других приложений.  \n\nНад ядром операционной системы располагается Android Runtime – среда выполнения приложений. Ключевыми её составляющими являются виртуальная машина Dalvik (Art), а также набор стандартных библиотек. Каждое приложение в ОС Android запускается в собственном экземпляре виртуальной машины."
  },
  {
    "category": "Android",
    "question": "Как работает приложение на Android?",
    "answer": "Программный код написанный разработчиком и все требуемые файлы данных и ресурсов, необходимые для корректной работы приложения компилируются в файл APK – программный пакет Android, который представляет собой файл архива с расширением .apk. В файле APK находится все, что требуется для работы Android-приложения, он позволяет установить приложение на любом устройстве под управлением системы Android.  \n\nAndroid не использует виртуальную машину Java (JVM) для выполнения файлов классов, вместо этого, в нём используется виртуальная машина Dalvik, не являющаяся истинной JVM и не работающая с Java байт-кодом. Начиная с версии Android 4.4 начала использоваться виртуальная машина Art (Android Runtime) и в версии Android 5.0 она полностью заменила Dalvik. На схеме приведены примеры исполнения обычного java-приложения, приложения для Android, а также приложения, созданного на фреймворке Xamarin.  \n\nДля платформы Android исходный java код транслируется в байт код и далее в далвик байт-код, с расширением .dex (Dalvik Executable Format), который понятен виртуальной машине Android."
  },
  {
    "category": "Android",
    "question": "Опишите структуру Android приложения",
    "answer": "Основные каталоги приложения: <brsrc – cодержит исходный код приложения \n\nanimator – содержит XML файлы, которые определяют свойства анимации \n\nanim – содержит XML файлы, которые определяют анимацию преобразований \n\ncolor – содержит XML файлы, которые определяют списки цветов \n\ndrawable – содержит графические файлы или XML файлы, которые компилируются в графические ресурсы \n\nlayout – содержит XML файлы, которые определяют расположение элементов пользовательского интерфейса \n\nmenu – содержит XML файлы, которые определяют все меню приложения \n\nvalues – содержит XML файлы, которые определяют простые значения, таких ресурсов как, строки, числа, цвета. \n\nmipmap – содержит изображение для лаунчера приложения \n\nAndroidManifest.xml – содержит основную информацию о приложении \n\n.gitignore – текстовый файл, содержащий список файлов и папок, которые будут игнорироваться системой контроля версий (VCS) и не будут загружены в удалённый репозиторий. \n\nproguard-rules.pro –  конфигурационный файл с правилами для утилиты Proguard \n\nsetting.gradle – все модули, которые содержит проект указываются в данным файле \n\nbuild.gradle – содержит информацию, используемую при построении проекта. Каждый модуль имеет свой файл build.gradle, который определяет подключенные библиотеки, конфигурацию построения проекта, специфичную для данного модуля \n\ngradle.proeprties – файл, содержащий настройки используемые при сборке проекта \n\ngradlew – используется Gradle Wrapper \n\nlocal.properties – файл используется только Gradle, содержит путь к Android SDK \n\nExternal Libraries – представляет собой перечень библиотек с расширением .jar, которые были подключены к нашему проекту"
  },
  {
    "category": "Android",
    "question": "Что такое Android Manifest?",
    "answer": "Каждое приложение в обязательном порядке должно содержать файл AndroidManifest.xml, который находится в корневой папке приложения.  Файл содержит в себе всю необходимую информацию о приложении, которая требуется системе Android. Проанализировав информацию файла AndroidManifest.xml, система может выполнить необходимый код приложения."
  },
  {
    "category": "Android",
    "question": "Назовите основные компоненты  Android приложение",
    "answer": "Основными компонентами приложения Android являются: \n\n– Activity \n\n– Service \n\n– Broadcast receiver \n\n– Content provider \n\nВсе компоненты Также некоторые относят к ним Intent, но на официальном сайте по разработке на Android он отсутствует."
  },
  {
    "category": "Android",
    "question": "Что такое Activity?",
    "answer": "Это компонент приложения, который представляет собой экран, с которым пользователи могут взаимодействовать для выполнения каких-либо действий, например набрать номер телефона, сделать фото, отправить письмо или просмотреть карту. Каждой Activity присваивается окно для прорисовки соответствующего пользовательского интерфейса."
  },
  {
    "category": "Android",
    "question": "Опишите жизненный цикл Activity",
    "answer": "Жизненный цикл представляет собой последовательность методов, которые вызываются в определенной последовательности во время создания/уничтожения/приостановки Activity.  \n\n– onCreate()Необходимо обязательно реализовать, поскольку система вызывает его при создании Activity. Важно именно здесь вызвать метод setContentView() для определения пользовательского интерфейса. Вызывается первым, во время создания Activity. Вызывается один раз, после чего наше Activity переходит в состояние Created. В данном методе мы инициализируем интерфейс нашего Activity, а также выполняем некоторую базовую логику, которая необходима нам для корректной работы Activity, например, создаём список с какими-либо данными. Также, в качестве аргумента метода onCreate нам передаётся объект Bundle, который содержит в себе информацию, которая была предварительно сохранена, во время пересоздания Activity. \n\n– onStart() Переводит нашу Activity в состояние Started, после чего Activity становится видно для пользователя. Метод может использоваться для какой-либо логики, которая взаимодействует с UI. \n\n– onResume() Наше Activity переходит на передний план приложения (foreground) изменяя своё состояние на Resumed. После вызова данного метода, пользователь может взаимодействовать с Activity. В данном состоянии Activity остается до тех пор, пока не потеряет фокус, это может произойти, например, при переходе на другую Activity, либо при входящем телефонном звонке. \n\n– onPause() Наше Activity теряет фокус, больше не видно для пользователя и выходит из состояния foreground. При этом Activity не уничтожается и продолжает существовать. В этом методе, например, мы можем приостановить логику связанную с GPS навигацией, чтобы минимизировать расход батареи. \n\n– onStop() Состояние Activity изменяется на Stopped. Вызывается, когда Activity не видно пользователю, например, при переходе на другой экран или при сворачивании приложения, а также при подготовке к полному уничтожению нашей Activity. системой. \n\n– onDestroy() Метод вызывается непосредственно перед уничтожением нашей Activity, например, после вызова метода finish(), или переходе на предыдущую Activity, путём нажатия кнопки “назад”. \n\nЕсли активность завершается, onDestroy() – это последний метод жизненного цикла, который вызывает Activity. Если onDestroy() вызывается в результате изменения конфигурации, система немедленно создает новый экземпляр активности вызывает onCreate() в новом экземпляре и новой конфигурации. Метод onDestroy() должен освобождать все ресурсы нашей Activity.  \n\nПри повороте экрана система полностью пересоздаёт экземпляр Activity. Для того, что сохранить какие-либо пользовательские данные и затем восстановить их в нашей Activity, используются следующие методы:  \n\n– onSaveInstanceState() Данный метод вызывается перед тем, как Activity будет уничтожена. Параметром метода является Bundle, в который мы будем складывать необходимые для сохранения данные. Рекомендуется сохранять данным способом информацию, объём которой не превышает 1 мегабайт, в случае превышения лимита мы получим ошибку TransactionTooLargeException. \n\n – onRestoreInstanceState() Вызывается после метода onStart(). В данный метод мы получим наш Bundle, в котором была сохранена информация.  \n\nСтоит заметить, что Bundle с сохранёнными данными мы также получаем в методе onCreate(), но данную ситуацию нужно отдельно обрабатывать, чтобы не получить NullPointerException."
  },
  {
    "category": "Android",
    "question": "Опишите Broadcast receiver?",
    "answer": "Приёмник широковещательных сообщений — это компонент для получения сообщений (Intent) и реагирования на них. Сообщения отправляются при помощи метода sendBroadcast(). Для обработки широковещательных сообщений необходимо создать объект IntentFilter и связать его с Broadcast receiver:  \n\nIntentFilter intentFilter = new IntentFilter() \n\nintentFilter.addAction(\"SOME_ACTION\") \n\nregisterReceiver(receiver, intentFilter)  \n\nЛибо зарегистрировать его в манифесте при помощи тега <intent-filter>.  \n\nBroadcastReceiver можно динамически зарегистрировать с помощью метода registerReceiver(), или статически создать его в тэге <receiver> в файле AndroidManifest приложения. Запускается в главном потоке приложения.  \n\nBroadcastReceiver может принимать сообщения от системы, например, если телефон был установлен на зарядку либо система Android была запущена."
  },
  {
    "category": "Android",
    "question": "Способ применения ContentProvider?",
    "answer": "Поставщик содержимого представляет собой оболочку над базой данных приложения. Если наше приложение использует базу данных SQLite, то только оно имеет к ней доступ. Поставщик содержимого применяется лишь в тех случаях, когда необходимо использовать данные совместно с другими приложениями, работающими на устройстве. Запускается в главном потоке приложения, поэтому для обработки запросов к базе данных, необходимо использовать другой поток. Например при помощи ContentProvider мы можем получить контакты из записной книги телефона или SMS."
  },
  {
    "category": "Android",
    "question": "Что такое ContentResolver?",
    "answer": "ContentResolver необходим для выполнения запросов к ContentProvider другого приложения. ContentResolver включает в себя методы CRUD (create, retrieve, update, delete) для запросов и транзакций. Объекту ContentResolver необходимо передать путь URI, в котором указано, к какому объекту ContentProvider необходимо обращаться."
  },
  {
    "category": "Android",
    "question": "Что такое Fragment?",
    "answer": "Fragment  представляет собой часть пользовательского интерфейса, который находится внутри Activity. Fragment имеет свой жизненный цикл и самостоятельно обрабатывает события ввода. В Activity одновременно может находиться несколько фрагментов. \n\nЖизненный цикл фрагмента выглядит следующим образом:  \n\n– onAttach()Вызывается, когда Fragment связывается со своей Activity, при этом элементы не инициализированы до конца. Можно использовать для получения ссылки для Activity и последующей работы с ней. \n\n– onCreate()Вызывается при создании фрагмента. В методе можно инициализировать компоненты, которые необходимы для работы фрагмента, но не связанные с пользовательским интерфейсом. \n\n– onCreateView()Фрагмент готов для инициализации пользовательского интерфейса. В данном методе необходимо указать R.layout.xxx, который содержит интерфейс фрагмента. \n\n– onActivityCreated()Вызывается после полной инициализации фрагмента и его родительской Activity. С текущего момента можно обращаться к объекту Context. \n\n– onStart()Переводит наш Fragment в состояние Started, после чего он становится виден для пользователя. Метод может использоваться для какой-либо логики, которая взаимодействует с UI. \n\n– onResume()Fragment становится доступен для взаимодействия с пользователем. \n\n– onPause()Метод вызывается когда пользователь покинул Fragment, например перешёл на другой фрагмент, либо закрыл родительскую Factivity. \n\n– onStop()Fragment переходит в состояние Stopped. \n\n– onDestroyView()Интерфейс Fragment уничтожается. \n\n– onDestroy()Вызывается для выполнения окончательного удаления Fragment из системы. Android не гарантирует вызов данного метода."
  },
  {
    "category": "Android",
    "question": "Как добавить Fragment к Activity?",
    "answer": "Для добавления/удаления/замены  Fragment в Activity необходимо воспользоваться классами FragmentManager и FragmentTransaction. \n\nFragmentManager fragmentManager = getSupportFragmentManager() \n\nFragmentTransaction fragmentTransaction = fragmentManager.beginTransaction()  \n\nЗамечу, что getFragmentManager() является deprecated методом, необходимо использовать getSupportFragmentManager() из пакета android.support.v4.app.  \n\nПосле создания необходимых объектов, необходимо вставить наш Fragment в xml разметку нашей Activity.  \n\nStackOfSkills fragment = new StackOfSkills() \n\nfragmentTransaction.add(R.id.fragment_container, fragment) \n\nfragmentTransaction.commit()"
  },
  {
    "category": "Android",
    "question": "Как гарантированно добавить Fragment к Activity?",
    "answer": "При выполнении транзакции и добавлении Fragment к Activity можно использовать асинхронный метод commit(). При передаче данных в Fragment, например отправка Broadcast или через EventBus, нет гарантии, что Fragment получит их. Гарантированную доставку данных в Fragment можно обеспечить путём использования метода commitNow() который вызывается синхронно."
  },
  {
    "category": "Android",
    "question": "Предназначение методов add, remove, hide, show, replace?",
    "answer": "– add()Добавляет Fragment в контейнер и отображает его UI, если метод onCreateView() возвращает не null. \n\n– remove()Удаляет существующий Fragment и его UI из контейнера, к которому он был добавлен. \n\n– hide()Если Fragment был добавлен к контейнеру, то метод скрывает его UI, при этом Fragment не уничтожается. Применимо только к Fragment находящемся в контейнере. \n\n– show()Делает Fragment видимым, который был скрыт методом hide(). Применимо только к Fragment находящемся в контейнере. \n\n– replace()Заменяет Fragment, которой был добавлен в контейнер, другим Fragment. Метод работает по принципу вызова remove() и затем add()."
  },
  {
    "category": "Android",
    "question": "Как сохранить данные в Fragment при повороте экрана (изменении конфигурации)?",
    "answer": "<bt>Fragment содержит переменную, отвечающую за сохранение экземпляра Fragment во время изменения конфигурации. По умолчанию она равна false. Для сохранения данных, в классе Fragment необходимо установить значение в true:  <bt>@Override     <bt>public void onCreate(Bundle savedInstanceState) {         <bt>super.onCreate(savedInstanceState)         <bt>setRetainInstance(true)     <bt>}"
  },
  {
    "category": "Android",
    "question": "Service",
    "answer": "Службы (Сервисы) в Android работают как фоновые процессы и представлены классом android.app.Service. Они не имеют пользовательского интерфейса и нужны в тех случаях, когда не требуется вмешательства пользователя. Сервисы работают в фоновом режиме, выполняя сетевые запросы к веб-серверу, обрабатывая информацию, запуская уведомления и т.д. Служба может быть запущена и будет продолжать работать до тех пор, пока кто-нибудь не остановит её или пока она не остановит себя сама. Сервисы предназначены для длительного существования, в отличие от активностей. Они могут работать, постоянно перезапускаясь, выполняя постоянные задачи или выполняя задачи, требующие много времени. \n\n \n\n Клиентские приложения устанавливают подключение к службам и используют это подключение для взаимодействия со службой. С одной и той же службой могут связываться множество клиентских приложений. \n\n \n\n Android даёт службам более высокий приоритет, чем бездействующим активностям, поэтому вероятность того, что они будут завершены из-за нехватки ресурсов, заметно уменьшается. По сути, если система должна преждевременно завершить работу запущенного сервиса, он может быть настроен таким образом, чтобы запускаться повторно, как только станет доступно достаточное количество ресурсов. В крайних случаях прекращение работы сервиса (например, задержка при проигрывании музыки) будет заметно влиять на впечатления пользователя от приложения, и в подобных ситуациях приоритет сервиса может быть повышен до уровня активности, работающей на переднем плане. \n\n \n\n Используя сервис, можете быть уверены, что ваши приложения продолжат работать и реагировать на события, даже если они в неактивном состоянии. Для работы службам не нужен отдельный графический интерфейс, как в случае с активностями, но они по-прежнему выполняются в главном потоке хода приложения. Чтобы повысить отзывчивость вашего приложения, нужно уметь переносить трудоёмкие процессы (например, сетевые запросы) в фоновые потоки, используя классы Thread и AsyncTask. \n\n \n\n Службы идеально подходят для проведения постоянных или регулярных операций, а также для обработки событий даже тогда, когда активности вашего приложения невидимы, работают в пассивном режиме или закрыты. \n\n \n\n Сервисы запускаются, останавливаются и контролируются из различных компонентов приложения, включая другие сервисы, активности и приёмники широковещательных намерений. Если ваше приложение выполняет задачи, которые не зависят от прямого взаимодействия с пользователем, сервисы могут стать хорошим выбором. \n\n \n\n Запущенные сервисы всегда имеют больший приоритет, чем бездействующие или невидимые активности, поэтому менее вероятно, что их работа завершится преждевременно при распределении ресурсов. Единственная причина, почему Android может досрочно остановить Сервис, — выделение дополнительных ресурсов для компонентов, работающих на переднем плане (как правило, для активностей). Если такое случится, ваш сервис автоматически перезапустится, когда будет достаточно доступных ресурсов. \n\n \n\n Когда сервис напрямую взаимодействует с пользователем (например, проигрывая музыку), может понадобиться повысить его приоритет до уровня активностей, работающих на переднем плане. Это гарантия того, что сервис завершится только в крайнем случае, но при этом снижается его доступность во время выполнения, мешая управлять ресурсами, что может испортить общее впечатление от приложения. \n\n \n\n Приложения, которые регулярно обновляются, но очень редко или нерегулярно взаимодействуют с пользователем, можно назвать первыми кандидатами на реализацию в виде сервисов. Проигрыватели MP3 и приложения, отслеживающие спортивные результаты, — примеры программ, которые должны постоянно работать и обновляться без необходимости отображать активность."
  },
  {
    "category": "Android",
    "question": "Что такое Service?",
    "answer": "Service (служба) — это компонент android-приложения без видимого интерфейса, который работает в фоновом режиме. Служба обязательно должна быть объявлена в файле AndroidManifest в теге application:  \n\n<application \n\n... \n\n<service \n\nandroid:name=\".ExampleService\" \n\nandroid:enabled=\"true\" \n\nandroid:label=\"StackOfSkillsService\"/> \n\n... \n\n</application>  \n\nService запускается в главном потоке приложения, поэтому если необходимо обработать в нём какую либо тяжёлую логику, необходимо создавать в нём новый поток.  \n\nService бывает нескольких типов: \n\n– Foreground Service \n\n– Background Service \n\n– Bound Service."
  },
  {
    "category": "Android",
    "question": "Какой жизненный цикл у Service?",
    "answer": "Какой жизненный цикл у Service?\n\n– onCreate()Вызывается один раз при первом создании сервиса методом startService(). Не вызывается при повторном использовании метода startService().\n\n– onStartCommand()Вызывается каждый раз при получении сервисом команды, отправленной с помощью метода startService(). Метод может возвращать флаг, который запускает сервис в определённом режиме\n\n– onBind()Вызывается при привязке (сервис живёт, пока жив клиент)  сервиса к клиенту (Activity) при помощью метода bindService()\n\n– onRebind()Вызывается при повторной привязке сервиса к клиенту\n\n– onUnbind()Вызывается при отвязке сервиса от клиента\n\n– onDestroy()Вызывается при уничтожении сервиса"
  },
  {
    "category": "Android",
    "question": "Какие существуют разновидности сервисов?",
    "answer": "Сервисы можно разделить на три вида: \n\n– Foreground ServiceСервис запущенный в данном режиме имеет высокий приоритет и не будет уничтожен системой, в случае нехватки памяти. Такой Service связывается с Notification, которое будет отображаться в статус баре. Запускается при помощи метода startForeground(). \n\n– Background ServiceРаботает в стандартном режиме, в фоне, в основном потоке приложения. Запускается при помощи метода startService(). \n\n– Bound ServiceService запущенный в данном режиме привязывается к какому-либо клиенту, например к Activity, и работает по принципу клиент-сервер. Service может быть привязан к нескольким клиентам, при этом система уничтожит сервис в случае, если все клиенты связанные с ним были уничтожены. Запускается при помощи метода bindService(). Для открепления сервиса от клиента используется метод unbindService(). При помощи интерфейса IBinder можно получить ссылку на наш сервис и вызывать методы непосредственно в нашем сервисе."
  },
  {
    "category": "Android",
    "question": "Что такое Intent Service?",
    "answer": "Intent Service – наследник класса Service. В отличие от Service, выполняется асинхронно в отдельном потоке. Сервис запускается методом startService() в котором передается Intent с необходимыми данными для работы. Обрабатывает входящий Intent в методе onHandleIntent(). После завершения всех необходимых операций над данными сервис прекращает свою работу."
  },
  {
    "category": "Android",
    "question": "Какие флаги запуска можно задать сервису?",
    "answer": "Метод  жизненного цикла сервиса onStartCommand()С может возвращать флаг, который описывает поведение сервиса, в случае если он был неожиданно остановлен, например системой из-за нехватки памяти:  – START_STICKY Сервис будет заново запущен системой и продолжит работу – START_REDELIVER_INTENT Сервис будет заново запущен системой и заново получит Intent который был передан методом startService() при запуске сервиса – START_NOT_STICKY Сервис остается в остановленном положении и не будет заново запущен системой – STOP_FOREGROUND_REMOVE Используется для отмены режима foreground и удаления Notification с которым связан сервис.Метод  жизненного цикла сервиса onStartCommand()С может возвращать флаг, который описывает поведение сервиса, в случае если он был неожиданно остановлен, например системой из-за нехватки памяти:– START_STICKYСервис будет заново запущен системой и продолжит работу– START_REDELIVER_INTENTСервис будет заново запущен системой и заново получит Intent который был передан методом startService() при запуске сервиса– START_NOT_STICKYСервис остается в остановленном положении и не будет заново запущен системой– STOP_FOREGROUND_REMOVEИспользуется для отмены режима foreground и удаления Notification с которым связан сервис.\n\nМетод  жизненного цикла сервиса onStartCommand()С может возвращать флаг, который описывает поведение сервиса, в случае если он был неожиданно остановлен, например системой из-за нехватки памяти:\n\n– START_STICKYСервис будет заново запущен системой и продолжит работу\n\n– START_REDELIVER_INTENTСервис будет заново запущен системой и заново получит Intent который был передан методом startService() при запуске сервиса\n\n– START_NOT_STICKYСервис остается в остановленном положении и не будет заново запущен системой\n\n– STOP_FOREGROUND_REMOVEИспользуется для отмены режима foreground и удаления Notification с которым связан сервис."
  },
  {
    "category": "Android",
    "question": "Пересоздается ли Activity при смене языка системы?",
    "answer": "Да, после смены языка происходит полный цикл создания Activity."
  },
  {
    "category": "Android",
    "question": "Что такое Zygote?",
    "answer": "Это служба, которая является обязательным компонентом Android-системы. Она отвечает за инициализацию, старт системных служб, запуск и остановку пользовательских приложений и запускается после виртуальной машины Dalvik."
  },
  {
    "category": "Android",
    "question": "Что такое Doze Mode?",
    "answer": "Режим работы системы Android, который запускается, в случае если устройство находится без активного использования и зарядки более одного часа. Данный режим ограничивает функциональность всех приложений, запрещая использовать сеть, Alarm’ы, планировщики."
  },
  {
    "category": "Android",
    "question": "Что такое App Standby?",
    "answer": "Режим работы приложения, который также ограничивает функциональные возможности. Система включает данный режим, если пользователь некоторое время не использует приложение и у приложения нет никаких уведомлений на экране блокировки или панели уведомлений."
  },
  {
    "category": "Android",
    "question": "В чем отличие Dialog от DialogFragment?",
    "answer": "Класс Dialog используется для отображения диалогового окна и не позволяет управлять его жизненным циклом. Класс DialogFragment представляет собой фрагмент, который содержит Dialog и позволяет управлять своим жизненным циклом, не допуская утечек памяти и других неявных проблем."
  },
  {
    "category": "Android",
    "question": "Что такое Target Fragment?",
    "answer": "Target Fragment используется для взаимодействия между фрагментами, когда один фрагмент, содержит в себе другой фрагмент. Таким образом можно взаимодействовать с родительским фрагментом, по аналогии с методом startActivityForResult() который используется для получения обратной связи в Activity."
  },
  {
    "category": "Android",
    "question": "Для чего нужен SnapHelper?",
    "answer": "Класс в Android, который предназначен для изменения поведения прокрутки элементов в RecyclerView. При помощи данного класса, можно сымитировать прокрутку элементов на одну позицию, как это делает ViewPager."
  },
  {
    "category": "Android",
    "question": "Что такое Flavors?",
    "answer": "Product flavors – это параметр в Gradle, который предоставляет возможность разделить наше приложение на несколько версий, которые будут иметь различный функционал, например, версии demo/full, разделение приложения для клиентов и администраторов.  \n\nproductFlavors {     \n\ndemo {         \n\ndimension \"version\"         \n\napplicationId \"com.stackofskills.demo\"         \n\nresValue \"string\", \"flavoredName\", \"Demo App\"     \n\n}      \n\nfull {        \n\n dimension \"version\"       \n\n  applicationId \"com.stackofskills.full\"       \n\n  resValue \"string\", \"flavoredName\", \"Full App\"   \n\n  } \n\n}"
  },
  {
    "category": "Android",
    "question": "Что такое  BuildType?",
    "answer": "Данный параметр в Gradle необходим для создания сборок нашего приложения с различными настройками, например каким сертификатом подписывать приложение, какие адреса использовать для сетевых запросов.  \n\nsigningConfigs {    \n\n config {      \n\n   keyAlias 'stackofskills'      \n\n   keyPassword 'password'       \n\n  storeFile file(C:/android/key/key.jks)      \n\n   storePassword 'password'   \n\n  } \n\n} \n\nbuildTypes {    \n\n release {     \n\n    minifyEnabled false     \n\n    proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'     \n\n    buildConfigField \"String\", 'URL', '\"https://stackofskills.com\"'    \n\n     signingConfig signingConfigs.config   \n\n  }   \n\n  debug {    \n\n     minifyEnabled false    \n\n     proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'   \n\n      buildConfigField \"String\", 'URL', '\"https://demo.stackofskills.com\"'  \n\n   } \n\n}"
  },
  {
    "category": "Android",
    "question": "Что такое BuildVariant?",
    "answer": "Это совокупность параметров BuildType и Flavors, для создания итоговых билдов приложения, содержащих все необходимые настройки."
  },
  {
    "category": "Android",
    "question": "Что такое View?",
    "answer": "View это базовый класс для создания элементов пользовательского интерфейса в Android приложении. Представляет из себя прямоугольную область и отвечает за обработку событий (например клика по экрану) и их отображение. UI элементы являются наследниками класса View, например Button, TextView и т.д. Обязательными параметрами у элементов являются ширина android:layout_width и высота android:layout_height."
  },
  {
    "category": "Android",
    "question": "Что такое ViewGroup?",
    "answer": "ViewGroup это класс, который наследуется от View. Представляет собой контейнер, предназначенный для хранения в себе других элементов View, например несколько Button и ImageView. Является базовым классом для контейнеров UI элементов, таких как LinearLayout, ConstraintLayout, RecyclerView и т.д.У любого объекта может быть связанный с ним целочисленный идентификатор, который служит для обозначения уникальности объекта View в иерархии."
  },
  {
    "category": "Android",
    "question": "Что такое XML?",
    "answer": "Extensible Markup Language (XML) – это язык разметки, предназначенный для структурирования, хранения и передачи информации. Язык имеет свой базовый синтаксис, благодаря которому можно размечать текст при помощи обрамляющих тегов, превращая каждое слово или предложение в идентифицируемую, сортируемую информацию. Язык XML не имеет предопределенных тегов."
  },
  {
    "category": "Android",
    "question": "Виды разметки в Android?",
    "answer": "В Android SDK имеется несколько типов контейнеров, позволяющие располагать элементы пользовательского интерфейса различными способами. Разметку можно создавать как программно, так и при помощи редактора XML файлов в Android Studio. Один макет может содержать один или несколько вложенных макетов, но рекомендуется использовать как можно более простую иерархию макетов. Чем меньше в макете вложенных элементов, тем быстрее выполняется его отрисовка, горизонтальная иерархия представлений эффективнее вертикальной.  \n\nОсновные виды разметки: \n\n– LinearLayoutРазметка, в которой элементы располагаются цепочкой поочередно. При указании параметра android:orientation=”vertical” View элементы располагаются друг под другом вертикально. При указании параметра android:orientation=”horizontal” View элементы располагаются друг за другом горизонтально. \n\n– FrameLayoutРазметка, в которой элементы прикрепляются к верхнему левому углу экрана и их местоположение нельзя изменить. При добавлении нескольких элементов в FrameLayout они будут рисоваться поверх предыдущих, если их размеры совпадают, либо частично перекрывать друг друга. \n\n– ReiativeLayoutРазметка, в которой элементы располагаются относительно родительского компонента или относительно соседних View элементов (по идентификатору элемента). \n\n– ConstraintLayoutРазметка, схожая по принципу с RelativeLayout. У каждого View элемента есть линии, на основании которых View располагается внутри ConstraintLayout. Эти линии (constraints) могут быть привязаны к сторонам самого ConstraintLayout или к сторонам других View внутри ConstraintLayout \n\n– TableLayoutРазметка, в которой элементы располагаются в табличной форме со строками и столбцами. Внутри TableLayout необходимо создавать элементы TableRow, которые будут являться строками и выстраиваться вертикально. Внутри TableRow можно размещать другие элементы, которые будут выстраиваться горизонтально. TableLayout не отображает разделительных линий для их строк, столбцов и ячеек, их необходимо реализовывать самостоятельно. Может иметь строки с разным количеством ячеек."
  },
  {
    "category": "Android",
    "question": "Как создать собственный View элемент?",
    "answer": "Есть несколько способов для создания кастомного View: \n\n– Расширить стандартный Android элементНапример, нам не хватает стандартных возможностей такого View элемента, как Button. Для расширения возможностей мы создаём свой класс и наследуемся от класса android.widget.Button. После чего мы можем переопределять своё поведение для View элемента. \n\n– Наследовать класс от класса ViewДанный способ предоставляет нам возможность нарисовать свой собственный UI элемент, наполнить его логикой обработки событий нажатия и т.д.  \n\nРассмотрим методы жизненного цикла View в Android  \n\n– Constructor Создание View начинается с конструктора, с различными входными параметрами, такими как Context, AttributeSet, defStyleAttr и  defStyleRes. \n\n– onAttachToWindow() После вызова данного метода, наша View прикрепляется к нашему Activity и знает о других элементах, которые также находятся на этом экране. \n\n– onMeasure() Метод определяет ширину и высоту вашего View, подтягивая данные из layout файла. При переопределении данного метода, необходимо указать ширину и высоту Вашего View самостоятельно, используя метод setMeasuredDimension(). \n\n– onLayout() Определяет размер и положение элементов каждого дочернего элемента View, если они имеются. \n\n– onDraw() Метод отвечает за рисование различных элементов внутри нашего View. Входным параметром метода является объект Canvas, при помощи которого мы и создаем элементы, такие как круг, текст, изображение и т.д.  \n\nДля обновления визуальной части нашего View, используется метод invalidate(). Например, мы нарисовали квадрат, и хотим изменить его цвет. Для этого мы вызываем метод invalidate() после чего у нашего View вызывается метод onDraw() и происходит перерисовка нашего квадрата с новым цветом.  \n\nВ случае, если у нашего View были изменены размеры, необходимо вызвать метод requestLayout(), после которого последует вызов методов, согласно жизненному циклу нашего View, т.е. onMeasure() → onLayout() → onDraw()."
  },
  {
    "category": "Android",
    "question": "Что такое Context?",
    "answer": "Context представляет собой абстрактный класс в Android, от которого наследуются важные классы Application, Activity, Service. Важно отметить, что Fragment не наследуется от Context.  \n\nКласс Context предоставляет следующие возможности: \n\n– получить доступ к различным ресурсам приложения, например к строковым ресурсам методом getString() или к графическим ресурсам getDrawable() \n\n– запускать Activity \n\n– отправлять широковещательное сообщения (broadcast) и регистрировать приёмники широковещательных сообщений (BroadcastReceiver) \n\n– запускать/останавливать сервисы, а также биндить их к Activity \n\n– получать пути к директориям приложения в памяти системы Android, например методом getFilesDir().  \n\n \n\nЧтобы получить объект класса Context, мы можем использовать следующие способы: \n\n–  внутри вложенного класса или метода получить ссылку на объект MainActivity – Activity.this \n\n– внутри фрагмента получить ссылку на объект родительской активности – getActivity \n\n– получить ссылку на базовый контекст – getBaseContext \n\n– получить ссылку на объект приложения – getApplicationContext \n\n– внутри активности или сервиса получить ссылку на этот объект – getContext \n\n– this (то же, что и getContext)"
  },
  {
    "category": "Android",
    "question": "Для чего используется Intent?",
    "answer": "Intent – это класс в Android, который используется для для следующих возможностей: \n\n– запуск Activity, передав объект Intent методу startActivity класса Context \n\n– запуск сервиса, передав объект Intent методу startService класса Context \n\n– отправка широковещательных сообщений, передав объект Intent методу sendBroadcast класса Context  \n\nIntent делится на два типа – явный (explicit) и неявный (Implicit). Явный объект Intent используется для запуска какого-либо конкретного компонента своего приложения, например.  \n\nIntent i = new Intent(this, ActivityTwo.class) startActivity(i)  \n\nНеявный объект Intent содержит в себе действие (Action), которое другому приложению необходимо выполнить, если оно это делать умеет, например отобразить карту или открыть PDF файл.  \n\nIntent i = new Intent(Intent.ACTION_VIEW, Uri.parse(\"https://stackofskills.com\")) \n\nstartActivity(i)"
  },
  {
    "category": "Android",
    "question": "Что такое Bundle?",
    "answer": "Bundle это потокобезопасный класс, который предназначен для хранения пар ключ-значение, т.е. мы можем положить в объект Bundle данные в виде примитивов либо объектов, реализующих интерфейс Parcelable. Может использоваться для передачи данных между Activity, для сохранения/восстановления данных при смены состояния Activity.  \n\nBundle b = new Bundle() \n\nString name = \"Ivan\" \n\nb.putString(\"name\", name) \n\nMan man = new Man() \n\nb.putParcelable(\"man\", man)"
  },
  {
    "category": "Android",
    "question": "Расскажите про класс Application?",
    "answer": "Application – класс в Android который позволяет отслеживать состояние приложения в целом. При создании процесса Android приложения (запуске приложения через launcher), в первую очередь всегда инициализируется класс Application и далее все остальные необходимые части приложения.  \n\nВ классе есть интерфейс ActivityLifecycleCallbacks, содержащий все методы жизненного цикла Activity, которые вызываются после вызова методов в Activity приложения.  \n\npublic interface ActivityLifecycleCallbacks {     \n\nvoid onActivityCreated(Activity activity, Bundle savedInstanceState)     \n\nvoid onActivityStarted(Activity activity)     \n\nvoid onActivityResumed(Activity activity)     \n\nvoid onActivityPaused(Activity activity)     \n\nvoid onActivityStopped(Activity activity)     \n\nvoid onActivitySaveInstanceState(Activity activity, Bundle outState)     \n\nvoid onActivityDestroyed(Activity activity) \n\n}  \n\nТакже класс содержит такие методы, как onLowMemory() и onTrimMemory() по отслеживанию использования памяти приложением.  \n\nContext ресурсоёмкий класс, но его можно использовать в классе Application в качестве Singleton, потому как Application повторяет жизненный цикл самого приложения и статический Context будет создаваться и умирать вместе с ним. Это не будет вызывать утечек памяти и такой подход весьма удобно использовать для работы приложения."
  },
  {
    "category": "Android",
    "question": "Расскажите про класс R в Android?",
    "answer": "final Класс R автоматически генерируется во время компиляции приложения инструментом aapt (Android Asset Packaging Tool), который предназначен для упаковки и компиляции всех ресурсов приложения. В классе находятся идентификаторы для всех ресурсов созданных в каталоге res, например для графических ресурсов класс R.drawable. Для каждого типа ресурсов предусмотрен свой подкласс (R.dimen, R.layout и т.д.). Также для каждого ресурса указанного типа создается статическая целочисленная переменная, например R.drawable.image. Эта переменная служит идентификатором ресурса, которую можно использовать для его получения."
  },
  {
    "category": "Android",
    "question": "Что такое Looper и MessageQueue?",
    "answer": "MessageQueue – класс, который хранит список из объектов Message, которые должны быть выполнены по принципу FIFO. и взаимодействует с Looper для обработки сообщений. \n\n Looper – класс, предназначенный для обработки очереди MessageQueue, в которую Handler отправляет сообщения (объекты Message) о необходимости обработать изменения в приложении. После запуска приложения, в его основном потоке создаётся экземпляр Looper, главный UI Looper приложения, который при помощи метода loop() запускает бесконечный цикл и проверяет, появились ли новые сообщения в MessageQueue. \n\n При создании нового потока, необходимо обязательно создать looper внутри него, при помощи последовательного вызова методов Looper.prepare() → Looper.loop(), иначе при попытке изменить данные в UI потоке приложения, произойдёт ошибка. \n\n class StackOfSkillsThread extends Thread { \n\n      public Handler mHandler     \n\n  public void run() {         \n\n  Looper.prepare()           \n\nmHandler = new Handler() {              \n\n public void handleMessage(Message msg) {                \n\n   // some logic here               \n\n}           \n\n}           \n\nLooper.loop()       \n\n}   \n\n} \n\n Для завершения работы Looper необходимо вызвать метод quitSafely() для того чтобы завершить работу Looper и быть уверенным в том, что все сообщения в MessageQueue были обработаны."
  },
  {
    "category": "Android",
    "question": "Что такое Handler и HandlerThread?",
    "answer": "Handler это класс, который предназначен для управления потоками в приложении. Получает сообщения от Looper из MessageQueue и он же отправляет сообщения в MessageQueue. С его помощью мы можем связать UI поток нашего приложения с другими потоками. \n\n При создании нового объекта Handler, по умолчанию он привязывается к этому потоку и MessageQueue в этом же потоке. Т.е. если мы создаём новый Thread и в нём создаём Handler, то он не будет иметь доступа к UI потоку приложения. Для взаимодействия с UI потоком, необходимо инициализировать looper в этом потоке, либо предоставить Main Looper для нашего Handler \n\n Handler mHandler = new Handler(Looper.getMainLooper()) \n\n HandlerThread – класс, который наследуется от Thread. Уже включает в себя Looper, MessageQueue и готов для создания нового потока, с последующей передачей данных в UI поток."
  }
]